<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 아겔로그</title>
    <link>http://localhost:1313/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 아겔로그</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© &lt;a href=&#39;http://localhost:1313/myself&#39;&gt;ageldama&lt;/a&gt; 👾</copyright>
    <lastBuildDate>Wed, 12 Mar 2025 10:40:27 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>data-driven programming &amp; data-driven design &amp; data-oriented programming ???</title>
      <link>http://localhost:1313/posts/2025-03mar/2025-03mar12--01-data-prog/</link>
      <pubDate>Wed, 12 Mar 2025 10:40:27 +0000</pubDate>
      <guid>http://localhost:1313/posts/2025-03mar/2025-03mar12--01-data-prog/</guid>
      <description>&lt;p&gt;&#xA;비슷한 용어들. 내가 이해한 정리들은 &lt;sup class=&#34;footnote-reference&#34;&gt;&lt;a id=&#34;footnote-reference-1&#34; href=&#34;#footnote-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;data-driven programming&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;데이터처리를 중심으로 하는 프로그래밍언어나 도구, 스타일.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  예를 들어, awk, perl은 입력의 패턴에 따라 코드를 나누고 출력을&#xA;  만들기 수월한 방식을 제공.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Data-driven_programming&#34;&gt;https://en.wikipedia.org/wiki/Data-driven_programming&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Perl/perl5/commit/8d063cd8450e59ea1c611a2f4f5a21059a2804f1&#34;&gt;a &amp;#34;replacement&amp;#34; for awk and sed&lt;/a&gt; (by Larry Wall)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-2&#34;&gt;&#xA;data-oriented design&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;현대 cpu의 아키텍처에 적절하도록, cpu cache, simd등을 잘 적용될 수&#xA;  있도록 애플리케이션 데이터구조를 설계하는 방식.&lt;sup class=&#34;footnote-reference&#34;&gt;&lt;a id=&#34;footnote-reference-2&#34; href=&#34;#footnote-2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  그리고 단순히 게임개발에서 ecs만이 아니라 lmax disruptor등도 포함될&#xA;  것 같다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Data-oriented_design&#34;&gt;https://en.wikipedia.org/wiki/Data-oriented_design&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;dod의 예시: &lt;a href=&#34;https://en.wikipedia.org/wiki/Entity_component_system&#34;&gt;Entity component system&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://martinfowler.com/articles/lmax.html&#34;&gt;lmax disruptor&lt;/a&gt; (by Martin Fowler)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-3&#34;&gt;&#xA;data-oriented programming&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;그리고 또 갑자기 위 2개의 정의처럼 완전 갑자기, dop은 다음과 같은&#xA;  원칙들을 이용한 애플리케이션 개발방식:&lt;/p&gt;</description>
    </item>
    <item>
      <title>xmake, compile_commands.json, flycheck</title>
      <link>http://localhost:1313/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</link>
      <pubDate>Mon, 06 May 2024 07:51:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</guid>
      <description>&lt;p&gt;&#xA;cmake/warp등을 써보면서 c/c++ 개발할 때에 빌드도구 갖고 놀다가,&#xA;이번에 마음을 열고 xmake을 익혀봄.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;마음에 든다. 가볍고 빠르고 좋다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;ccache등도 바로 지원하고, lua으로 스크립팅도 그럭저럭 할만해 보이고,&#xA;[build.zig](&lt;a href=&#34;https://ziglang.org/learn/build-system/)&#34;&gt;https://ziglang.org/learn/build-system/)&lt;/a&gt;스러워서&#xA;당연하게도 좋은거 같아.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;계속 쓸거 같다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;emacs / flycheck + c/c++ 개발할 때에 단점이, 자동적으로 외부 3rd-party&#xA;라이브러리의 include-path을 설정해주지 않아서,&#xA;[dirs-local](&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html)&#34;&gt;https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html)&lt;/a&gt;&#xA;같은걸 세팅해주길 기대한다는 점.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;그래서 그냥 &lt;code&gt;xmake project -vD -k compile_commands -m debug&lt;/code&gt; 같이&#xA;&lt;code&gt;compile_commands.json&lt;/code&gt; 생성하고,&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;이걸 파싱해서 표준출력으로 include-paths&#xA;&lt;a href=&#34;https://github.com/ageldama/configs/blob/master/compile_commands_json_incdirs.py&#34;&gt;https://github.com/ageldama/configs/blob/master/compile_commands_json_incdirs.py&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;현재 소스코드 버퍼 기준으로 가장 가까운 compile_commands.json 파일&#xA;위치 찾는 elisp 함수&#xA;&lt;a href=&#34;https://github.com/ageldama/configs/blob/master/emacs/elisp/compcmdsjson-tiny.el&#34;&gt;https://github.com/ageldama/configs/blob/master/emacs/elisp/compcmdsjson-tiny.el&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;위 (1)+(2)을 조합해서 flycheck을 위한 변수 &lt;sup class=&#34;footnote-reference&#34;&gt;&lt;a id=&#34;footnote-reference-1&#34; href=&#34;#footnote-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 들을 설정하는 elisp 함수&#xA;&lt;a href=&#34;https://github.com/ageldama/configs/blob/master/emacs/elisp/flycheck-compcmdsjson.el&#34;&gt;https://github.com/ageldama/configs/blob/master/emacs/elisp/flycheck-compcmdsjson.el&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;그리고 위 (3)을 c/c++-mode에 자동적으로 적용하고, 또 단축키도&#xA;만드는 elisp 코드&#xA;&lt;a href=&#34;https://github.com/ageldama/configs/blob/master/emacs/feat/flycheck-compcmdsjson.el&#34;&gt;https://github.com/ageldama/configs/blob/master/emacs/feat/flycheck-compcmdsjson.el&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&#xA;…요렇게 만들어서 세팅해서 쓰니 편안.&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;: Golang-ish `defer`-macro</title>
      <link>http://localhost:1313/posts/2023-03mar/cxx-defer/</link>
      <pubDate>Thu, 02 Mar 2023 16:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2023-03mar/cxx-defer/</guid>
      <description>&lt;p&gt;&#xA;별거 없는데, 문득 심심해서 툭닥거려봤다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;div&gt;&#xA;  &lt;nav id=&#34;TableOfContents&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#headline-1&#34;&gt;원하는 것과 접근법&lt;/a&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#headline-2&#34;&gt;&lt;code class=&#34;verbatim&#34;&gt;defer.inl&lt;/code&gt; :&lt;/a&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#headline-3&#34;&gt;사용예&lt;/a&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#headline-4&#34;&gt;제약사항과 생각해볼꺼리&lt;/a&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#headline-5&#34;&gt;Footnotes&lt;/a&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&#xA;&lt;/div&gt;&#xA;&lt;/p&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;원하는 것과 접근법&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://go.dev/blog/defer-panic-and-recover&#34;&gt;https://go.dev/blog/defer-panic-and-recover&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.rs/defer/latest/defer/fn.defer.html&#34;&gt;https://docs.rs/defer/latest/defer/fn.defer.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ziglang.org/documentation/master/#defer&#34;&gt;https://ziglang.org/documentation/master/#defer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&#xA;  golang/zig에서처럼 &lt;code class=&#34;verbatim&#34;&gt;defer&lt;/code&gt; 등록한 LIFO순서대로 호출되도록.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  검색해보면, 대부분 RAII을 사용하거나 하는 것들이 보인다:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://duckduckgo.com/?q=c%2B%2B+golang+defer&#34;&gt;DDG: c++ golang defer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/33050620/golang-style-defer-in-c&#34;&gt;https://stackoverflow.com/questions/33050620/golang-style-defer-in-c&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/45617758/proper-way-to-release-resources-with-defer-in-a-loop&#34;&gt;https://stackoverflow.com/questions/45617758/proper-way-to-release-resources-with-defer-in-a-loop&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://codesire-deng.github.io/2022/02/06/One-Minute-to-C-defer/&#34;&gt;https://codesire-deng.github.io/2022/02/06/One-Minute-to-C-defer/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&#xA;  …그냥 &lt;code class=&#34;verbatim&#34;&gt;std::shared_ptr&amp;lt;void&amp;gt;&lt;/code&gt; 을 이용하는 방식이 마음에&#xA;  들었다. 그리고 조금 더 간단하게 사용하려고 매크로로 만들어 봤다.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-2&#34;&gt;&#xA;&lt;code class=&#34;verbatim&#34;&gt;defer.inl&lt;/code&gt; :&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;div class=&#34;src src-c++&#34;&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#1&#34;&gt; 1&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#2&#34;&gt; 2&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#3&#34;&gt; 3&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#4&#34;&gt; 4&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#5&#34;&gt; 5&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#6&#34;&gt; 6&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#7&#34;&gt; 7&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#8&#34;&gt; 8&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#9&#34;&gt; 9&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#10&#34;&gt;10&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#11&#34;&gt;11&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#12&#34;&gt;12&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#13&#34;&gt;13&lt;/a&gt;&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* -*- mode: c++; -*- */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cp&#34;&gt;#ifndef defer_INL&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;cp&#34;&gt;#define defer_INL 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cp&#34;&gt;#define _Defer_CONCAT_IMPL( x, y ) x##y&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;cp&#34;&gt;#define _Defer_CONCAT( x, y ) _Defer_CONCAT_IMPL( x, y )&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cp&#34;&gt;#define Defer(blk) std::shared_ptr&amp;lt;void&amp;gt; _Defer_CONCAT(Defer_, __COUNTER__ )(nullptr, blk)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cp&#34;&gt;#endif &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*defer_INL*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;&#xA;  &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html&#34;&gt;&lt;code class=&#34;verbatim&#34;&gt;__COUNTER__&lt;/code&gt;&lt;/a&gt; 이용해서 매크로가 생성한 &lt;code class=&#34;verbatim&#34;&gt;std::shared_ptr&amp;lt;..&amp;gt;&lt;/code&gt; 변수의&#xA;  이름이 겹치지 않도록 해봤다. (…위에 검색한 링크들에도 사용하듯이)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ping 07/02/2023 .01 : C&#43;&#43;, D, Zig의 이름에 대한 추측</title>
      <link>http://localhost:1313/posts/2023-02feb/2023-02feb07--01-ping/</link>
      <pubDate>Tue, 07 Feb 2023 07:48:17 +0000</pubDate>
      <guid>http://localhost:1313/posts/2023-02feb/2023-02feb07--01-ping/</guid>
      <description>&lt;p&gt;&#xA;문득 떠오른 생각이라서, 그냥 추측.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;/strong&gt; : &lt;em&gt;로마숫자(roman numeral)&lt;/em&gt; 으로 100.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;처음부터 의도한 숫자가 100이 아니었을거란건 나도 알거 같아.&#xA;BCPL이나 그런 역사에 대해 나도 조금은 아니까.&lt;/li&gt;&#xA;&lt;li&gt;그런데 그 이후에 따르는 언어들이 그런 패턴을 만든거 같아서 재미로&#xA;쓰는 글.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/strong&gt; : 위의 로마숫자이란 생각과 &lt;em&gt;C언어의 &lt;code&gt;x++&lt;/code&gt; 연산&lt;/em&gt; 으로 생각해보면,&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;즉시 평가할 때에는 C == 100, 그냥 C와 같아 보임.&lt;/li&gt;&#xA;&lt;li&gt;그런데 저장된 값은 +1, == 101.&lt;/li&gt;&#xA;&lt;li&gt;…어쨌든 그냥 볼 때엔, 씨언어와 거의 같아 보이지만, 그래도 좀&#xA;더 성장했다고. 그리고 겸손하게 오직 +1.&lt;/li&gt;&#xA;&lt;li&gt;(그냥 겸손하다고 될 문제인가 싶다… C++ 좋아하지만 ㅎㅎ)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;D&lt;/strong&gt;&lt;/strong&gt; : C에서 다음 단계으로 발전했으니, 이번엔 다섯배, 역시 로마숫자, 500.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python에 대한 내 관점</title>
      <link>http://localhost:1313/posts/2020-09sep/perspective-on-python/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2020-09sep/perspective-on-python/</guid>
      <description>&lt;p&gt;&#xA;Python은 조금 지루한 문법의 언어다. 거기에 매크로 같은 기능도 없어서&#xA;항상 평이한 문장을 작성하게 되는 것 같다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;하지만 다른 비슷한 언어들과는 다르게, 파이썬 문장 자체는 깔끔하면서도&#xA;density가 높다. 리습, 하스켈 같은 언어들으로 작성한 것을 생각해봐도&#xA;밀도가 높아 표현력이 좋다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;Java와 같은 언어는 밀도도 낮고 표현력도 가끔은 너무 아쉽다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;파이썬이 이렇게 밀도가 높을 수 있는 이유는, 언어 자체적으로 매크로를&#xA;지원하거나 해서 문법을 확장하는 방법을 채택하는 것이 아니라 SymPy에서&#xA;그랬었던 것처럼 값을 계속 쌓아갈 수 있게 만들고 연산자를 재정의해서&#xA;문장이 다르게 해석되도록 만드는 방법이고, 이쪽이 더 Pythonic한 방법&#xA;같다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ping 14/Aug/2020</title>
      <link>http://localhost:1313/posts/2020-08aug/ping-14fri/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2020-08aug/ping-14fri/</guid>
      <description>&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;빌드도구의 경험과 Meson을 사용하기&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;&#xA;  &lt;a href=&#34;https://github.com/ageldama/meson-abc&#34;&gt;Meson-ABC 갖고 놀아본 코드&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  아주 예전에 commercially 성공적이었었던 C++ 프로젝트를 홀로 기획, 설계, 개발했었었다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  처음에는 GNU Makefile으로 간단히 시작했었었다. 타겟 플랫폼이 뻔하게 윈도였기 때문이다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  그 이전에는 ANSI C으로 작성한 &lt;a href=&#34;https://sourceforge.net/projects/sdlhan/&#34;&gt;SDL 조합형 비트맵 출력 오픈소스&lt;/a&gt;&#xA;  라이브러리 같은 것들을 작업할 때는 그냥 GNU Autotools 을 쓰거나&#xA;  했었었다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  하지만 그렇게 configure 하거나 할 부분도 없고 처음 혼자 시작하며&#xA;  다른 신경 쓸 것도 무지하게 많았었던 프로젝트였고 더욱이 기간도&#xA;  한정적이었었다.&lt;sup class=&#34;footnote-reference&#34;&gt;&lt;a id=&#34;footnote-reference-1&#34; href=&#34;#footnote-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  그리고 SCons 같은 것을 조금 쓰다가, 결국 더 간단히 Rake으로 빌드를&#xA;  작성해 한동안 썼었다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>direnv &#43; direnv-mode 이맥스 지원 &#43; C/C&#43;&#43;/Python등 프로젝트 설정 적용하기</title>
      <link>http://localhost:1313/posts/2019-12dec/direnv/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2019-12dec/direnv/</guid>
      <description>&lt;p&gt;&#xA;프로젝트의 빌드 디렉토리, virtualenv와 같은 경로의 설정, &#xA;경로 설정에 따른 빌드/실행/테스팅/스크립트을 편하게 하려고 만든&#xA;&lt;a href=&#34;http://localhost:1313/posts/2019-12dec/moonshot-1st-rel/&#34;&gt;moonshot.el&lt;/a&gt; 와 유사한걸 검색해봤다.&lt;/p&gt;&#xA;&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;몇 가지&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;이런 비슷한게 몇 가지 있는데, 내 상황에 쓸만한 것은 direnv&lt;/p&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-3&#34;&gt;&#xA;&lt;h3 id=&#34;headline-2&#34;&gt;&#xA;NPM: dotenv&#xA;&lt;/h3&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-3&#34;&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/dotenv&#34;&gt;https://www.npmjs.com/package/dotenv&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;Node.js에서 Unix environment variable으로 &lt;code&gt;.env&lt;/code&gt; 파일을 로딩해주는&#xA;역할인 듯.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;Shell에서 Hook 걸어서 사용하기엔 별로 인거 같았다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;그리고 Node.js 이외의 프로젝트에 적용하려면 매번 JS으로 wrapper을&#xA;짜주고 하기 싫었고,&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;code&gt;.env&lt;/code&gt; 파일이 그냥 정적인 key-value 문자열의 나열이라, 파일시스템에서&#xA;경로를 조립하고 하는데 별로라는 생각이 들었다. 항상 절대 경로만&#xA;표기하거나, &lt;code&gt;getenv&lt;/code&gt; 해서 문자열을 가져와서 상대 경로 등으로 지정된&#xA;값을 매번 절대 경로로 만드는 작업을 해야할테니까.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ivy/Counsel으로 바꾸기, 기능들 만들기 (w/ C&#43;&#43;지원, &#43;&#43;rmsbolt)</title>
      <link>http://localhost:1313/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</link>
      <pubDate>Tue, 26 Feb 2019 01:00:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</guid>
      <description>&lt;p&gt;최근에 이맥스 설정을&#xA;&lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;Helm&lt;/a&gt;기반에서&#xA;&lt;a href=&#34;https://github.com/abo-abo/swiper&#34;&gt;Ivy/Counsel&lt;/a&gt;으로 전부 바꿨다.&lt;/p&gt;&#xA;&lt;p&gt;더 가볍고, 적당히 잘 동작하고,&#xA;&lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;Ripgrep&lt;/a&gt;이랑 기본적으로&#xA;설정이 가능해서 편함.&lt;/p&gt;&#xA;&lt;p&gt;거기에 &lt;code&gt;C-c C-o&lt;/code&gt;&#xA;(&lt;a href=&#34;https://oremacs.com/2015/11/04/ivy-occur/&#34;&gt;ivy-occur&lt;/a&gt;) +&#xA;&lt;a href=&#34;https://github.com/mhayashi1120/Emacs-wgrep&#34;&gt;wgrep&lt;/a&gt;이 Helm에선&#xA;동작할때가 그때그때 기능에 따라 달라서 짜증나고, 심지어 플러그인을&#xA;설정해서 써야하거나 해서 정말 좋아하는 기능인데 우울하게 만들었는데,&#xA;Ivy이 훨씬 깔끔하게 동작하고 일관성있게 잘 동작함.&lt;/p&gt;&#xA;&lt;p&gt;처음에는 Helm에서 하는 기능들을 그대로 옮기려고만 생각하다가, 오히려&#xA;Ivy에 맞춰서 내가 익숙해지고, 더 낫게 할 방법들이 있어서 그냥 내가&#xA;adopt해서 편안해졌다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;cmake--compile_commandsjson&#34;&gt;CMake + &lt;code&gt;compile_commands.json&lt;/code&gt;&lt;/h1&gt;&#xA;&lt;p&gt;이전에는 &lt;a href=&#34;https://github.com/Andersbakken/rtags&#34;&gt;RTags&lt;/a&gt;을 사용해서&#xA;&amp;lsquo;&amp;lsquo;정말로&amp;rsquo;&amp;rsquo; C++ 프로젝트를 Clang등을 이용해서 파싱하고, 그걸&#xA;인덱싱한걸로 정확한 navigation, code completion을 구성해 사용하려고&#xA;했었었다. 그리고 타입 정보다 그런거 다 있으니 제대로 굴러가서 꽤&#xA;쓸만하고.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CQuery &#43; LSP vs CMake-IDE &#43; RTags</title>
      <link>http://localhost:1313/posts/2018-09sep/cquery-vs-cmake-ide/</link>
      <pubDate>Sun, 23 Sep 2018 12:00:00 +0900</pubDate>
      <guid>http://localhost:1313/posts/2018-09sep/cquery-vs-cmake-ide/</guid>
      <description>&lt;p&gt;LSP + CQuery을 써보려고 했는데, 결국 &lt;a href=&#34;http://localhost:1313/posts/2018-05may-emacs-cmake-ide-screencast/&#34;&gt;CMake-IDE +&#xA;RTags&lt;/a&gt; 조합으로&#xA;원래대로 쓰게될거 같아. :&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;_build/&lt;/code&gt; 와 같이 CMake, Ninja, Makefile등의 파일들을 별도의&#xA;디렉토리로 만들어서 필드하고 싶은데, 제대로 지원을 못한다.&#xA;1. 그냥 프로젝트 소스코드랑 같이 generate하고 &lt;code&gt;gcc&lt;/code&gt;등의 중간&#xA;파일이 모두 같이 남아서 지저분해져서 싫어함.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;아직은 별로 내 마음에 꼭 들게 만들기는 어려울거 같아서. 그래도&#xA;인상적이었던 부분들:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;flycheck에 전용으로 연동되어 있는 점.&lt;/li&gt;&#xA;&lt;li&gt;company-lsp이 생각보다 훨씬 부드럽고 자동완성 잘되는거.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;미래에는 그냥 LSP기반만 남을거 같아서, 이것도 &amp;ldquo;helm-rg의 모험&amp;quot;처럼&#xA;아직은 완전히 전환은 못할거 같긴하다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
