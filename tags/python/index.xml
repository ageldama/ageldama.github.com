<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on 아겔로그</title>
    <link>https://ageldama.github.io/tags/python/</link>
    <description>Recent content in python on 아겔로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <copyright>All rights reserved to ageldama</copyright>
    <lastBuildDate>Mon, 06 May 2024 07:51:13 +0000</lastBuildDate><atom:link href="https://ageldama.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>xmake, compile_commands.json, flycheck</title>
      <link>https://ageldama.github.io/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</link>
      <pubDate>Mon, 06 May 2024 07:51:13 +0000</pubDate>
      
      <guid>https://ageldama.github.io/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</guid>
      <description>cmake/warp등을 써보면서 c/c++ 개발할 때에 빌드도구 갖고 놀다가, 이번에 마음을 열고 xmake을 익혀봄.
마음에 든다. 가볍고 빠르고 좋다.
ccache등도 바로 지원하고, lua으로 스크립팅도 그럭저럭 할만해 보이고, [build.zig](https://ziglang.org/learn/build-system/)스러워서 당연하게도 좋은거 같아.
계속 쓸거 같다.
emacs / flycheck + c/c++ 개발할 때에 단점이, 자동적으로 외부 3rd-party 라이브러리의 include-path을 설정해주지 않아서, [dirs-local](https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html) 같은걸 세팅해주길 기대한다는 점.
그래서 그냥 xmake project -vD -k compile_commands -m debug 같이 compile_commands.json 생성하고,
이걸 파싱해서 표준출력으로 include-paths https://github.</description>
    </item>
    
    <item>
      <title>Python &#43; Generator / LeetCode &#34;1614. max nesting depth of the parentheses&#34;</title>
      <link>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</guid>
      <description>지난 번 작성한 Common Lisp / LOOP매크로을 이용한 구현 을 다른 언어에서였다면, 비슷한 조건으로 메모리 복잡도 O(1)으로 풀어보고 싶었다.
from itertools import accumulate def find_paren_count(s): gen_only_parens = (ch == &amp;#39;(&amp;#39; and 1 or -1 for ch in s if ch in (&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;,)) return max(accumulate(gen_only_parens)) 다른 언어에서도 lazy stream을 지원한다면 비슷하게 풀 수 있을 것 같다.</description>
    </item>
    
    <item>
      <title>Python에 대한 내 관점</title>
      <link>https://ageldama.github.io/posts/2020-09sep/perspective-on-python/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-09sep/perspective-on-python/</guid>
      <description>Python은 조금 지루한 문법의 언어다. 거기에 매크로 같은 기능도 없어서 항상 평이한 문장을 작성하게 되는 것 같다.
하지만 다른 비슷한 언어들과는 다르게, 파이썬 문장 자체는 깔끔하면서도 density가 높다. 리습, 하스켈 같은 언어들으로 작성한 것을 생각해봐도 밀도가 높아 표현력이 좋다.
Java와 같은 언어는 밀도도 낮고 표현력도 가끔은 너무 아쉽다.
파이썬이 이렇게 밀도가 높을 수 있는 이유는, 언어 자체적으로 매크로를 지원하거나 해서 문법을 확장하는 방법을 채택하는 것이 아니라 SymPy에서 그랬었던 것처럼 값을 계속 쌓아갈 수 있게 만들고 연산자를 재정의해서 문장이 다르게 해석되도록 만드는 방법이고, 이쪽이 더 Pythonic한 방법 같다.</description>
    </item>
    
    <item>
      <title>direnv &#43; direnv-mode 이맥스 지원 &#43; C/C&#43;&#43;/Python등 프로젝트 설정 적용하기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/direnv/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-12dec/direnv/</guid>
      <description>프로젝트의 빌드 디렉토리, virtualenv와 같은 경로의 설정, 경로 설정에 따른 빌드/실행/테스팅/스크립트을 편하게 하려고 만든 moonshot.el 와 유사한걸 검색해봤다.
몇 가지 이런 비슷한게 몇 가지 있는데, 내 상황에 쓸만한 것은 direnv
NPM: dotenv https://www.npmjs.com/package/dotenv
Node.js에서 Unix environment variable으로 .env 파일을 로딩해주는 역할인 듯.
Shell에서 Hook 걸어서 사용하기엔 별로 인거 같았다.
그리고 Node.js 이외의 프로젝트에 적용하려면 매번 JS으로 wrapper을 짜주고 하기 싫었고,
.env 파일이 그냥 정적인 key-value 문자열의 나열이라, 파일시스템에서 경로를 조립하고 하는데 별로라는 생각이 들었다.</description>
    </item>
    
    <item>
      <title>예전 모나드를 이용한 비동기코드의 정리에 대한 아이디어를 다시 생각해보기</title>
      <link>https://ageldama.github.io/posts/2017/2017-02-26-aync-rxjava-and-monad/</link>
      <pubDate>Sun, 26 Feb 2017 13:50:00 +0100</pubDate>
      
      <guid>https://ageldama.github.io/posts/2017/2017-02-26-aync-rxjava-and-monad/</guid>
      <description>예전 내가 썼던 블로그가 갑자기 떠올랐다. http://ageldama.blogspot.de/2012/03/nodejs-haskell-io-monad.html
내용은,
콜백헬 싫다. 그런데, 하스켈의 IO Monad처럼 imperative code을 작성할 수 있으면, 3. 이것들끼리의 제어권을 주고 받는걸 event loop측에서 제어하면서도, 4. 각각의 statements끼리 그냥 주욱 흐름대로 작성한것과 다르지 않게 짜기 쉽다. 굳이 이 얘기 왜 하냐하면, 사실 요즘에 RxJava2 보고, Python3에서 asyncio 같은거 보면서 이런거, 그러니까 결국엔 모나드스러운 체이닝을 구현하고, 그걸로 콜백들을 풀어서 잘 해결하고 있는거 같은 인상이 들어서.
결론? 내 아이디어 부심. 그리고 조금 더 잘 생각하고 실제로 어떻게 구현할지 고민해봤다면 좋았을거라는, 나 자신의 능력 한탄하기.</description>
    </item>
    
  </channel>
</rss>
