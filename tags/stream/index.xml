<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stream on 아겔로그</title>
    <link>https://ageldama.github.io/tags/stream/</link>
    <description>Recent content in Stream on 아겔로그</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© &lt;a href=&#39;https://ageldama.github.io/myself&#39;&gt;ageldama&lt;/a&gt; 👾</copyright>
    <lastBuildDate>Wed, 11 Nov 2020 00:00:00 +0900</lastBuildDate>
    <atom:link href="https://ageldama.github.io/tags/stream/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python &#43; Generator / LeetCode &#34;1614. max nesting depth of the parentheses&#34;</title>
      <link>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</guid>
      <description>지난 번 작성한 Common Lisp / LOOP매크로을 이용한 구현 을 다른 언어에서였다면, 비슷한 조건으로 메모리 복잡도 O(1)으로 풀어보고 싶었다.&#xA;from itertools import accumulate def find_paren_count(s): gen_only_parens = (ch == &amp;#39;(&amp;#39; and 1 or -1 for ch in s if ch in (&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;,)) return max(accumulate(gen_only_parens)) 다른 언어에서도 lazy stream을 지원한다면 비슷하게 풀 수 있을 것 같다.</description>
    </item>
  </channel>
</rss>
