<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Commonlisp on 아겔로그</title>
    <link>https://ageldama.github.io/tags/commonlisp/</link>
    <description>Recent content in Commonlisp on 아겔로그</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© &lt;a href=&#39;https://ageldama.github.io/myself&#39;&gt;ageldama&lt;/a&gt; 👾</copyright>
    <lastBuildDate>Sat, 04 Feb 2023 16:46:54 +0000</lastBuildDate>
    <atom:link href="https://ageldama.github.io/tags/commonlisp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ping 04/02/2023 .01: 씨언어의 장자 zig, rust, golang, c&#43;&#43; ???</title>
      <link>https://ageldama.github.io/posts/2023-02feb/2023-02feb04--01-ping/</link>
      <pubDate>Sat, 04 Feb 2023 16:46:54 +0000</pubDate>
      <guid>https://ageldama.github.io/posts/2023-02feb/2023-02feb04--01-ping/</guid>
      <description>&lt;p&gt;&#xA;최근에 재미로 &lt;a href=&#34;https://ziglang.org/&#34;&gt;zig&lt;/a&gt; 을 정말 재밌게 &amp;#39;읽었다&amp;#39;. 공부해보고 실제로 뭔가&#xA;코딩을 많이 해보거나 한 것은 아니고, 대체 어떻게 동작하는 프로그램을&#xA;이걸로 만들라고 하는건지 이해하고 싶었기 때문에 해봤다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;zig으로 프로그램을 짜는게 궁금하던 부분은 haskell의 monad을 이용한&#xA;방식, 혹은 apl이나 prolog으로 실제프로그램을 어떻게 만들 수 있을지&#xA;패러다임부터 다른 언어를 공부하고 생각해보는 것과는 조금 다를수도&#xA;있겠다. 어쨌든 그냥 imperative언어이니까.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;오히려, zig을 어떻게 써먹어야 할지 궁금하던 지점은, c++의&#xA;스마트포인터와 move semantics등을 이해하는 것이나, rust의 borrowing&#xA;checker, rc/arc등을 이해하는 것과 마찬가지인 것 같다.&#xA;둘 다 이해하고 익숙해지면 그렇게 부담스럽지 않을거 같긴 하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>&#34;asdf-subdir-finder&#34; released!</title>
      <link>https://ageldama.github.io/posts/2020-10oct/asdf-subdir-finder-1st/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/asdf-subdir-finder-1st/</guid>
      <description>&lt;p&gt;&#xA;지난번 포스팅한 &amp;#34;&lt;a href=&#34;https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/&#34;&gt;asdf 정의를 내 코드베이스의 하위디렉토리에서 자동으로&#xA;로딩하기&lt;/a&gt;&amp;#34;를 프로젝트으로 만들었다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://github.com/ageldama/asdf-subdir-finder&#34;&gt;https://github.com/ageldama/asdf-subdir-finder&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;사람마다 커먼리습으로 작업하는 스타일에 따라 많이 다를 수 있어서 안&#xA;써도 되기도 하지만, 그냥 정리해서 공개는 해봤다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>&#34;커먼리습 ASDF 불러오기 편하게 하기&#34; 대모험</title>
      <link>https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/</guid>
      <description>&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-1&#34;&gt;&#xA;ASDF와 system definition file 검색의 정석&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;이전에 &lt;a href=&#34;https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/&#34;&gt;ASDF을 이용하여 커먼리습 프로젝트의 의존성, 시스템을 로딩하기&lt;/a&gt;&#xA;  에 대해서 설명한 적이 있었다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  이전에 다룬 내용은 정석적으로 &lt;code&gt;$HOME/common-lisp&lt;/code&gt; 디렉토리에 &lt;code&gt;.asd&lt;/code&gt;&#xA;  파일을 심볼릭링크를 걸고, &lt;code&gt;(asdf:load-system ..)&lt;/code&gt; 을 시도하는&#xA;  내용이었었다.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;&#xA;&lt;h2 id=&#34;headline-2&#34;&gt;&#xA;Prototyping등 더 편안하게 혼자 코딩을 할 때는…&#xA;&lt;/h2&gt;&#xA;&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;&#xA;&lt;p&gt;혼자 커먼리습 코딩을 하면서, 나는 더 간단하게 프로젝트를 시작하는&#xA;  방법을 선호한다.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;  커먼리습이 파일 이름이나 경로에 대해서 의존하는 것이 아니고,&#xA;  컴파일시점, 로딩시점에 순서에 따라 로딩해서 최종적으로 컴파일하여&#xA;  적재한 결과 이미지를 더 중요하게 여기기 때문에, 그리고 그런 컴파일,&#xA;  빌드, 로딩과 같은 모든 단계들 자체도 커먼리습 표현식 그자체로&#xA;  동작하기 때문에 그냥 하나의 소스파일을 섹션별로 나눠서 작업하면&#xA;  편리하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>First release of cl-state-machine</title>
      <link>https://ageldama.github.io/posts/2019-12dec/cl-state-machine-1st-release/</link>
      <pubDate>Mon, 09 Dec 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/cl-state-machine-1st-release/</guid>
      <description>&lt;p&gt;Made a small state machine library/DSL in/for CommonLisp.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ageldama/cl-state-machine&#34;&gt;https://github.com/ageldama/cl-state-machine&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>커먼리습 설정하기, ASDF 시스템 코드를 받기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/tips-ecl-clisp/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/tips-ecl-clisp/</guid>
      <description>&lt;h1 id=&#34;1-asdf을-최신-버젼으로-설정한다&#34;&gt;1. ASDF을 최신 버젼으로 설정한다&lt;/h1&gt;&#xA;&lt;p&gt;(이부분에서 많이 고생했는데) SBCL와 다르게&#xA;&lt;a href=&#34;https://clisp.sourceforge.io/&#34;&gt;CLISP&lt;/a&gt;,&#xA;&lt;a href=&#34;https://common-lisp.net/project/ecl/&#34;&gt;ECL&lt;/a&gt; 은 최신 버젼의 ASDF을&#xA;내장한걸 패키징해놓지 않았다.&lt;/p&gt;&#xA;&lt;p&gt;대부분은 문제가 없이 동작하지만, 내가 작성한 커먼리습 시스템에서&#xA;실행파일을 빌드할 때 문제가 많았다.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ASDF 의 최신 버젼을 &lt;code&gt;git clone&lt;/code&gt; 해서 적당한 디렉토리에 받는다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://common-lisp.net/project/asdf/&#34;&gt;https://common-lisp.net/project/asdf/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;make&lt;/code&gt;을 내려받은 ASDF 디렉토리에서 실행한다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;실행하면 &lt;code&gt;build/asdf.lisp&lt;/code&gt; 파일으로 한 파일으로 뭉쳐서 로딩하게&#xA;편안한 파일을 생성해준다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;내 커먼리습 구현체의 시작설정파일 맨 앞에 다음처럼 추가한다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;(load &amp;quot;~/local/asdf/build/asdf&amp;quot;)&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;여기서 나는 &lt;code&gt;$HOME/local/asdf/&lt;/code&gt; 에 ASDF을 받았다고 가정.&lt;/li&gt;&#xA;&lt;li&gt;그리고 &lt;code&gt;asdf.lisp&lt;/code&gt; 파일이더라도, 마지막에 &lt;code&gt;.lisp&lt;/code&gt; 확장자는 생략했다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECL은 &lt;code&gt;$HOME/.eclrc&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;CLISP은 &lt;code&gt;$HOME/.clisprc.lisp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;그리고 중요한데, 그 다음에&#xA;&lt;a href=&#34;https://www.quicklisp.org/&#34;&gt;Quicklisp&lt;/a&gt; 초기화 내용이 오도록&#xA;한다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Quicklisp을 초기화하기 전에 ASDF 최신 버젼이 로딩되어 있는게 더&#xA;나을테니까.&lt;/li&gt;&#xA;&lt;li&gt;어차피 위의 (1~3)의 순서대로 ASDF 먼저 설정한 다음에&#xA;Quicklisp설치한 다음에 &lt;code&gt;ql:add-to-init-file&lt;/code&gt; 실행하면 이런&#xA;순서로 추가해준다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&amp;hellip;별거 아닌데, 이거 때문에 빌드한 결과 실행파일이 이상해서 좀 고생했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>(Common Lisp의 어두운 면) Equality</title>
      <link>https://ageldama.github.io/posts/2019-11nov/the-dark-side-of-cl-equality/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-11nov/the-dark-side-of-cl-equality/</guid>
      <description>&lt;p&gt;오늘은 커먼리습의 어두운 면을 이야기 해볼까. 보통 나는 리습 팬보이니까&#xA;리습에 대해 불리한 이야기는 잘 쓰지 않는거 같아서 한번 써보기로&#xA;생각했다. 그리고 놀랍게도 이 글의 끝에 가서는 다시 이런 리습의 결점을&#xA;리습의 위대함으로 승화시키는 단계까지 끌어가 보도록 하려고함.&lt;/p&gt;&#xA;&lt;p&gt;뭐 커먼리습의 &lt;a href=&#34;http://clhs.lisp.se/Front/index.htm&#34;&gt;CLHS - HyperSpec&lt;/a&gt;을 읽다보면 비슷한데 아주 약간씩&#xA;미묘하게 달라서 지원하는 것들이 있다:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;let&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm&#34;&gt;Special Operator LET, LET*&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm&#34;&gt;Special Operator FLET, LABELS, MACROLET&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/f_map.htm&#34;&gt;Function MAP&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm&#34;&gt;Function MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/f_map_in.htm#map-into&#34;&gt;Function MAP-INTO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;prog&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/m_prog1c.htm&#34;&gt;Macro PROG1, PROG2&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/s_progn.htm#progn&#34;&gt;Special Operator PROGN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/m_prog_.htm#progST&#34;&gt;Macro PROG, PROG*&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/s_progv.htm#progv&#34;&gt;Special Operator PROGV&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;그밖에도 좀 더 있을듯?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;이렇게 나열해 놓으면 꽤 무서워 보이지만, 막상 차이를 이해하면 별로&#xA;복잡하지도 않아서 나중엔 더 편안해진다. (정말로)&lt;/p&gt;</description>
    </item>
    <item>
      <title>cl-toy-stack-lang 첫번째 버젼과 작업하면서 깨달은것</title>
      <link>https://ageldama.github.io/posts/2019-10oct/cl-toy-stack-lang/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-10oct/cl-toy-stack-lang/</guid>
      <description>&lt;p&gt;일단 첫번째 버젼 다 만들었다.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ageldama/cl-toy-stack-lang/releases/tag/v0.1.0&#34;&gt;https://github.com/ageldama/cl-toy-stack-lang/releases/tag/v0.1.0&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;그냥 장난으로 인터프리터도 아니라 그냥&#xA;&lt;a href=&#34;http://clhs.lisp.se/Body/f_eval.htm&#34;&gt;eval&lt;/a&gt; 이용한 간단한 파서도&#xA;필요없이 lexer만으로 만들만한&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Forth_(programming_language)&#34;&gt;Forth&lt;/a&gt;&#xA;비슷한 언어를 만듬.&lt;/p&gt;&#xA;&lt;p&gt;명령어도 실용적인 목적이 아닌만큼 그냥 문자열 장난 밖엔 없다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;느낀점&#34;&gt;느낀점&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;라이브러리 좋은거 갖다 잘쓰자&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://quickdocs.org/uiop/&#34;&gt;uiop&lt;/a&gt; 같은거,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://clhs.lisp.se/Body/24_aba.htm&#34;&gt;feature-expression&lt;/a&gt; 삽질을 적게하거나 안해도됨. 더&#xA;portable하고 잘 굴러가는.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Test!&lt;/strong&gt;&#xA;3. 짜고 하나씩 진화시켜가면서 다시 돌리는 재미.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Idiomatic하게&lt;/strong&gt; 그리고 역시 Test!&#xA;&lt;ol&gt;&#xA;&lt;li&gt;..처음엔 그냥 전역변수에 상태를 갖도록 만들고,&lt;/li&gt;&#xA;&lt;li&gt;그걸 &lt;a href=&#34;http://www.lispworks.com/documentation/HyperSpec/Body/03_abaab.htm&#34;&gt;dynamic binding&lt;/a&gt;으로 바꿔서 파라미터화하고,&lt;/li&gt;&#xA;&lt;li&gt;또 그걸 다시 상태를 캡슐화하는 클래스로 감싸고,&lt;/li&gt;&#xA;&lt;li&gt;처음엔 단순하게 리습스럽게 짜고 그걸 진화시키고,&lt;/li&gt;&#xA;&lt;li&gt;그리고 역시 다시 테스트.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;em&gt;아는만큼 보인다&lt;/em&gt;&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;setf&lt;/code&gt; 병렬로 하기, +destructuring&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;asdf:operate&lt;/code&gt; + &lt;code&gt;:build-op&lt;/code&gt; :&#xA;&lt;a href=&#34;http://www.sbcl.org/&#34;&gt;SBCL&lt;/a&gt;/&lt;a href=&#34;https://common-lisp.net/project/ecl/&#34;&gt;ECL&lt;/a&gt;&#xA;등 리습컴파일러에 관계 없이 실행이미지 빌드 편안하게&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/xach/buildapp&#34;&gt;https://github.com/xach/buildapp&lt;/a&gt; 같은거 써볼까 하다가,&#xA;처음엔 그냥 간단히 쉘스크립팅으로 시작.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;기타 등등&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&amp;hellip;그리고 무엇보다 재밌었다. 그리고 뭐가됐든 그냥 짜보고 굴러가는&#xA;형태로 계속해서 작은 프로그램을 많이 만들고 하면서 놀아야겠다고&#xA;생각했다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CFFI으로 CommonLisp 2d array을 Foreign function으로 전달하기</title>
      <link>https://ageldama.github.io/posts/2019-03mar/cffi-2d-array/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-03mar/cffi-2d-array/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/ageldama/cffi-2d-array-hello&#34;&gt;https://github.com/ageldama/cffi-2d-array-hello&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;cffi:with-foreign-array&lt;/code&gt;이 &lt;a href=&#34;https://common-lisp.net/project/cffi/manual/cffi-manual.html&#34;&gt;CFFI&#xA;manual&lt;/a&gt;에&#xA;없어서 처음에 좀 골치아팠음.&lt;/p&gt;&#xA;&lt;p&gt;리습 어레이를 복사해서 매핑해줌.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ASDF으로 간단한 의존성 연결과 로딩하기</title>
      <link>https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/</link>
      <pubDate>Sat, 03 Nov 2018 19:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/</guid>
      <description>&lt;h1 id=&#34;system-이런게-왜-필요하지-require있잖아&#34;&gt;System? 이런게 왜 필요하지? &lt;code&gt;require&lt;/code&gt;있잖아&lt;/h1&gt;&#xA;&lt;p&gt;대부분의 유명한 프로그래밍언어들이 &lt;em&gt;커먼리습의 System&lt;/em&gt; 에 대응하는&#xA;기능이 명확하게 없으니까, 다른 프로그래밍 하거나 하는 방법으로&#xA;이야기를 하지는 않아야겠다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/systems.html&#34;&gt;https://lispcookbook.github.io/cl-cookbook/systems.html&lt;/a&gt; 에서 마음에 드는 설명을 찾을수 있다.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A &lt;strong&gt;system&lt;/strong&gt; is a collection of Lisp files that together constitute an&#xA;application or a library, and that should therefore be managed as a&#xA;whole. A &lt;strong&gt;system definition&lt;/strong&gt; describes which source files make up the&#xA;system, what the dependencies among them are, and the order they&#xA;should be compiled and loaded in.&lt;/p&gt;</description>
    </item>
    <item>
      <title>SBCL을 OSX에서 실행할때 멀티쓰레딩 켜기.</title>
      <link>https://ageldama.github.io/posts/2017/2017-02-25-sbcl-osx-multithread/</link>
      <pubDate>Sat, 25 Feb 2017 16:40:00 +0100</pubDate>
      <guid>https://ageldama.github.io/posts/2017/2017-02-25-sbcl-osx-multithread/</guid>
      <description>&lt;p&gt;SBCL은 멀티쓰레딩을 잘 지원하는 커먼리습 컴파일러이지만,&#xA;공식사이트에서 제공하는 리눅스 바이너리가 아니라 OSX 바이너리는&#xA;멀티쓰레딩이 꺼져서 컴파일되어있다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.sbcl.org/manual/#Threading&#34;&gt;http://www.sbcl.org/manual/#Threading&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;요건 자기 리습에서 &lt;code&gt;*features*&lt;/code&gt; 을 평가해서, 리스트에 &lt;code&gt;:threading&lt;/code&gt;,&#xA;&lt;code&gt;:sb-thread&lt;/code&gt; 같은 키워드를 포함하는지 확인해보면 알 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;어쨌든 지원하지 않을 경우에, 컴파일을 다시 해야하는데, 우선&#xA;준비물은 &lt;a href=&#34;http://clisp.org/&#34;&gt;GNU CLISP&lt;/a&gt; 같은 여기저기서 잘굴러가고&#xA;적당히 설치해서 부트스크래핑에 이용 가능한 커먼리습 컴파일러를 준비한다.&lt;/p&gt;&#xA;&lt;p&gt;다음 포스트를 참고해서 작업해봤다.:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://haminhvuong-blog.tumblr.com/post/22109095116/compile-sbcl-with-multi-thread-enabled-on-os-x&#34;&gt;http://haminhvuong-blog.tumblr.com/post/22109095116/compile-sbcl-with-multi-thread-enabled-on-os-x&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;create &lt;code&gt;customize-target-features.lisp&lt;/code&gt; with content&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt;1&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt;2&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt;3&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt;4&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt;5&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt;6&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt;7&lt;/a&gt;&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt;8&lt;/a&gt;&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;features&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;flet&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;enable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pushnew&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;features&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;disable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;setf&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;features&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;features&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;;; Threading support, available only on x86/x86-64 Linux, x86Solaris&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;;; and x86 Mac OS X (experimental).&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;enable&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;:sb-thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;그리고 다음의 커맨드들로 빌드하고 설치 끝.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
