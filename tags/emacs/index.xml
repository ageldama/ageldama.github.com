<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>emacs on 아겔로그</title>
    <link>https://ageldama.github.io/tags/emacs/</link>
    <description>Recent content in emacs on 아겔로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <copyright>All rights reserved to ageldama</copyright>
    <lastBuildDate>Wed, 15 Mar 2023 15:37:14 +0000</lastBuildDate><atom:link href="https://ageldama.github.io/tags/emacs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>내 책상에서 유선랜 환경</title>
      <link>https://ageldama.github.io/posts/2023-03mar/2023-03mar15--wired-desktop/</link>
      <pubDate>Wed, 15 Mar 2023 15:37:14 +0000</pubDate>
      
      <guid>https://ageldama.github.io/posts/2023-03mar/2023-03mar15--wired-desktop/</guid>
      <description>개인환경을 조금 특이하게 사용하는데, 그 이유와 방식.
why: 유선랜? (무선랜 대신) 키보드/마우스 입력이 가장 부드럽게 전달되어서 유선으로 연결해서 사용한다.
x2x으로 연결하거나, ssh-x11-forwarding으로 다른 컴퓨터에서 실행하는 프로그램을 디스플레이와 입력장치만 현재 자리에서 그대로 사용할 때에 네트웍 연결속도가 딜레이가 적어야 쾌적해서. 1
why: x11? (wayland 대신) 요즘 리눅스/bsd 데스크탑 기본설치하면 wayland으로 세팅하는 경우도 많은데, 네트웍을 통해서 ssh-x11-forwarding 1 사용하거나 x2x 사용하기는 아직 부족한거 같아서, 나는 그냥 x11 사용함.
거기에 xdotool 같은 gui-automation/scripting이나 warpd 같은 키보드를 마우스으로 편안하게 쓰도록 해주는 xtest이나, qjoypad 처럼 2 게임패드/조이스틱을 편안하게 마우스/키보드으로 매핑해서 쓰는게 나는 많은데 모두 x11만 지원하거나, 아직은 x11에서만 쓸만한 수준으로 동작해서.</description>
    </item>
    
    <item>
      <title>&#34;org-more.el&#34; released!</title>
      <link>https://ageldama.github.io/posts/2020-11nov/org-more-1st-rel/</link>
      <pubDate>Wed, 04 Nov 2020 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-11nov/org-more-1st-rel/</guid>
      <description>org-more.el: search .org files have certain tags (#+tags[]: or #+tags[]:)
개인 위키, KB처럼 org 파일 모음을 사용하고 있는데, 디렉토리 계층과 직접 링크 관계만이 아니라 같은 태그들으로 묶어서 각 파일들을 검색하고 리스팅 할 수 있도록 만들었다.</description>
    </item>
    
    <item>
      <title>Ping 13/Aug/2020</title>
      <link>https://ageldama.github.io/posts/2020-08aug/ping-13thu/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-08aug/ping-13thu/</guid>
      <description>프비 워크스테이션을 만들어놓고 그렇게 좋은 사양은 절대 아닌 조용한 슬림PC에서, 또 가능한 마우스를 안 써도 좋게 세팅해놓고 편안하게 이맥스에서 작업을 해나간다.
FM라디오의 가끔 지글거리는 잡음도 좋은 것 같다.
계속해서 신경을 쓰게 만들고 끊기고 광고가 나오고 또 클릭을 유도하고 멍청하게 징징거리는 것으로 돈으로 바꾸는 요즘의 수많은 다른 매체들보다 훨씬 나를 편안하게 만든다.
다른 매체들도 비슷하지 않을까. SNS도 그런 것 같고 대부분의 앱, 심지어 운영체제도 그런 환경들과는 다른.</description>
    </item>
    
    <item>
      <title>Ping 01/Aug/2020</title>
      <link>https://ageldama.github.io/posts/2020-08aug/ping-01sat/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-08aug/ping-01sat/</guid>
      <description>오랬만에 내 환경을 더 다듬었다.
Emacs, Evil, General.el. 매일 이맥스에서 코딩을 하면서 조금은 Vim보다 키바인딩이 편집에 불리한 것 같았었다. 그렇다고 Vim을 쓰고 싶지는 않았다. 검색이나 다중편집 같은 이맥스만의 기능을 Vim에서 흉내내는 것은 별로 마음에 차지 않는 정도이고 또 화면 flickering도 이맥스 GUI을 쓸 때보다 터미널 Vim은 심해서 난 피곤해.
그래서 Evil-mode을 종종 썼는데 문제는 내가 만들어놓은 general.el 키바인딩들이 Evil을 고려하지 않고 만들어서 evil모드를 toggle하며 써야했었었다. 특히 내 이맥스 모드에서의 키바인딩의 prefix이 C-z인데, evil-mode에서는 emacs mode으로 전환을 위해서 사용.</description>
    </item>
    
    <item>
      <title>Emacs 시작 시간 빠르게 만들기</title>
      <link>https://ageldama.github.io/posts/2020-01jan/esup-emacs-init-speed/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:01 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2020-01jan/esup-emacs-init-speed/</guid>
      <description>이맥스 설정이 조금씩 자라날 때마다 이맥스를 새로 시작하는 시간도 길어져서 짜증이 슬슬나기 시작했다. 그래서 조금 개선해봤다.
Quelpa + MELPA 거절하기 Quelpa 을 이용해서, MELPA등에 등록된 패키지가 아닌 내가 작성해서 GitHub에 올려놓고 사용하는 패키지를 Git으로 받아서 등록해 사용한다.1
그런데, 어차피 use-pacakge을 이용해서 MELPA 등 패키지를 받아와서 사용하는데, 불필요하게 MELPA 인덱스를 시작할 때마다 받아오고 한다는걸 알게 됐다.
당연히 껐다. 한참 빨라졌다.
참고: Inhibit MELPA git checkout or updates on init
esup profiler Elisp 자체는 프로파일링이 가능한데2, $HOME/.</description>
    </item>
    
    <item>
      <title>direnv &#43; direnv-mode 이맥스 지원 &#43; C/C&#43;&#43;/Python등 프로젝트 설정 적용하기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/direnv/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-12dec/direnv/</guid>
      <description>프로젝트의 빌드 디렉토리, virtualenv와 같은 경로의 설정, 경로 설정에 따른 빌드/실행/테스팅/스크립트을 편하게 하려고 만든 moonshot.el 와 유사한걸 검색해봤다.
몇 가지 이런 비슷한게 몇 가지 있는데, 내 상황에 쓸만한 것은 direnv
NPM: dotenv https://www.npmjs.com/package/dotenv
Node.js에서 Unix environment variable으로 .env 파일을 로딩해주는 역할인 듯.
Shell에서 Hook 걸어서 사용하기엔 별로 인거 같았다.
그리고 Node.js 이외의 프로젝트에 적용하려면 매번 JS으로 wrapper을 짜주고 하기 싫었고,
.env 파일이 그냥 정적인 key-value 문자열의 나열이라, 파일시스템에서 경로를 조립하고 하는데 별로라는 생각이 들었다.</description>
    </item>
    
    <item>
      <title>moonshot.el 최초 릴리즈</title>
      <link>https://ageldama.github.io/posts/2019-12dec/moonshot-1st-rel/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-12dec/moonshot-1st-rel/</guid>
      <description>moonshot.el 을 만들어서 공개했다.
이맥스를 써오면서 불편하다고 생각한걸 간단히 하고 싶었었다:
불편함들 빌드 디렉토리 Projectile을 사용하니까 프로젝트 디렉토리는 관리가 쉬운데, 빌드 디렉토리는 관리가 어려웠다.
아예 Projectile이 추론하는 디렉토리 바깥에 빌드 디렉토리는 위치하는 경우도 있으니까.
예) GNU Autotools configure 이나 CMake으로 작업할 때, 소스트리 바깥에 빌드 디렉토리를 걸어놓아서 정리를 깔끔하게 할 수 있으니까. 그런데 이 &amp;#39;빌드 디렉토리&amp;#39;가 중요한게,
말그대로 컴파일한 .o 파일이나 최종 결과 실행파일 등이 여기에 쌓이니까 디버깅, 테스트를 위해서 실행파일을 실행하거나, 심지어 make 이나 ninja 같은 빌드 커맨드를 실행하기 위해서도 빌드 디렉토리를 지정하거나 이동해서 실행해야 하니까 귀찮다.</description>
    </item>
    
    <item>
      <title>Org모드에서 스프레드시트 기능과 Babel 섞어쓰기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/org-spreadsheet-and-babel/</link>
      <pubDate>Fri, 13 Dec 2019 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-12dec/org-spreadsheet-and-babel/</guid>
      <description>쩌는 Org-mode Spreadsheet 소개 를 읽고 감명 받아서 따라해봅니다.
다른 부분은 만족스러웠는데, 조금 복잡한 elisp식을 쓰기 귀찮으니, 미리 defun / defmacro 으로 정의해놓고 그걸 spreadsheet에서 불러 쓸 수 있을지가 궁금했습니다.
그래서 다음과 같이 해보면 가능할지를 실험:
Org-Babel으로 원하는 함수를 정의한다.
그리고 Org 파일이 로딩될 때 평가하도록 속성을 지정해놓는다. Spreadsheet에서 불러서 쓸 수 있는지 확인해본다. 우선 C-h a 을 눌러 vsum 을 검색해보니, defun calcFunc-vsum (&amp;amp;rest vecs) 으로 미리 선언되어 있는거 같았습니다.</description>
    </item>
    
    <item>
      <title>Org 파일으로 Hugo 포스팅 테스트</title>
      <link>https://ageldama.github.io/posts/2019-12dec/foo/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-12dec/foo/</guid>
      <description>적당히 잘 동작하는거 같으니 앞으로는 그냥 혼란스러운 Markdown 대신에 그냥 Org 파일으로 블로깅 하며 될거 같다. 행벜.
예전 버젼 Hugo에서는 지원을 제대로 못하던거 같은데, 어느샌가 업데이트 하니까 되는거 같아서 그냥 슬그머니 쓰기로. https://gohugo.io/content-management/formats/
기존 마크다운들도 인라인 이미지 문법을 바꾸고, ToC 표시 설정도 바뀌어서 조금 변경.
아쉬운건 여전히 Org 파일에서 ToC 지원은 빠져 있는거 같아서… https://github.com/snosov1/toc-org 설치해봤다. 그냥 고민할 필요가 없었구나. ㅋ
제일 좋은건 code syntax highlight이 예뻐졌다.
Table of Contents &amp;lt;– :TOC: –&amp;gt; foobar</description>
    </item>
    
    <item>
      <title>Ivy/Counsel으로 바꾸기, 기능들 만들기 (w/ C&#43;&#43;지원, &#43;&#43;rmsbolt)</title>
      <link>https://ageldama.github.io/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</link>
      <pubDate>Tue, 26 Feb 2019 01:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</guid>
      <description>최근에 이맥스 설정을 Helm기반에서 Ivy/Counsel으로 전부 바꿨다.
더 가볍고, 적당히 잘 동작하고, Ripgrep이랑 기본적으로 설정이 가능해서 편함.
거기에 C-c C-o (ivy-occur) + wgrep이 Helm에선 동작할때가 그때그때 기능에 따라 달라서 짜증나고, 심지어 플러그인을 설정해서 써야하거나 해서 정말 좋아하는 기능인데 우울하게 만들었는데, Ivy이 훨씬 깔끔하게 동작하고 일관성있게 잘 동작함.
처음에는 Helm에서 하는 기능들을 그대로 옮기려고만 생각하다가, 오히려 Ivy에 맞춰서 내가 익숙해지고, 더 낫게 할 방법들이 있어서 그냥 내가 adopt해서 편안해졌다.
CMake + compile_commands.</description>
    </item>
    
    <item>
      <title>CQuery &#43; LSP vs CMake-IDE &#43; RTags</title>
      <link>https://ageldama.github.io/posts/2018-09sep/cquery-vs-cmake-ide/</link>
      <pubDate>Sun, 23 Sep 2018 12:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2018-09sep/cquery-vs-cmake-ide/</guid>
      <description>LSP + CQuery을 써보려고 했는데, 결국 CMake-IDE + RTags 조합으로 원래대로 쓰게될거 같아. :
_build/ 와 같이 CMake, Ninja, Makefile등의 파일들을 별도의 디렉토리로 만들어서 필드하고 싶은데, 제대로 지원을 못한다. 1. 그냥 프로젝트 소스코드랑 같이 generate하고 gcc등의 중간 파일이 모두 같이 남아서 지저분해져서 싫어함. 아직은 별로 내 마음에 꼭 들게 만들기는 어려울거 같아서. 그래도 인상적이었던 부분들:
flycheck에 전용으로 연동되어 있는 점. company-lsp이 생각보다 훨씬 부드럽고 자동완성 잘되는거. 미래에는 그냥 LSP기반만 남을거 같아서, 이것도 &amp;ldquo;helm-rg의 모험&amp;quot;처럼 아직은 완전히 전환은 못할거 같긴하다.</description>
    </item>
    
    <item>
      <title>NeoVim, Evil-mode and Emacs의 모험</title>
      <link>https://ageldama.github.io/posts/2018-07jul/2018-07jul-nvim-evil-and-emacs/</link>
      <pubDate>Sat, 28 Jul 2018 12:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2018-07jul/2018-07jul-nvim-evil-and-emacs/</guid>
      <description>&amp;ldquo;내적모순&amp;rdquo; 이맥스에서 Evil을 쓰면서 몇가지 짜증나는게 있어왔다.
Evil 자체의 문서화가 조금 거시기하다. 거기에 Which-Key같은 키바인딩을 실시간으로 확인할 수 있는 방법도 제대로 안먹히게 된거라, 이맥스에서 쩔어주는 기능인 자기 자신을 확인하며 단축키 안외우기 같은게 다 무의미해짐. 공식 사이트 들어가도 문서는 없다. 그냥 Vim 온라인 help을 보거나 하라는 친절인거 같다. Magit, Edb, 등등 대부분의 이맥스의 다른 Major mode들이랑은 정말 충돌하는 경우가 너무 많음. https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018#L421 위의 링크만 봐도, 내가 얼마나 충돌이 나는 모드들을 경험했는지 알수있다.</description>
    </item>
    
    <item>
      <title>Emacs &#43; CMake-IDE Screencast</title>
      <link>https://ageldama.github.io/posts/2018-05may/2018-05may-emacs-cmake-ide-screencast/</link>
      <pubDate>Tue, 08 May 2018 00:00:00 +0900</pubDate>
      
      <guid>https://ageldama.github.io/posts/2018-05may/2018-05may-emacs-cmake-ide-screencast/</guid>
      <description>이건 무엇인가 Emacs Configurations: https://github.com/ageldama/configs/tree/master/emacs/cmake-ide
이맥스에서 C++ 개발 편하게 하려고 이것저것 알아보다가 결국엔 CMake-IDE + RTags 조합이 제일 괜찮다는 결론에 도달해서 만들어본 설정이다.
원래 사용하는 환경이 Evil은 아니었는데, Spacemacs 을 조금 쓰다가 편한거 같아서 Evil으로 옮겨탔다.
지금은 그냥 Spacemacs은 다운도 잘되고 너무 무겁고 설정을 레이어 방식 으로 할게 아니면 짜증나게 하는 부분도 많고, 그렇다고 레이어가 완전히 내가 그냥 커스텀으로 만들어서 바로바로 머지하는 구조도 아니고 중앙에서 관리하는 방식으로만 되는거 같아서, 옆으로 치우고, 바닐라 이맥스에 Spacemacs스럽게 직접 설정해서 가볍게 사용하고 있다.</description>
    </item>
    
    <item>
      <title>Emacs에서 window 전환을 편하게, ace-window</title>
      <link>https://ageldama.github.io/posts/2017/2017-01-22-emacs-ace-window/</link>
      <pubDate>Sun, 22 Jan 2017 14:15:00 +0100</pubDate>
      
      <guid>https://ageldama.github.io/posts/2017/2017-01-22-emacs-ace-window/</guid>
      <description>이맥스에서 코딩하거나 마크다운이나 Org으로 글을 쓰고 정리하는데, 그간 그냥 그럭저럭 나는 이맥스를 나한테 맞춰서 사용하고 있다고 생각하고 있었던거 같다. 1
그런데, 항상 뭔가 불편한데, 그냥 바쁘다는 이유로 깊이 생각은 안하고 대충 대충 때우면서 사용해왔었던게 있었다. 바로 window 끼리 전환하는 방법.
C-x 2 이나 C-x 3으로 창을 분할해놓고 쓰는게 보통인데, 이때 나는 그냥 아무 생각없이 C-x o만을 이용해서 다음 윈도우 으로 이동만해왔었다.
그런데, 창이 3개 이상이 되고, 현재 창의 다음 창 이 아니라, 이전 창 으로 이동하고 싶으면?</description>
    </item>
    
    <item>
      <title>Emacs이랑 친해지기</title>
      <link>https://ageldama.github.io/posts/2017/2017-01-01-getting-started-with-emacs/</link>
      <pubDate>Sun, 01 Jan 2017 10:00:00 +0100</pubDate>
      
      <guid>https://ageldama.github.io/posts/2017/2017-01-01-getting-started-with-emacs/</guid>
      <description>&amp;ldquo;이맥스를 어떻게 배우면 좋은지 모르겠다. 여러번 도전해봤지만 항상 별로였다.&amp;rdquo;
..어느날 한 동료가 물어봤다. (그렇다 나는 일터에서도 이맥스를 켜놓고 계속 쓴다.)
솔직히 기본적으로 매일 Org-mode으로 계획, 일정 등등 정리하고 계속 개인적으로 정리하면서 쓰고, 파이썬, Go, Clojure 같은거 할때도 편집하고 테스트하기도 편하니까 선호하는 편인거 같다. (자바랑 스칼라은 물론 그냥 IntelliJ 쓴다.)
여튼 그날 간단히 짝프로그래밍하듯이 같이 앉아서 몇가지 이야기를 하고, 내 설정 파일 1 이나 어떻게 접근하는게 좋은지에 대해서 잠깐 이야기를 했었다.</description>
    </item>
    
  </channel>
</rss>
