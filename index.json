
[
 {
     "permalink": "https://ageldama.github.io/posts/","title": "▫️ Posts",
     
     "tags": [],
     
 "description": "",
 "contents": ""},
 {
     "permalink": "https://ageldama.github.io/posts/2026-02feb/2026-02feb18--01-ping/","title": "🚢 생성형AI, 진짜로 문제인 AI Hallucination은",
     
     "tags": ["ping", "programming", "architecture", "llm", "gpt", "ai", "coding", "code", "software", "programmer", "hallucination", "techical-debt", "saas", "it", "hiring", "people", "interviewing"],
     
 "description": "",
 "contents": " 요즘 나와 우리는 요즘엔 SW/IT업계에 일자리가 많이 없어지는 것, 구독형, SaaS 기업의 주가가 떨어지고 투자가 사라지는 것에 대한 우려가 많다. 그리고 나도 영향을 받는 사람으로서 걱정이 없진 못하다.\n“구독형 소프트웨어 서비스”와 데이터=석유🛢️? 그런데 사실 절대다수의 구독형서비스(…실은 그냥 모바일앱이나 데스크탑 앱이 좀 있는 웹서비스)/SaaS이 그렇게 존재할 사업이었던게 모순이 맞았던거 같다. 오히려 자동화 된 데이터모델과 그의 CRUD + 약간의 로직이 들어간 것을 각자가 해결해도 될 일이었던게 맞다. 도메인에 특화되어 있다고 하는 기업이든 특정 기술을 쓴다고 하는 기업이든… 그 도메인의 전문가라고 해야 할까 싶기도 하거니와, 말그대로 특정 기술을 “갖다 쓰는 것” 사용자인 곳일 뿐이기도 하고. …결국 적당한 뻥튀기를 다들 하니까 그게 이상한지 모르고 다같이 하며 장사를, 혹은 투자금을 쓰는 일을 했던거지 싶다.\n누적된 데이터니 뭐니하지만, 지금에 와서 생각해보면, 사실 그걸 가공하거나 어떤 의미 있는 무언가를 도출해낼 능력이 부재하거나, 그럴만한 데이터가 아닌 경우도 많은거 같다. 오히려 그걸 보지 않거나 누적한 것에 상대적으로 아주 소량의 적당한 샘플링된 데이터만 있어도 더 나은 결과를 찾아내거나 하는데 도움이 될 것도 많아서… 한때의 ‘데이터=석유’–썰 같은것도 듣기에 거시기하다. 실은 석유🛢️라기 보다는 …쌓인 쓰레기🚽에 가까워지는 경우가 더 많을 것 같다.\n기술과 기술구조의 관점에서의 신기루🌴🐪 그런데 어떤 부분에선, 어쩐지 뭔가 그렇게 변한거 같지 않다는 느낌도 받는다.\n이전에는 최초구축 시점에 전문가를 필요로 했다면, 이제는 AI을 이용해 구축한 …사실상 기술부채 덩어리를 어떻게 해소할지의 문제를 겪는 것이 더 많아진것 같다.\n구조적으로 보안적일 수 없고, 아주 단순한 보안의 관점만을 갖고도 쉽게 문제가 생길 수 있는 구조를 생성해 놓고, 그걸 아예 이해하지 못하거나 하는 경우를 많이 접한다.\n실은 그 이전에도 소프트웨어에 대한 몰이해가 크거나, 아니면 이해하고 싶어하지 않고 그냥 극단적으로 단순화하여 매도하고 싶은 이들이 쉽게 갖는 관점과 전혀 다르지 않다. 차이점은 그 관점으로 이젠 뭔가 굴러가는걸 만들어 내기는 가능한데, 여전히 그게 어떤 구조여야 서비스가 가능하고 어떤게 문제가 있는지 이해하지 못한다는 점인거 같다. 그리고 내 생각엔 과거에도 “아니 그냥 카톡처럼 깔면 되고 해야 하는거 아니요!”하는 당찬 포부를 밝히는 이들, 어떤 업무들을 거쳐서 어떻게 되어야 한다는걸 이해하지도, 이해하고 싶어하지도 않는 이들은 앞으로도 변하지 않을거 같다. ㅎㅎ1\n그리고, 의외로, 기술적인 관점의 문제는 단순히 이러한 기술적 선택에 보다 회사와 팀의 조직의 건강함과 성장가능성, 지속가능성 등에 훨씬 지대한 영향을 미친다.\n회사와 팀의 관점에서 신기루🌴🐫 어떤 종류의 (정말 너무 흔한 부류이지만) 사람들은, 처음 팀과 회사가 생겨날 때에 합류했거나 한 경우가 많다. 물론 과도기나 성장이후에도 그런 사람들은 얼마든지 팀에 합류할 가능성이 있다. 그런데 경제적인 이유, 일자리 진입의 난이도 등등의 이유로 초기에 합류한 경우가 이런 합류의 원인이 되기가 쉽다. 오히려 적당한 출신학교 타이틀이나 인맥 등이 이런 사람들에게 도움이 된다. 실제로는 별로 연관성도 없고, 어떤 것도 증명해주지 못하는… 슬픈 우리사회의 졸업장 판매, 혹은 그 과정을 들었으니 나는 qualified되었다는 막연함의 뭉텅이이지만 말이다.\n스스로에겐 불안한 자리, Insecureness🫨 이런 이들은 전혀 이슈나 기술적 선택을 적절히 이해하지 못했지만, 그것보다는 적당한 기술적인 키워드를 갖고2 거기에 스스로의 자리를 지키기 위해, 결정권자나 대중을 적당히 그런것처럼 구슬려야 하고, 밖으로는 자신이 있는 성장한 곳에 유입되려는, 혹은 그런 필요로 접촉하는 진짜 안목자나 전문가를 배척하도록 애써야 하는게 절대다수의 기업에서 빚는 매일매일의 촌극의 풍경이다.\n–그런 사람들은 외부의 전문가가 혹여 실력을 증명해 보이더라도 인성이나 성격 등등의 것들을 프레이밍하여서라도 끓어 내리기에 바쁘다. 자기자리에 대해 스스로가 insecurity을 강하게 느끼고 위협이 될거라 느끼기 때문이고, 또 스스로가 그렇게 성장해본적이 없으니 진짜가 되려면 그런 프레이밍하는 내용과는 다르게 살아와야 했으리란걸 짐작도 할 수 없기 때문이다.\n한마디로 쉽게 말해서, 사람들은 흔히 ‘실력있는 성격파탄자’를 미디어를 통해서 학습해오지만, 실제로는 그렇기 어렵다. 어차피 자기 실력을 키워가는 사람이라면 정치질이나 수작질에는 관심이 적어질 수 밖엔 없다. 자기가 실력 그대로 인정 받고 보상 받길 원하게 되니까. 오히려 그런 프레이밍을 하는 사람들… 그 스스로가 증명하는 부적격자나 능력이 떨어지는 사람들이 오히려 항상 조직내에서 성격, 인성의 문제, 흔히 말하는 정치질에 빠질 수 밖에 없다. 우선 당장부터 정치질을 의식적이건 무의식적으로 해서 자기자리를 방어하려 드는 정도인데 뭐가 더 필요한가. ㅎㅎ\n‘착한’ 직원들🙈🙉🙊 프레이밍으로, 그런 방식으로만 자기자리를 방어하는 사람들은 자기말을 잘 듣고, 고분고분할, 혹은 물지 않는 착한 사람을 뽑을 것이다. 그 사람이 그냥 적당한 거짓말을 잘하는 사람이면 더 뽑힐 가능성이 올라갈 것이다. 그리고 그런 정직하지 못함은 실은 그 사람이 정말로는 자기직무에 대한 능력은 별로일거란 생각은 시도도 않은채.\n그리고 그런 착한 직원들로 채워나간 회사는, 또 그런 “착한 직원”들을 뽑아 나가는 인재들일 수 밖엔 없다. 어차피 능력보다는 그런 ‘착함’이 우선시 되니까. 그렇게 계속해서 회사가 성장함에 따라 더더욱 무능해져만 간다.\n더욱이 나아가서 그런 상사가 나르시시스트이기까지 하다면, 이런 ‘착한’ 직원들은 금새 “날으는 원숭이”3들이 되어 함께 합심하여 피해자를 더 괴롭히게 된다.\n“저기, 저희 회산 큰 회사는 아니에요” 글쎄다… 세계최고의 기업이나 그런게 아니라는 자각이 있더라도, 그걸 어디에 어떻게 갖다 적용하는가가 중요할 것 같다. 오히려 세계최고가 아니고 당장의 성장과 생존이 절실한 작은 기업일수록 더 냉철해야 하는 부분인 것 같다. 그리고 이것도 내 작고 제한적인 경험으로서, 내가 이해한 범위에서는 거의 전체의 문제가 있었거나 문제를 겪은 기업들이 이 문제일 뿐이었었다.\n이런 문제를 제대로 이해하고 노력해온곳과 그렇지 못한 곳은 그 차이가 심해져만 간다. 제정신으로 성과를 내는 사람은 견제와 괴롭힘에 떠나고 그 자리를 다시 ‘착한’ 직원들으로 채워가는 악순환이 일어나고 거기서 빠져나오지 못한다. 그렇게 학습한 자기자리의 방어자들은 계속해서 같은 방식을 이어나가며, 채용 인터뷰는 청문회나 그 자리에 적정한 정도를 망각하는 인성검증의 재판장이 된다. (그리고 그런걸 이용하는 정보를 제공하거나 하는 비즈니스도 생겨난다) …순식간에 조직은 흔히 말하는 사해효과를 벗어날 수 없는 상태가 된다.\n그런 기업, 팀이 결국엔 어떻게 될지는 말하지 않아도 될 것이다. 외부에서 바라볼 때엔 왜 저걸 못하지? 왜 저렇게 밖엔 못해내지? 싶은 이유를 내부인들은 깊이 이해하게 될 것이다.\n우리식 ‘보편화’ 반대로 팀과 회사가 성장했으니, 다른 큰 곳들처럼 그렇게 정치나 ‘구조’가 잡혀야 한다고 말하고 착각하는 경우도 정말 흔하다.\n내가 볼때엔 그냥 그런 분이 위에 들어오시거나 해서 그렇게 생각을 주입당한것일거 같다. 그리고 그렇게 받아쓰기를 해나가야 자기들 연줄도 좀 잘 탈거 같으니 그런 소리들을 퍼뜨리는것이다.\n글쎄다. 규모에 관계 없이 그런 형태의 ‘보편화’는 그 팀/기업이 이제는 더 성장하지 못하고 하락하는 일밖엔 없다는 얘기일텐데 말이다. 그건 보편화가 아니고, 그저 병폐화일뿐인거 같다.\n초인(超人)🦸 or 양아치🦹 흔히 Machiavellianism이나 Sociopathic Management을 찬양하는 이들은 어느 부분에서 비인간적이어야 하는지를 혼동하기 쉽다. 그리고 그 선택에 따라서 그저그런, 그리고 금새 사라지거나 성장도 불확실한 좀비기업으로 남는가 아닌가가 결정되는 것 같다.🧟\n다들, 그리고 그 ‘다들’이 그렇게 오래 생존하지도 성장하지도 못하는 좀비들임을 떠올리고 생각해봐야 할 일이다. 그 ‘다들’은 거의 항상 성과를 내거나 제대로 일한 사람들에게 보상이나 승진, 혹은 일자리의 보장에 있어서 비인간적이기를 택했던 것 같다. 그들이 볼때엔 그렇게 비인간적이어야 그들의 ‘경영놀이’에 적절하다고 판단한 것 같다.\n그리고 이런 선택은 한편으로는 매우 ‘인간적’인 면이 있다. 그건 바로 결정을 내리는 이의 개인적인 애착이나 사적인 친분이나 관계에 따른 결정이라는 점이다. 참으로 양면적인 비인간적인 면과 인간적인 면이라고 할 수 있다.\n–그러한 선택은 이미 말했듯이, 그리고 이 글에서 길게 설명하듯이 좋은 결과를 이끌 수 없는 결정이다. 실은 그들의 자기애적인 성향을 충족시켜주는 면이 있으니 그렇게 선택한것이다. 그리고 다시금 재귀적으로 그들의 자기애적 성향에 의해서 그들의 선택이 맞았고, 맞아야만 한다고 맹목적일 뿐인 것이다.\n실은 정말 비인간적인 선택은, 자기자신의 자기애적인 성향을 이겨내고 공동의 이익을 위해 결정하는 것. 혹은 자기자신의 애착이나 사적인 관계를 뛰어 넘는 결단을 내리는 것으로 팀/기업을 배신하지 않는 것일 것이다.\n결국 어떤 부분, 누군가에게 인간적이고, 비인간적인가가 극명하게 갈릴것이다. 그리고 그 선택의 가름선이 흔하디 흔한 양아치인가 아니면 정말로 경영놀음이 아닌 스스로를 뛰어 넘는 누군가가 되는 것인가가 나뉜다.\n단어 ‘Competitive’ ⚔️ 내 경험으로는 ‘싸움닭’ 같은 팀원이 팀불화의 문제였던적은 별로 없다.\n오히려 이상하게도 ‘착한’ 직원들만 가득한 곳이 더 문제였다. 제대로 염증이 포착되거나 아예 곪아 터져나와서 건강해지지 못하고 계속해서 더 썩어만 들어간다. 그리고 당연히 그걸 치료해야 할 사람들이 원하는 바는 조용히 자기자리를 위해 잡음이 없는 것이므로 문제가 없는 것으로 치부된다.\n싸움보다는, 적당히 깎아내리기 혹은 반대로 자기들은 자화자찬하기를 한다. 실제로는 성과도둑질이거나 없는 성과 만들어 포장하기 정도지만. 그리고 계속해서 제대로 된 팀원은 괴롭혀 나간다.\n싸움이라기 보다는 그들 나름엔 생존을 위한 치졸한 경쟁을 하는 것이다. 그리고 그런 경쟁적인, 건강하지 못한 팀의 분위기를 Competitive하다고 말하고 싶다.4 이런 Competitive한 분위기는 ‘경쟁’하면 있어야 할 선의의 경쟁이나, 양자에게 더 좋은 결과를 도출하기 위한 것과는 거리가 멀다. –실은 공격하는 사람에게 유익할 수 있는, 그것도 아주 극단적으로 단기적인 이득을 위한 것이고, 더 나쁘게는 아주 잠깐의 쾌감을 느끼기 위해서 시도하는 경우도 많던거 같다.\n당연히 이런 팀은 어느샌가 서로 공격을 주고 받는 방식으로만 존재하게 된다. 당연히 공동의 선이나 생산성은 커녕 없는 성과만 만들거나, 실패를 성과로 포장하기만 잘하게 된다.\n원인은 여전히, 그 스스로 무능함을 의식적/무의식적으로 아는 ‘불안한 상사’와 그와 비슷한 ‘착한’ 직원들이다. 무능하기 때문에, 그리고 그걸 들키거나 명확히 하면 자기 자리를 위협 받을 것을 의식적/무의식적으로 알기 때문이다.\n오히려 ‘싸움닭’인 것 같다면, 그냥 그런 문제로 썩은 부분을 만들기 보다는 그 썩은 부분을 시원하게 털어내고 생산적인 일을 해내는 경향이 있다. 단지 그래서 저런 날개 달린 원숭이들에게 싸움닭으로 딱지붙이기를 당하는것뿐이다.\n특별한 범죄이력이 없다면, …오히려 저런 ‘착한 직원’이나 인성논쟁을 시작하는 이를 훨씬 더 경계해야 하는 이유들이다.\n어제와는 또 다르지만, 닮은 꼴인 오늘의 신기루 기술적으로는, 내 생각엔 AGI5 이전에 현재의 생성형AI은, 오답도 줄 수 있고, Reasoning이나 그런 부분에 더 강화될 부분도 많다고 생각이 든다. 하지만 그럼에도 이미 엄청나게 성장했고 고도화 된 것 같다. 그리고 거부하거나 무시할 수 없을 것 같다. 패러다임 자체를 변화시킬 것이 아니라, 이미 변화시켰다고 생각한다.\n흔히 말하는 패러다임변화에서 초기의 전환에는 새로운 패러다임이 사실 맞는것도, 실제로는 더 엉성하거나 할것 같다. 하지만 그럼에도 생존해 그런 부분들을 보완해냈으니 패러다임전환의 초기단계는 이미 지났다고 생각한다.\n하지만, 결국엔 원하는 곳으로 가기 위한 방향을 결정하거나 그걸 분석-이해하고 제대로 다듬어 나가기 위해선 안목과 배경이해가 필요하다. 그러나 예전에는 그냥 ‘개발자’가 다 알아서 해주길 바랬었고, 이제는 ‘AI’이 알아서 다 해주길 바라는건 똑같다. 글쎄다. 생각하는 기계가 아닌, 사실은 거대한 사전이 그걸 제대로 해주긴 당장은 어려울 것 같다.\n그리고 그걸 사용하는 사람들이 어떻게 함께 하고 있는가에도 AI은 영향을 크게 미친다. 하지만 역시나, 그리고 여전히 핵심적인 문제는 위에 말했듯이 크게 변화하지 못했다. 오히려 저런 사람들의 좋은 구실이 될 도구가 될 가능성도 커졌다.\n물론, 장사질을 잘 하려면 예나 지금이나 그런 고객들을 잘 구워 삶아야 하겠지만 싶기도 하다. 하지만 그런 고객들이 절대다수는 좋은 고객도 제대로 된 고객도 아니기도 쉽거니와, 오래도록 모실 수 있도록 오래 버티시는 고객도 아니시더라는게 일쑤라는게 내 미천한 경험이다.\nFootnotes 1 카톡은 그게 제대로 굴러가기 위해서 수 많은 서버와 시행착오의 시간, 많은 사람들의 고민이 녹아들어서 그렇게 되는 것일 것이다. 물론 최근의 카톡의 유명했던 ‘CXO이슈’라던가, AI이 그런 시행착오와 노력을 녹여들인 것이라는 생각은 좀 접어두고 말하고 싶다. (이 글에서 말하는 것도 그런 방향이니까)\n2 https://en.wikipedia.org/wiki/Snake_oil\n3 https://en.wikipedia.org/wiki/Winged_monkeys#In_psychology 4 예전에 영어를 잘 하는 누군가에게 이런 뉘앙스구나 하고 줏어들은 단어다. 고맙다 Mark.\n5 https://ko.wikipedia.org/wiki/%EC%9D%B8%EA%B3%B5_%EC%9D%BC%EB%B0%98_%EC%A7%80%EB%8A%A5 "},
 {
     "permalink": "https://ageldama.github.io/","title": "💡 아겔로그",
     
     "tags": [],
     
 "description": "",
 "contents": ""},
 {
     "permalink": "https://ageldama.github.io/posts/2026-02feb/selecting-title-emoji/","title": "🏹 원하는 emoji으로 선택되는 제목을 고르기 [0.798129]",
     
     "tags": ["webdev", "hugo", "gohugo", "go", "text-template", "html-template", "template", "emoji", "loop", "title", "shortcode"],
     
 "description": "자동 title-emoji 선택을 원하는 emoji으로 고르도록 만들어봤다",
 "contents": " 지금까지의 스토리 🐌 블로그 디자인 수정 + 제목 자동 emoji 붙여주기 그런데, 위 포스팅에서 밝혔듯이, 단순히 hashing 함수에 의해서 자동으로 이모지를 선택하는 것이니까, 의도를 담은 emoji을 선택하기는 어려움. 원하는 것 포스팅 제목은 (거의) 그대로 두고, 원하는 emoji을 선택하도록 하고 싶다. 시도, 아쉬운 점, 그래도 포스팅 제목에 추가적인 문자열 추가하며 원하는 emoji이 나올 때까지 루핑하는 shortcode-을 짰다. (…이전에 이미 문자열에 따라 이모지 출력하는 partial은 짜놓은걸 호출)\n그래서 다음처럼 호출되도록 했다: findemojititle str=\u0026#34;TITLE\u0026#34; target=\u0026#34;🏹\u0026#34; (…hugo template / shortcode 문법으로 호출했다)\n호출하면, TITLE-문자열에 계속 일정한 임의문자열을 시도하면서 target=-으로 지정된 이모지를 찾을 때까지 시도한다.\n그런데: Hugo template은 While-loop등-을 지원하지 않는다. 그리고 goto-도 지원 않음. 둘 중 하나만 있으면, 원하는 것을 얻을때까지 계속해서 시도할 수 있겠지만, 그렇지 못하니, 그냥 큰 수를 지정해놓고 그 횟수 동안만 시도할 수 있었다.\n대부분은, 루프를 실행하는 동안 원하는 값을 찾을 수 있었다만 항상은 아니었다. pseudo-random 함수를 써서 찾으니, 얼마나 반복하면 기대할 수 있을지 자신이 없다. ㅎㅎ 일단은 그래도 적당히 굴러가니 당분간은 사용해보려고.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-02feb/emacs-web-mode-dir-locals.el/","title": "💱 emacs / web-mode engine 선택",
     
     "tags": ["emacs", "dir-locals", ".dir-locals.el", "web-mode", "web-mode-engine", "elisp", "lisp", "emacs-lisp", "hugo", "django", "erb", "jinja2", "go", "golang", "go-template", "template-text"],
     
 "description": "",
 "contents": " hugo은 golang text/template, html/template 사용하는데, 또는 아예 다른 프레임웍(예: Rails)의 템플릿엔진을 매번 선택해주기 귀찮음.\nemacs web-mode-은 다양한 템플릿엔진을 지원. 그리고 무시하기 어렵도록 정말 편리함. ㅎㅎ\n이맥스답게 바로 discover / inspect하는 방법으로 설명을 해보려고 함.\n어떤 엔진을 지원하는지 알아보기 C-h v / web-mode-engines 변수 확인.\n1 2 3 ((\u0026#34;angular\u0026#34; \u0026#34;angularjs\u0026#34;) (\u0026#34;anki\u0026#34;) (\u0026#34;antlers\u0026#34;) (\u0026#34;archibus\u0026#34;) (\u0026#34;artanis\u0026#34;) (\u0026#34;asp\u0026#34;) (\u0026#34;aspx\u0026#34;) (\u0026#34;astro\u0026#34;) (\u0026#34;blade\u0026#34; \u0026#34;laravel\u0026#34;) (\u0026#34;cl-emb\u0026#34;) (\u0026#34;clip\u0026#34;) ... (\u0026#34;erb\u0026#34; \u0026#34;eruby\u0026#34; \u0026#34;erubis\u0026#34; \u0026#34;crystal\u0026#34;) ...) …위와 같은 list-of-lists을 얻는데, 저기 나온 문자열은 모두 web-mode-engine-에 지정하여 사용할 수 있음.\n유사한/같은 문법은 같은 리스트에 묶여 있음.\n예를 들어, \u0026#34;erb\u0026#34;-이라고 쓰거나 \u0026#34;eruby\u0026#34;-이라고 쓰거나 같은 문법엔진.\n파일확장자별 자동 설정 확인하기 web-mode-engines-alist 변수를 C-h v-으로 확인.\n1 2 3 (setq web-mode-engines-alist \u0026#39;((\u0026#34;php\u0026#34; . \u0026#34;\\\\.phtml\\\\\u0026#39;\u0026#34;) (\u0026#34;blade\u0026#34; . \u0026#34;\\\\.blade\\\\.\u0026#34;))) 파일별 수동설정 + 시험해보기 M-x web-mode-set-engine RET 실행하고 파일별로 적당한 문법엔진을 선택하여 시험.\n선택하면, web-mode-engine buffer-local-variable을 설정해줌.\n파일별 설정 💔 (setq web-mode-enable-engine-detection t) 설정한 다음,\n1 2 \u0026lt;?php /* -*- engine: php; -*- /* ... …와 같이 modeline을 설정하면 된다는데 잘 동작하지 않음. ㅎㅎ\nproject 전체 설정 : .dir-locals.el 다음처럼 project root에 .dir-locals.el-을 설정하면 됨:\n1 2 3 4 ;;; Directory Local Variables -*- no-byte-compile: t -*- ;;; For more information see (info \u0026#34;(emacs) Directory Variables\u0026#34;) ((web-mode . ((web-mode-engine . \u0026#34;go\u0026#34;)))) M-x add-dir-local-variable 사용하여, MODE= web-mode, VARIABLE= web-mode-engine 변수를 선택하고 값으로 go 입력해도 됨.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-02feb/hackers-and-painters-in-2026/","title": "⏯️ 2026년, 다시 생각해보는 “해커와 화가”",
     
     "tags": ["ping", "it", "software", "startup", "ycombinator", "viaweb", "paul-graham", "hackers-and-painters", "lisp", "scheme", "book", "영포티", "꼰대"],
     
 "description": "전설적인 Y Combinator, Viaweb의 Paul Graham의 에세이들을 생각해본다.",
 "contents": " 스타트업, IT기업들의 구인란과 Gig-job 사이트들을 보면, 예전이나 지금이나 다들 뭔가 ‘키워드 끼워맞추기’놀이를 열중하고 있다는 생각이 든다. 실은 별로 그렇게 중요할 것도 없고, 그렇게 찾아서 오히려 양자모두에게 도움이 되지 않는 방식일 뿐인거 같은데 말이다.\n그때나 지금이나 ‘리액트, 자바, 스프링, TypeScript, LLM, GPT’… 그냥 시대에 따라 사용자들이 많이 올려간 프레임웍이나 언어, 라이브러리를 그것도 뻔하디 뻔한 반복으로 나타난다. 그나마 조금 특이하다 싶은 것들은 그것들도 실은 그냥 리거시가 그걸로 되어 있으니 그렇게 써서 올리는것일뿐이다.\n예전엔 사회에 개발자에 대한 인식이 낮았기 때문에 유입된 인력의 수준을 기대하기 어려웠었다. 그리고 지금은 너무 많이 코더가 되고 싶어서 공부하고 유입된 인원들이 많은데… 솔직히 절대다수는 그렇게 나아졌나 회의적이다. 그냥 유행타는 키워드를 선행학습하고 왔을 뿐이지, 자기가 뭘하는지의 이해는 큰 차이는 전혀 없는거 같다. 오히려 인터넷의 개발자 클리쉐나 그런것들만 익혀서 더 머리엔 쓸모 없는것만 채운거 아닌가 우려스러울 때도 많다.\n그 맞은편도 마찬가지다.\n예전엔 모호하다고, 이해하기 어렵다고 뜬구름소리라고 투덜거리던 이들이, 이제는 AI의 영향으로 또 스스로가 잘 안다는 오해에 빠져서, 비슷하게 또 이상한 얘기들만 해나간다. 신기하게도 자기중심적으로, 말과 생각을 대충 굴절시켜 하는건 동일하다.\n글쎄다. 남들이 다 그렇게 생각하고 행동한다고, 그게 나도 그래야 한다는 의미가 되진 않는다. 더군다나 그 ‘남들’이 거의 엇비슷한 성주괴공(成住壞空)의 경로를, 그저 조금씩만 다른, 사실은 동일한 논리적 배경과 선택의 궤적을 그대로 답습하고 그 결과도 그렇게 만족스럽지 못할걸 생각해본다.\n…한국의 기업 햇수별 생존율을 생각해보면 더 그렇다. 물론 단순히 햇수가 늘어난다고 성공적이라고 하지는 못할것이다. 햇수가 늘어도 전혀 성장이나 개선이 없는 경우도 많을 것이기 때문이다. 다만 생존율만을 놓고 보아도 그렇게 낮다는 것을 지적한 것이다. 거기에 생존했지만 사실상 좀비상태인 곳들도 포함한다면 더 암울한 수치일 것 같다.\n그리고 그 뻔한 궤적을 그리고 있음을 비춰주는 좋은 정성적 기준은 구직자에게도, 구인자에게도 역설적이게도 어떤 기술적 선택, 어떤 ‘키워드’선택을 하는 것으로 그 놀이에 대답했는지라는 생각이 들었다.\n흥미롭게도 거의 25년이 지난 지금에도 그 판단기준은 전혀 변함이 없이 오히려 더 명확해지는데, 이상하게도 더욱 더 사람들에게 잊혀져 가고만 있다. 아마도 그때에도 이해했거나 진짜로 받아들였기 보다는 그저 구색맞추기로 입에 올리기만 하던건 아닐까 싶다. 단순히 어떤 프로그래밍언어나 프레임웍, 도구를 꼭 써야 한다는 것이 아닌 생각으로서 말이다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-02feb/2026-02feb07--01-ping/","title": "🦙 Ping 07/02/2026 .01 👁️",
     
     "tags": ["ping", "alan-parsons-project", "eye-in-the-sky", "karma", "bitcoin", "crypto", "btc", "hacking", "security", "claude", "hype", "saas", "startup", "vibe-coder", "programmer", "bubble", "llm", "gpt", "ai"],
     
 "description": "어제오늘의 뉴스를 보면서",
 "contents": " 어느샌가 뉴스의 대부분의 큰 화제가 컴퓨터와 인터넷 없이는 할 이야기가 적어질 정도였던거 같다. 이렇게 모든 일들이 연결될 일일까 싶을 정도로.\n불과 20여년전만 해도 그저 신기한, 현실과는 동떨어진 이야기로, 그저 먼 미래의 이야기로 이야기되던 발전이, 어느새 지금 당장의 일들이 되어 버렸고 그게 일어나고, 잠시뒤의 과거로 뉴스가 되어 버린다. (물론 20여년은 엄청 긴 시간이다. ㅎㅎ)\n해킹이나 보안과 관련된 이슈, 그리고 그에 따른 정부와 거대기업간의 논의가 일어났고, 또 진행중이다.\n단순히 숫자, 데이터, 혹은 바이트 덩어리일 뿐인 것이 잘못 기입되어 순식간에 부자가 되었다가 또 환불은 어떻게 됐는지, 그리고 실은 조작이 아닌지 하는 흥미로운 가쉽들도 많이 떠돈다.\n또 그 무언갈 옹호하고 환호하던, 생각과 안목이 모자란 사람들을 가장 먼저 등졌다. 그 Hype에 편승하고 싶던, 실은 세상 누구보다 가장 미신적인, 21세기형 주술에 빠진 사람들. …맑스베버, 유교/성리학, 냉전 이데올로기, 경제… 등등 그런것을 적하숭배하면 그들의 구슬픈 외사랑이 이루어질거라 착각하는, 서글픈 오컬트에 빠진 이들. 그런 슬픈 맹목성이 응답 받지 못하는 흐름은 더 명확하게 흘러갈것이다.\n그리고 혼란한 시기가 흘러가면, 정리가 되고, 더 건강하게, 그런 모순을 이루던 것들이 쓰러져 거름이 되어 더 좋은 숲이 될 수 있겠지. 🌲\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan31--01-ping/","title": "🐳 Ping 31/01/2026 .01",
     
     "tags": ["ping", "the-rolling-stones", "million-dollar-baby"],
     
 "description": "“Wild Horses” 🐎🫦👅",
 "contents": " 영화를 통해 정말 멋진 웃음 / 매력적인 여배우들을 많이 봤었지만, 그중에 가장 멋지다고 생각하는 웃음 중 하나는 밀리언달러베이비에서 버스에 앉아 창밖을 보며 묘한 미소를 지을 때였던거 같다.\n그 장면만으로 그를 봤다면, 이해하기 어려운 웃음이겠지만.\n살아가면서도 비슷한 경험들을 하는 것 같다. 다행스럽게도. 또 레몬 파이를 먹고 싶어졌다. 싸구려 통조림에 든 것이 아닌 진짜로 만든. 🍋\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan27--01-ping/","title": "🍁 “Protection” Massive Attack",
     
     "tags": ["ping", "massive-attack", "protection", "hackers", "pixie-cut", "angelina-jolie", "his-mothers-passwod-is", "mezzanine"],
     
 "description": "겨울의 따스함, 그리고 안젤리나 졸리의 “Pixie Cut”",
 "contents": " 그리고 추억의 명화 ㅎㅎ\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/hugo-builtin-sass-esbuild/","title": "🛥️ hugo builtin sass/esbuild 으로 전환",
     
     "tags": ["programming", "webdev", "hugo", "esbuild", "sass", "js", "css", "sass", "scss", "ping"],
     
 "description": "블로그에서 써오던 방식과 조금 다르게 구성해서 사용해봤다.",
 "contents": " (배경: 이 블로그는 sass=hugo내장, esbuild=npm을 통해서 빌드하고 있었음. 참고 👉 아겔로그변천사 )\n어쩌다 만들게 된 hugo 사이트에서는 javascript build도 hugo builtin으로 바꿔봤다. 잘 동작했다.\n…그래서 이 블로그도 그냥 모두 hugo 내장으로 변경. 적당히 잘 굴러가서 마음에 든다.\n구성이 더 단순해졌다. hugo 최고💌\nHugo: js.Build Hugo: css.Sass PostCSS, Tailwind.css도 지원하는데 딱히 끌리진 않음. (아직은) sass자체가 좀 이상하게 동작하고 하기는 하지만.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/shooting-star--lzzy-hale/","title": "🥧 Halestorm “Shooting Star” / feat. Paul Rodgers",
     
     "tags": ["ping", "halestorm", "lzzy-hale", "paul-rodgers"],
     
 "description": "요즘 잘 없는 이런 시원한 노래도 좋으니까.",
 "contents": " "},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan26--03-ping/","title": "🤹‍♀️ “Hands of Necromancy II”",
     
     "tags": ["gaming", "fps", "hands-of-necromancy"],
     
 "description": "hands of necromancy 시리즈",
 "contents": " 지난번 ‘Hands of Necromancy’ 포스팅 이후, II도 플레이.\n맵을 돌아다니기에도 아름답고, 재밌는 방식으로 날아다녀야 하거나 물리엔진을 이용한 재밌는 방식이 더 늘었다. playable character이 하나 더 늘어나서 약간씩 차이가 있음. 전투가 조금 더 재밌어졌다. (…적이 한 번에 많이 덤빈다) 보스전은… 좀 너무 빡쎄다. 그렇게 엄청 인기가 많은 게임은 아니니 막힐 때 공략이 마땅히 없어서 오히려 더 \u0026lt;tab\u0026gt;으로 맵을 뒤적거리면서 하나씩 backtracking해서 풀어야 했다. 오랬만에 이게 더 재밌었음.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan26--02-ping/","title": "🧡 Ping 26/01/2026 .02",
     
     "tags": ["ping", "twin-peaks", "david-lynch", "ost", "david-duchovny", "the-x-files", "donuts", "damn-good-coffee", "coffee", "orientalism", "sawmill", "fbi", "dea", "scully", "japanese-breakfast", "be-sweet"],
     
 "description": "데이빗 린치의 ‘Twin Peaks’에 대한 생각",
 "contents": " 트윈픽스는 오프닝 이외에도 OST 음악들 전반적으로 좋으다.\n한국 TV에서 방영한적이 있다고 하는데, 그때 난 시청하진 못하고 나중에야 인터넷을 통해 구해서 봤다.\n외적으로 재밌을거 같은 이야기는(엑스파일 팬이라면), 엑스파일에 영향을 강하게 준 드라마였으리라 추측한다.1 물론 엑스파일 자체가 시즌1에서는 ‘양들의 침묵’의 분위기를 대놓고 복제하려 시도한다. 이후 시즌/에피소드에서 점점 그런 색깔을 내려놓고 엑스파일 자체만의 캐릭터, 분위기, 구조를 완성하지만 말이다.\n예를 들어, 스컬리의 아버지-은 아예 같은 배우이고, 트윈픽스에서 음모를 숨기고 있는 공군장교-으로 나오는데, 엑스파일에선 퇴역한 해군장교으로 나온다.\n엑스파일의 멀더, 데이빗 듀코브니는 트윈픽스에서도 요원 캐릭터이다. 다만 FBI이 아니라 DEA요원으로 나온다. 다만 어느샌가 크로스드레싱에 눈을 뜬 조금 묘한 요원으로 나오는데, …정장에 뭔가 사자머리 같은 느낌이 미래의 스컬리를 떠올리게 만든다. (…스컬리팬입니다.)2\n음, 시즌1 이후에 캐릭터를 더 개발한거 같은 느낌을 받는 부분들도 있다. 처음에 조금 활용되고 시즌2에서는 더이상 비중이 전혀 없는 오드리의 다른 가족멤버들이라거나.\n하옇튼 다시 봐도 재밌는, 그리고 캐릭터에 대해서 애정을 더 깊어질만한 드라마인 것 같다.\n오프닝은 뭔가 꿈결 같은 화면과 음악이다. 그리고 사실 거의 모든 에피소드 내내 그렇다. 그 이유는 어쩌면 꿈과 현실, 혹은 현세계와 영적인 세계의 대칭, 혹은 서로 비춤을 이야기하고 싶었는지도 모르겠다 싶다.\n제목인 ‘twin peaks’도 그런 서로 비추며 닮은 무언가를 말하고, 오프닝의 ‘톱날 생산장면’도 그런 모습을 그려낸다. 하나 하나 마치 산봉우리 같은 모양을 이루며 단순히 앞으로 전진해 나가면서 다듬어져 가는 모습은 에피소드 하나 하나가 전개되며 트윈픽스로서의 형태를 만듦을 보이는 것 같아 보인다. 개별 톱날 하나하나의 연마도 앞으로 나아가며 다듦어 지기도 하며, 반대로 그렇게 앞으로 나아간 연마공구의 뒷면을 이용해 다시 반댓편 날을 만드는 모습도 흥미롭다. 그리고 앞으로 나아가는 것처럼 보이지만, 실은 제자리에서 빙글빙글 돌고 있는 톱날이기도 하고, 제자리를 영원히 지킬 것 같지만 그래도 하나씩 앞으로 나아가는 컨베이어 벨트 또한 흥미롭다.\n많은 에피소드들에서 계속해서 영적인 세계에 대한 언급이 있는데, 데이빗 린치의 다른 영화들에서도 계속해서 나타나는 것 같다.\n오히려 서양문화가 동아시아문화보다 더 정신문화/문명, 영적인 세계에 대해서 열려 있는 태도라고 생각한다. 서양의 오리엔탈리즘을 서양화되는 과정에서 받아들여, 다시 그 오리엔탈리즘을 스스로의 과거에 투사하는, 더 괴이해진 오리엔탈리즘으로 스스로의 과거를 바라보는 동아시아는 오해하곤 하는 괴상한 현상이 일어나고는 하지만. 스스로의 문화로 살아간다기 보다는 서구문명의 일부로서, 변용되어 동작하기 때문에, 그리고 과거와의 단절을 타의적/자발적으로 겪었으며, 더군다가 서구의 시선으로 바라본 오리엔탈리즘을 다시 받아들여 그걸로 스스로의 과거를 오해하며 바라보는 희극적인 상황 같다. 그리고 그러한 서구문명의 배경에서 트윈픽스, 엑스파일은 훨씬 동아시아에서보다 더 받아들이기 쉬웠을거 같다.\n뭐 잡소리는 많이 했지만, …오프닝만으로도 분위기가 쩐다.\nFootnotes 1 \u0026#34;the x files\u0026#34; / 90년대의 분위기 포스팅 참고\n2 재밌는건, Japanese Breakfast의 Be Sweet 뮤직비디오에서는 아예 누가누구 역할인지 헷갈리지만 이런 크로스드레서 캐릭터를 활용하는거 같다. 트윈픽스+엑스파일의 이런 맥락을 이용한건지는 불확실하지만. ㅎㅎ Be Sweet의 가사 자체가 엑스파일을 아는 사람이라면 조금 다르게 들리는 가사이기도 하다. https://www.youtube.com/watch?v=2ZfcZEIo6Bw 📺\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan26--01-ping/","title": "🎭 “The Origin of Love” / Lena Hall ‘Obsessed’",
     
     "tags": ["ping", "lena-hall", "the-origin-of-love", "hedwig"],
     
 "description": "",
 "contents": " "},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan25--02-ping/","title": "🏣 “small web” || “dead internet”",
     
     "tags": ["ping", "blog", "blogging", "daily", "writing", "portishead", "roads", "small-web", "geocities", "neocities", "dead-internet-theory", "altavista", "google", "easter-egg", "sns", "twitter", "x.com", "mastodon", "reddit", "4chan", "doom-scrolling", "youtube"],
     
 "description": "블로깅을 하는 이유와 게으름에 대해 &amp;&amp; Portishead",
 "contents": " sns을 하거나 남들이 더 접근하기 손쉬운 매체, 혹은 내게 더 이익이 될 수도 있을 유튜브나 그런걸 하는게 더 좋을거 같다는 생각을 해본다.\n남에게 관심을 더 끌고 싶은 마음도 없고 그래서 따라올 의도하지 않은 피곤함도 이제는 사양하고 싶어서 같다. 유튜브 같은건 잘 해낼 능력이 있을까 싶기도 해서.\n죽은 인터넷 이론 같은걸 단순히 음모론으로 평가절하하기엔 지금 시대의 휩쓸림, 편향, 소비주의, 자본주의, ‘bot’-같은걸 너무 잘 포착한 생각이지 않나 싶다.\n과거, 그러니까 altavista 시대나 구글 검색의 초창기까지만 해도 뭔가 웹검색을 하면 내가 모르는 어딘가가, 더 탐험할 어딘가가 더 있을거 같았다. 요즘엔 스마트폰이나 웹브라우저를 켜도… 마땅히 가고 싶은 곳이 떠오르지 않는다.\n말초적 자극을 원해서 켠 한국 게시판들은 뭔가 조금 보고 나면 기가 빨리는 느낌이다. 신기할 정도다. 그래서 가지 않게 된다. YouTube은 가서 한참을 동영상을 고르고 doom-scrolling을 해댄다만 정신을 차리고 싶게 만든다. Reddit을 봐도 그냥 언제나의 내 취향의 커뮤니티를 가입한 것의 피드들이 올라온다. 정말 dead-internet 같은 느낌이다. 4chan도 굳이 가도 재밌을거 같진 않다. X, Mastodon도 마찬가지다. …그냥 내가 늙고 기운이 빠져서 그런걸까 싶기도 하다.\nsmall web 운동이나 과거 geocities을 다시 향수하는 neocities 같은걸 봐도… 참여해야 할까 싶은 마음이 별로 들진 않는다. 그때가 그립긴 하지만, 그리고 웹에, 인터넷에 그런 구석이 한구석 있어줬으면 하고 바라긴 하지만.\n구글에서 ‘geocities’을 검색하면, 그때 그 폰트대로 표시해주는 easter-egg\u0026hellip; 이 easter-eggs을 만든 누군가도 그때를 추억하고 있나보다\u0026hellip;\n…그냥 웹1.0, 웹2.0을 그리워 하는 꼰대의 중얼거림인거 같다. 어쨌든 나는 그래도 그냥 여기에서 멍청하게 어쩌면 별로 읽을 사람도 없을 글이나 올리고 싶을 뿐인거 같다.\n…그나마 지금 같은 때에 아쉬운건, 그래도 좋아하는 노래들을, 자주 듣던 노래들을 더 정리해서 올려보고 싶다는 마음. 그래서 하루에 몇 편 씩 포스팅하지 않으려면 꾸준히 계속해서 올려야겠다는 생각이다.\n…2000년대 초에 들을 때엔, 정말 암울하게 느껴졌었다. 그런데 지금이 더 그때보다 어둡지 않나?싶다. (꼰대가 된게 맞나보다) …저땐 그렇게 암울할게 적었을거 같아 보이는데 뭐가 저렇게 암울하게 노래해야 했을까 의아스러울 정도로 현시대가 더 암울한거 같다. ㅎㅎ\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan25--01-ping/","title": "👛 “When It Begins To Get Dark...” Sheena Ringo",
     
     "tags": ["ping", "sheena-ringo", "2000"],
     
 "description": "“가끔은 두려워하지 않고 내일을 맞이해 보고 싶어”",
 "contents": " 나의 20대초의 기억. 요즘엔 “Marunouchi Saditic”-이 유튜브에서 유행인거 같더라. 그곡도 좋아하지만.\n뭔가 내일을 조금 더 나아진 관점에서, 편안한 마음으로 바라보고 싶은 요즘 시대, 그리고 내 시점 때문에 이 곡이 더 끌리는지도 모르겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan22--01-ping/","title": "➗ Ping 22/01/2026 .01",
     
     "tags": ["ping", "wise-up", "aimee-mann", "마왕__잘_있지?"],
     
 "description": "어떤 사람들은 추억을, 또다른 이들은 교훈을 남긴다",
 "contents": " 잘난척을 더 하고 싶어서, 예전에 기억을 블로그 포스팅을 작성했다. 글을 쓰면서 내게 고마운 점들을 알게 됐다. 적어도 내가 뭘 할 수 있고, 어떤 성취가 가능한 사람인지 더 깊이 이해할 여지를 만들어준 고마운 이들이었었다. 물론 그들은 그런 의도가 아니었던거 같다만. 😅\n물론 그런 이들은 그렇게 내 코를 납작하게 만들어서 고분고분하게 만들고, 또 자기들이 못나지 않았음을 인정 받고 싶어서 그렇게 요청했던 것임을 알고 있다. ‘나’로서 살아가다 보면, 종종 그런 부류의 사람들, 그렇게 반응하는 사람들을 마주칠 때가 왕왕 있어 왔었었다.\n그런데 웃기지 않은가. 그런걸 놓치지 않고 모두 성공시켜 버렸다는게. 웃긴 일이었다. 오히려 나는 그때마다 그런 곳에서 더 입지가 확고해졌고 더 자신감을 얻게 되었었으니까.\n…하지만 덕분에 나는 어떤 이들과 시간을 보내고 싶고, 어떤 이들은 아닌지를 더 배웠다. 덕분이다.\n이렇게 생각하고, 또 알고 보면 그런 이들은 세상 누구보다 냉혹한 척, 약삭 빠른척, 똑똑한척을 하지만, 실은 헛똑똑이, 그리고 어리숙하기 때문인거 같다. 자기 스스로의 불안 때문에 그래야만 한다고 착각하고 그렇게 선택한다. 또 그것만이 전부라고 한정된 스스로의 경험과 앎만으로, 그리고 그 경험마저도 제대로 평가되기 어렵도록 시도 해보지도 않은 채, 그런 냉소주의에 빠져서 그렇게 혼자 단정 짓고 착각에 빠지니까 말이다. 하지만 이해한다. 나도 아마도 그런 정도의 사람일테니까. 혹은 아마도 그런 정도의 사람이었을테니까. 그리고 다른 그 어느 누구보다 그걸 나는 나 스스로 너무나 잘 알고 있을테니까 말이다.\n최고의 사람들은 추억을 남기고, 최악의 사람들은 교훈을 남긴다고 하더라. ㅎㅎ… 그래도 매순간 추억을 만들고 온정을 주려 애썼지만, 어떤 이들을 그것도 비웃고 얄팍한 것으로 평가절하하며 내팽겨치면서, 한편으로는 내게는 교훈만 많이 줬구나 싶다.\n그리고, 그럼에도 불구하고 나는 앞으로도 그냥 더 그런 마음과 행동을 계속해야 할 것 같다. 그게 맞는거 같으니까 말이다. 마찬가지로, 내가 알아봐주지 못하고 내팽겨쳐버린 수 많은 고마운 따뜻함들, 그런걸 내게 내밀어 준 이에게 나는 차갑디 차가운 그런 싸구려 냉소주의의 비수만을 답했던거 같으니까 말이다.\n그래도 살아가면서 조금은 뭔가를 배운거 같긴 하다. 다행이다.\n그리고 그 포스팅은 굳이 올리지 않으련다. 그럴 여지도 없이 정리해서 썼지만 이젠 “굳이?” 싶어서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/vb6-pcode-for-activex/","title": "🧿 잃어버린 결제모듈 소스코드와 VB6 P-Code",
     
     "tags": ["reversing", "activex", "windows", "win32", "com", "pcode", "vb6", "visual-basic", "ocx", "bytecode", "vm"],
     
 "description": "(법정관리하의) 쇼핑몰 소스코드도 잃어버렸다는, ActiveX 결제모듈에 결제방식을 추가하는 모험의 이야기",
 "contents": " 어느 계약직 X 어느 회사에 계약직으로 일하던 때였다. 이 이야기도 거의 2010여년 전후일 것 같다.\n바보인척하며 그냥 명랑하게, 그리고 받은 일을 충실히 최선을 다하며 그냥 지내던 때였다.\n정직원들은, 그렇게 친절하지는 못했다. 나이도 나보다 많았고, 이미 법정관리에 들어간(2번째) 회사였었는데, 어쨌든 그렇게 아름다운 관계는 되기 어려웠다. ㅎㅎ\n친구들, 구내식당, 그리고 미성숙한 자신에 대한 후회 출퇴근하기 좋고, 어쨌든 남들이 뭐라고 하건 좋은 성과를 내고 충실하고 정직하게 일했던거 같다. 그리고 그게 나쁘진 않았다. 그냥 나를 이해해주고 제대로 평가해주는 팀장님이나 그냥 비슷한 또래의 다른 정직원이나 또다른 계약직과 친하게 지내며 21층 구내식당에서 행복하게 밥을 먹으며 서로 더러운 농담을 만들며 킬킬거리며 잘 지냈던거 같다. PC하지는 못한 농담들이었다. ♂️❤️\n지금 돌아보면 좋은 우정이었던거 같다. 내가 그렇게 사귄 친구에게 어줍잖은 자존심이나 어설픈 사회적 성공을 갖고 지금보다 더 미성숙하던 내가 멍청한 소리들을 해서 지금은 헤어진 것이 후회스럽고 미안하다.\n하지만 당시의 젊고 뭘몰랐고, 혼란스럽던 그 친구를 조금은 이해해줬으면 좋겠다. …이 사회에선 그렇게 돈이나 자리, 회사 같은 것에 혼란스러워 하는게 너무 보통이기도 한 세상이니까 말이다. 슬프고 허망하게도.\nJava, Spring, Oracle DBMS, 거기에 프론트엔드 개발까지 속해 있던 팀은 회사내부의 ERP시스템이나, 중견기업이던 그 회사의 직원을 위한 쇼핑몰을 유지보수하는 역할이었다. 대부분은 Java + Spring, Oracle DBMS으로 삽질을 하며 보냈었다. 원래 있던 ‘유지보수’업무를 하던 정규직 직원들은 MiPlatform 정도만 가끔 하고, 사실 자바도, 오라클도 관심이 없었다.\n거기에 ‘퍼블리셔’ 업무를 해주던 친구는 있었지만, 자바스크립트나 그 친구가 짜주는 HTML/CSS을 갖고 화면에 붙이고 로직을 붙이는건 전부 내몫이었다. 덕분에 jQuery을 쓰면서 DB/서버/프론트엔드까지 혼자 디자인과 퍼블리싱만 받은 쇼핑몰 개편을 해내거나, 매달 만드는 별거 없는 ‘행사’관련 퀴즈나 기획에 따라 간단한 낱말게임 같은걸 짜고는 했다. 재밌었다.\n물론 당시엔 Backbone.js이나 Angular.js의 극초기였고, ‘프론트엔드’개발자는 생소한 개념이었으리라 싶다.\nCVS, ViewCVS, Subversion: ‘로마에선 로마법을 따라라’ 솔직히 거기 ‘정직원’이라며 건들거리던 분들은 좀 별로였던거 같다. 예를 들면, 팀에 합류할 때엔 CVS + ViewCVS -을 썼다고는 하지만, 이미 ViewCVS은 제대로 동작하지 않고 있었었고, 누가 어디를 고쳤는지 명확히 알기 어렵기 때문에 자기들이 문제를 만들어 놓고 그걸 나중에 합류한 n00b이 문제라며 뒤집어 씌우거나 하는 정도의 우리 사회에 평범하다면 평범한 수준의 사람들이었다.\n그런 상황에 팀장도 골치가 아프니, 설득해서 당시엔 쓸만하던 Subversion-으로 전환했다. 그 다음에 정말 말그대로 멱살을 잡혀서 옥상에 끌려가서 ‘로마에 가면 로마법을 따라야 한다’며 그 정직원들에게 헛소리를 들어야 했다. 물론 그때에도 헛소리인걸 너무 잘 알아서 그냥 신경도 쓰지 않았다.\n헤드헌팅업체와 남의 대학원 논문 물론, 나도 딱히 그들에게 고분고분한 ‘어린 후배’ 역할을 해주진 않은 것 같다. 매일 밀려드는 업무를 쳐내느라, 또 야근눈치를 너무 노골적으로 주던 곳이라 매일 야근에 근태는 별로 관심 없었다. 그리고 나아가서 중간 ‘헤드헌팅’업체는 좀 과하게 떼먹는 것 같고 그렇다고 제대로 계약금을 올려주지도 못하는, 어쨌든 내가 계약을 유지해주는걸 고마워하지도 않는 곳이었다.\n더군다나 다른 총책임자는 자기 대학원 논문을 위한 코딩을 냉면 한 그릇 사주고 부탁하거나(물론 당시 말대로 ‘KIN’때려야 할 정도의 부탁이었다) 하는, 지금 생각해도 어질어질한 상황이었다.\n그래도 그냥 잘 건강히 지내려고 노력한 것 같다 말했듯이, 그 사람들은 일에 대해서도, 그리고 감정휴지통으로서도 좋지 못하게 악용하며 대하는 인격적으로 별로 기대하기 어려울 사람들인걸 당시에도 잘 알고 있었다. 그리고 그때나 지금이나 어떤 사회에선 그렇게 행동해도 될거라고 착각하며, 결국 스스로에게 가장 좋지 않은 영향만 만들어 내는 사람들이 있다.\n지금 돌아보면, 그렇게 행동한다고 그 나중에 엄청난 이익을 얻거나 하는 것도 아니다. 반면, 그렇게 쓰레기이기만 한 일도 아니었다. 성실히 진지하게 대했어도 될 일들이었다.\n그런 사람들은, 항상 그 양극단을 자기정당화를 위해 오가며 선택한다. 하지만 반대가 훨씬 좋은거 같다. 겸허할 곳을 알며 한편으로는 진지하게 최선을 다하는게 내겐 더 좋은 관점인 것 같다.\n그리고 또다른 모험의 여명 ⚔️🪄 그렇게 지내던 중에, 그 쇼핑몰에 또다른 결제방식인 ‘escrow방식’을 추가해야 한다는 이슈가 발생했다. 어디서 나왔는진 모르겠다.\n재밌는건, 그 결제모듈은 당시 Internet Explorer / Windows만을 위한 그 쇼핑몰 웹사이트에서 사용하기 위해 제작된 ActiveX였는데, 그 소스코드를 잃어버렸다고 하는 것이었다.\n글쎄다, 지금에 와서 생각해보면, 그 정직원분들이 앙심에 그러는 것일 수도 있고, 정말 잃어 버렸을지도 모르겠다 싶다. 이미 버전관리가 어떤지 봐왔었으니 충분히 그럴만도 하다 싶다. 그리고 한편으로는 그런 허술한 측면을 자신들의 무기로 만들려고나 드는 정도의 인격인걸 알기 때문에 고의적일거라는 의심이 드는 것도 타당할 것 같다.\n하옇튼 나는 그냥 모른척 해도 됐을거 같다. 소스코드를 잃어 버렸다는데 뭐 어쩔건가. 그런데 그냥 뭔가를 시작했다.\n초기분석과 계획수립 🔬 소스코드는 잃어버렸다고 해도, 바이너리는 있으니 OCX/DLL 파일 분석을 해봤다.\n결과는 나름 행운이었던거 같다. 아니면 그냥 Visual Basic 6-을 사용해준 조금은 게으른 누군가에게 고마워 해야 했을까.\n어쨌든 분석으로 얻은 지식은:\nVB6으로 작성했다. 그리고 단순히 다른 결제업체(“PG업체”)가 제공한 DLL을 호출하는 방식. ActiveX인 이유는, IE에서 사용하기 위해서. 그리고 VB6은, 현재의 Visual Basic .NET-와 달리, 그리고 Delphi 등과는 또 다른 방식으로 코드를 컴파일했다.\n만약 전자의 .NET 방식으로 컴파일되었다고 하더라도 리버싱이 수월했을 것 같다. 하지만 그렇진 않았다.\n다만, 델파이나 Visual C++ 등이 진짜 x86 기계어코드를 생성해 내는 것과 다르게, VB6은 P-code-이라고 불리는 바이트코드으로 컴파일해놓고, 그걸 나중에 그 이미지가 실행될 때에, VB6을 위한 VM이 실행하는 ‘사실은 interpreted’-방식이었다.\n실제로는, VB6이 네이티브코드를 생성하는 것도 가능했겠지만, 그런 ‘자잘한건’ 그 약간 게을렀던 누군가는 관심이 없었던 것 같다.\n결론적으로, 내게는 Jackpot! 🎃\nP-code 문해능력 👓 그렇게 얻어낸 P-code을 모두 출력해서 그냥 읽기 시작했다.\n인터넷을 뒤져서 당시에도 고대의 지식이어서 사라져가던 VB6 P-code에 대한 자료들을 모아서 공부했다.1\n그렇게 이해한 것을 기반으로, 출력한 바이트코드에 메모를 해가면서 재구성해나갔다. 어차피 VB6이 그렇게 많은 Syntax construct을 갖지는 않았기 때문에 조금 오래 걸리지만 명확하게 정리해 나갈 수 있었다.\nPG API와 재구성 완료 😘 그리고 한편으로는 ‘PG모듈’의 API문서와 예제들을 읽고 이해하고, 분석한 사용코드와 짝을 맞춰 나갔다. …그리고 Voilà!\n모든 기능을 그대로 다 재구성해내고, 원래의 목적이던 새롭게 지원되기 시작한 결제방식도 잘 붙여줬다.\n그리고 무엇보다 이번엔 SVN 저장소에 잘 커밋해서 잃어버렸다는 이야기가 생기지 않도록 노력했다. 🤣\n뒤돌아보며 🎒 이 포스팅을 시작하며, 얼마나 같이 있던 사람들이 악한 사람들인지 떠들었던거 같다. 하지만, 실은 그런 사람들도 미성숙하고 무력한 사람들이었던거 같다. 어떻게든 사회에서 먹고 살고 살아남으려 애쓰던 것 뿐이다. 물론 그 방식이나 정도가 잘못되었고 그럴 방향도, 그렇게 마음 먹어야 할 필요도 없이 악하게 굴었던건 사실이다.\n하지만, 오랜 시간이 흐른 지금에 돌아보며, 또 그들이 어떻게 지내는지를 알고 있는 입장에선, 그렇게 살아서는 절대 좋지 않구나 생각이 든다.\n그리고 이 글이 기술적인 내용보다, 훨씬 역학적인 상황이나 인간에 대한 이야기가 많은 이유는, 그다지 밉지 않기 때문이다. 물론 친구로 사귀거나 같이 일하고 싶진 않다. 하지만 그렇게 그들이 해준 덕분에, 그들이 감히 어디서 굴러들어온 외주계약직이 해낼거라 믿지 않아준 덕분에, 내가 실패할거라 기대해준 덕분에 이 리버싱을 성공할 수 있었고, 멋진 성취감을 느낄 수 있었다. 그리고 그런 성취감은 계속해서 나를 어떤 특정한 방향으로 성장시켜줬던거 같다.\n그 이후에도 그러한 방식으로 나를 대하는 사람들을 접하게 되어도 더 깊이 이해하게 되었다. 오히려 내 상대로 있는 그런 사람들은 적어도 그 시점엔 절대로 이해하지 못할 관점과 깊이로서 나는 그런 상대를 이해할 수 있게 된 것에 감사한다.\n그리고 그때의 인연들중에 지금에 와서 감사하다고 말하고 싶은 좋은 사람들도 많다.\n기술적으로 어떤 교훈보다는, 그것들을 어떻게 바라보고 받아들이는지는 이 글을 통해서 이미 충분히 이야기한 것 같다. 그리고 그게 정말 중요하다고 생각한다.\nFootnotes 1 https://stackoverflow.com/questions/12908062/visual-basic-6-bytecode-specification\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/book-designing-data-intensive-applications/","title": "👒 책 “Designing Data-Intensive Applications&#34;",
     
     "tags": ["book", "reading", "ddia", "oreilly", "distributed-system", "backend", "database", "acid", "base", "cap", "rpc", "columnar", "sharding", "replication", "consitent-hashing", "rebalancing", "dbms", "nosql", "sql"],
     
 "description": "웹개발쟁이로서 한번 읽어봤다 (1st edition)",
 "contents": " 책의 목차나 내용을 정리하며 나가지는 않겠다. 읽을 관심이 있을만한 사람들은 분산시스템, 데이터처리 시스템에 대한 내용만이 아니라, 현대의 백엔드 시스템에 대해서, 그리고 이와 관련한 dbms, 혹은 zookeeper 등은 물론 grpc, columnar storage 등등에 대한 내용을 이해하고 싶다면 읽을만한 책인거 같다.\n분산시스템-에 대한 이해를 얻기 좋은 책이다. 현대에 넘쳐나는 문맥을 이해하기 어려울 정도로 많은 키워드들이 왜 필요한지, 어떤 문제를 각각 어떻게 접근하는지 넓은 지형을 살펴볼 수 있고, 각 분산시스템, 데이터시스템의 문제에 대해 깊이 있게 설명해준다.\n반면, 예제코드를 통해 설명하거나 ELI10 같은 방식으로 유치하게 설명하지도 않는다. 솔직히 그렇게 CS배경지식이 없는 사람이 읽어서 쉽지는 않을 책이다.\n하지만 추천할만한 책인 것 같다. 스스로가 이 책의 목차를 살펴보고 이게 뭘 이야기하려는 책인지가 와닿는 이라면 스스로 찾아서 읽을 것 같은 책.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/mem-padding-for-aka-security-solutions/","title": "😷 메모리패딩과 Heisenbug 추억담",
     
     "tags": ["reversing", "product", "solution", "security", "debugger", "debugging-mode", "mingw", "gcc", "gdb", "segfault", "lua", "memory", "windows", "win32", "com", "activex", "heisenbug"],
     
 "description": "Lua 써도 메모리 문제가 깜빡이도 켜지 않고 들어올 수 있다🚔",
 "contents": " 추억을 돌아보며 아마 이 기억은 2010년 전후였던거 같다. 당시 나는 작은 회사에 소속이었는데, 회사가 작을 때에 다같이 SI에 파견되었을 때에, 내가 S/W 솔루션 제품을 설계/개발한 것을 납품하며, 그 솔루션과 함께 SI구축을 하는 프로젝트들을 수주 받는 회사였었다.\n원래는 그 SI프로젝트에서 ActiveX 정도를 몇 개 개발하고 덮었어도 될 것을, 솔루션화하고 납품처에 따라 쉽게 적용할 수 있도록 설계/개발을 사실상 나 혼자 했었었다. 자세한 기술적 사항을 모두 설명하지는 않겠지만, Windows API, C++, Lua, HTTP/1.0, JSON을 잘 조합해서 필요한 것을 만들어냈다. 지금 돌아봐도 훌륭한 창조력이었던거 같다.1\n자기들이 가진 ‘분석툴’이 이해할 수 있도록 어째서 Visual Basic 6으로 짜지 않았느냐며 징징거리는, 그 자리에 앉으면 안될 책임자라던가 하는 괴상한 경험을 많이 했었었다.2 …이 포스팅의 이야기도 그런 경험에 대한 것이다.\n문제 나는 처음 그 ‘SI프로젝트’를 우리 회사팀이 성공시켜서 고도화 계약까지 따내서 아예 그 사이트에 상주하며 지내고 있었다. 분당이었다.\n그렇게 세월을 보내던 중에, ‘근처’ 수원쪽에 구축을 위해 혼자 파견된 직원에서 문제가 발생했다. 처음엔 같은 개발자였던 이가 갔었지만 제대로 해결해내지 못했다. 그는 스스로가 훌륭한 개발자라고 믿는, 하지만 역시나 주변에 “값싼 talk”만 해대는 사람들만 남기게 되는 그런 정도의 사람이었다. 그리고 “똑똑하다”는 평가를 받던 혼자 파견되었던 직원은 결국 견되다 못하고 도망가고야 말았다.3\n책임을 내게 돌리기 위해서겠지만, 나를 끌어들였다. 아마 그는 실제로는 C++/윈도API/COM으로 만들어진걸 만져야 하면서, 자기가 뭘 하는지 잘 이해하지 못했을거 같다. 그는 개발자로선 당시 트렌디한 키워드인 OOP, Java, SOA 같은 것만이 진리라고 믿으며, 그렇지 않은 다이나믹언어나 네이티브언어, 로우레벨은 평가절하하던 적당히 당시 시류에 적합한 평범한 사람이었다.\n문제는, 정상적으로 동작하다가 예상치 못한 상황에 ‘잘못된 연산’ 정도의 에러를 내고 프로그램이 종료된다는 것.\n원래의 솔루션의 memory leak이나 access violation 등을 검사했었고, 또 동일한 바이너리가 다른 사이트에서는 아무런 문제가 없어서 더 골치가 아팠다.\n특이한 현상: heisenbug 우선 mingw32 gdb을 붙이고 문제가 되는 영역을 좁혀나갔다. 그리고 해당 부근의 Lua에서 호출하는 Windows API, COM 호출을 하는 부분의 루아코드 앞뒤로 로깅을 추가해나갔다.4 로직은 Lua으로 스크립팅하는 방식이었기 때문이다.\n더 골때리는 것은, 정상적인 루아코드가 에러가 있다면서 실행을 거부하기도 했다는 점.\n그런데, 여기에서 재밌는 일이 일어났다. 루아코드를 변경할 때마다 조금씩 오류발생시점이 변했다.💣\n그리고 흥미로운 일도 관찰했다: 어느 지점에 어떻게 접근하고 있었는지 알기 위해서 루아코드에 주석을 달아가며 디버깅상황을 marking을 해나갈 때마다 안정화되어갔다. 🦾\n결국 관측(observe)하고 개입할수록 뭔가 문제의 양상이 변해갔다: 👉 Wikipedia: Heisenbug\n분석과 매듭짓기 분석은, 해당 사이트에 특이한 ‘보안솔루션’ 때문이었다고 결론 내렸다. 보안솔루션이 커널모드으로 동작하며, 다른 프로세스들을 감시하기 위해 동작하면서 이상하게도 메모리영역에 write을 했기 때문일 것 같다. 추측은 단순히 데이터버퍼(data segment)으로 인식하고 루아코드 영역에 어떤 패턴을 주입하고 이를 감시하거나 했을거 같다.\n그래서 루아코드를 키우거나 불필요한 주석영역을 늘여서 메모리에 영역을 더 할당 받고, 그 data영역의 앞뒤로 조금 corrupted되어도 무시될 수 있는 주석영역을 늘려줄 수록 안정화되었으리라.\n그렇게 해당 사이트의 다른 엔지니어에게 설명하고, 주석을 추가하고 늘리면서 안정하게 동작하는 상태로 만들고, 앞으로 변경이 있을 때에도 그렇게 heuristic하게 체크하며 진행하라고 당부하고 마무리지었다.\n돌아보며 그 이후에 그 이슈가 다시 내게 오는 일은 없었다. 다행이라고 생각한다. 그리고 그 납품처는 이름만 대면 그때나 지금이나 대한민국 산업의 가장 중요하다고 할만한 곳이어서, 지금은 당연히 그런 문제가 더 개선되었으리라 생각한다.\n실은 제목과 달리, 정확하게 컴파일러가 말하는 ‘memory padding’은 아닐 것이다. 컴파일러가 말하는 메모리패딩은 메모리정렬을 통해 특정 CPU/아키텍처가 빠르게 접근할 수 있도록 구조체의 각 필드를 메모리주소에 정렬/지정하는 방식이니까. …하지만 안정성을 위해, memory corruption을 대비해서 안전영역을 앞뒤로 더 붙여준다는 패딩의 의미로 사용했으니 이해 바란다.\n정석적인 상황이라면, 이런 문제가 발생한다면 offender측에 문제를 보고하고 해결을 바라는게 맞겠지만, 그러기 정말 어려운 상황이었다. 왜냐하면 그 보안솔루션은 그룹사 전체에 동일하게 적용하는 정책이었고, 그런 문제를 분석과 증거를 수집하여 전달한다 한들 그게 고쳐지는 시간도 물론이거니와 다른데에선 별 문제가 없는데 거기만 그러냐면 문제를 바로는 인정하지 않을 가능성도 높을테니까.\n결국 운이 좋았던 것 같다. ㅎㅎ짧게 말한다면.\n그리고 다른 이들은 이런 이야기의 대부분은 바로는 이해하거나 직관하기는 어려울 것 같다. 이슈의 문맥과 배경지식이 더 필요하리라 싶다.\nFootnotes 1 물론 나중에 조인한 사람들, 특히 스스로의 입지를 넓히거나 하고 싶던 사람들, 혹은 기존의 사람들도 마찬가지였던 사람들은 비평하기 바빴지만, 언제나 세상은 그런거 같다. “Talk is cheap”, 하지만 그렇다고 뭔가 발전시키거나 하지도 못하거나 그럴 생각도 없을 사람들이지만.\n2 원래 이런 그 자리에 앉으면 안될 분들은, 남들이 좋은 성과를 내고 성공시켜서 그 자리에 가도 그게 고마운줄 이해하지 못한다. 그리고 나아가서 이런식으로 스스로가 발 디딘 곳을 파내지 않고서는 못베기는 것 같다.\n3 그도 그럴 것이, 함수형 프로그래밍이나 고수준의 추상화 같은 무언가만 자기 일이라고 꿈꾸며 살다가, 막상 해야 하는 일은 기계나 어셈블리, 메모리, OS에 대한 조금 당사자에겐 낯선 것들을 겪어야 했을테니까. cmd.exe 열고 gdb 접속하고 하는게 그렇게 화려해 보이기도 어렵고 말이다.\n4 (기억이 가물가물하지만 아마도) OutputDebugString\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan18--01-ping/","title": "🔧 Ping 18/01/2026 .01",
     
     "tags": ["ping", "foo-fighters", "music"],
     
 "description": "Foo Fighters - Chasing Birds",
 "contents": " 새들은 금새 날아가 버려서 허망하기 쉬움에도.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/typescript-is-the-new-delphi/","title": "🦔 타입스크립트는 새로운 델파이이지 않을까",
     
     "tags": ["c#", "pascal", "turbo-pascal", "borland", "turbo-c", "dos", "windows", ".net", "visual-j++", "j++", "java", "visual-studio", "vscode", "typescript", "javascript", "delphi", "object-pascal", "microsoft", "the-rocky-horror-picture-show", "frankenstein", "java", "jvm", "hotspot", "bytecode", "jbuilder", "visual-studio", "visual-c++", "wsl", "yellow-box", "apple-rhapsody", "openstep", "nextstep", "webobjects", "uml", "ejb", "bgi", "tvision", "turbovision", "tui", "gui", "raylib", "allegro", "imgui", "debugger", "ide", "swift", "xcode", "interface-builder", "xib", "nib", "smalltalk", "webdev", "mvc", "music", "ost"],
     
 "description": "TypeScript, C#, Delphi, Turbo Pascal의 비밀",
 "contents": " 타입스크립트, C#, J++, 델파이, 터보파스칼… 이 프로그래밍언어들의 공통점, 모두 같은 사람이 설계했다는 점이다:\n👉 https://en.wikipedia.org/wiki/Anders_Hejlsberg\n이 포스팅에서는 이분과 관련된 추억놀음을 정리해 보려고 함. 결론이 있을 수 있겠고, 나 개인의 의견을 늘어놓지는 않아도 될 것 같다. 어차피 내 관점이 녹아 있을 수 밖에 없는 주관적으로 해석하고 나열하는 역사일테니까.\nDOS, 터보파스칼, 볼랜드의 시대 💾 터보파스칼 스크린샷들\n1990년대, 당시에 프로그래밍을 한다고 하면, 대부분은 GW-BASIC, QBASIC, QuickBasic이거나, 아니면 당시의 ‘볼랜드’社의 Turbo-C, Turbo-Pascal이 보통이지 않았을까 한다.\n베이직 계열은 접근하기 쉬웠지만 프로그램 코드길이제한이나 컴파일방식이 흔치 않은 단점이 있었다. 물론 퀵베이직, 파워베이직 같은 제품들은 진짜 네이티브코드로 컴파일을 해주고, 또 인라인 어셈블리를 지원해서 얼마든지 원하는걸 짤 수 있었겠지만.\n그럼에도 조금이라도 더 구조적프로그래밍을 하거나 시스템에 접근하고 싶다면 씨언어나 파스칼을 사용하는게 더 일반적이었을 것 같다.\n대중화된 IBM-PC호환 + MS-DOS 시스템을 위해, 꽤 괜찮은 프로그래밍언어에 컴파일러+링커, 그리고 Stepping debugger에 문서화까지 되어 있는 IDE/편집기가 모두 하나로 묶여 있는 터보씨, 터보파스칼 제품은 정말 쩔었던거 같다.\n솔직히 2026년 현재에 봐도, 소프트웨어 제품으로서 정말 완성도가 높았던거 같다. 단순하게 문법강조 같은 것들이 없다고 평가절하하기엔 디버거가 제공하는 기능이나 실행시간 디버거가 갖춰야 할 요소들, 실제 CPU의 레지스터들을 확인하거나, 현재 실행중인 instruction-pointer 부근의 디스어셈블리를 보여주거나 등등은 완성도가 높다. (현대적이라고 생각할 수 있는 프로그래밍언어들중에 Stepping debugger을 지원하지 못하는 경우도 많다.)\n언어, 개발환경, 라이브러리 함수 등에 대한 깔끔하고 읽기 좋고, ‘링크(Hyperlink)’이 걸려 있어서 따라가며 읽기 좋은 내장문서는 물론이고 함께 제공되던 BGI, Turbo Vision 같은 라이브러리는 완성도도 높고 사용하기도 좋은, 거기에 당장 내 애플리케이션을 만들 때에 필요한 UI, Graphics을 만들기 쉽게 해줬었다. 도스환경에서 그래픽을 직접 구현하거나 하는 것이 얼마나 까다로운지 안다면, 이게 얼마나 유리한지 알 수 있을 것 같다. 재미있게도, Turbo Vision의 후손격인 라이브러리나, BGI에 영향을 받은 그래픽 라이브러리나, 아예 그 방식으로 GUI을 구성하는 Immediate GUI 같은 패러다임도 2026년에 너무나 많다: Raylib, ImGui, TVision… 그리고 아이러니하게도 저런 라이브러리들이 훨씬 효과적이고 사용하기에도 직관적이다.\n당연히 이런 제품을 만들고 판매한 당시의 볼랜드는 독보적이었던 것 같다. 그래서였는지, 언제부터 그런 경향이 있었는지 모르겠지만, 마이크로소프트의 제품들도 어느새 비슷해지는 경향을 보였었다. DOS환경이라는 점을 감안해서, 제약이 많은 환경에서 프로그래밍언어/IDE이라는 동일한 영역의 제품이기 때문에 그렇게 되었을까.\nMicrosoft QuickBasic\n윈도95🪟와 Delphi 윈도95이 공개되고, GUI환경이 다 망해가던 애플의 매킨토시나 중형차 가격에 가까운 비싼 자체 하드웨어와 OS을 탑재한 워크스테이션이 아닌, 일반PC에서도 보편화되었다.\n윈도API을 직접 사용하는 GUI프로그래밍이 얼마나 별로인지를 역설할 생각은 없다. 어차피 당시의 기준으로 Xlib을 직접 사용한 GUI프로그래밍이나 MacOS Classic의 Carbon API도 끔찍하기는 마찬가지였을테니까. 다만 차이점은 그 저수준의 API들을 어떻게 추상화해주고 쓸만하게 만들어 주는 상위라이브러리였으리라 생각한다.\nNeXTSTEP/OPENSTEP의 경우에는 현재에도 OSX, iOS의 GUI와 기본API으로서 훌륭하게 생존+발전한 좋은 예 같다. 하지만, OPENSTEP도 AppKit이나 Foundation Kit이 동작하기 위해서, POSIX계층이나 libc, 혹은 “Display Server”와 직접 IPC하며 화면을 그리고 하는 정말 저수준의 조작을 아주 잘 추상화한 것을 함께 제공하는 경우라고 생각하는게 맞을 것 같다. OPENSTEP API, 혹은 현대의 Cocoa을 쓰더라도 직접 Display PostScript을 이해하거나 짤 필요가 없고, Quartz을 꼭 직접 쓰지 않아도 되는 이유겠다. …결국 윈도API와 OPENSTEP/Cocoa AppKit이 꼭 동일한 계층을 제공하는 API이라고 말할 수는 없다.\nAppKit와 비슷한 계층이라면, 유닉스계열이었다면 Xt, Motif, FL등이었을 것 같다. 그리고 동시대의 윈도 GUI은 마이크로소프트의 컴파일러를 사용한다면, MFC/WTL이었을 것 같고, 볼랜드였다면 VCL이 압도적이었었다.\nMS의 MFC은 “Visual C++ 6.0”을 기억하는 사람이라면 한 번 정도는 어떤 것인지 경험해봤으리라 생각한다. 그리고 지금 돌아보면 생각보다 정말 현실적이고 실용적인 접근이었던 것 같다. 당시의 C++ 컴파일러가 잘 최적화하기 어렵던 템플릿프로그래밍이나 RTTI 같은 것에 의존할 필요 없이, 단순하고 잘 동작하는 preprocessor macros 등으로 적당히 잘 동작하는, 그것도 꾸준히 계속해서 쓸만한 수준의 GUI프레임웍을 제공하긴 했었었다. 하지만 진입장벽이 꽤 높았었다. 그리고 GUI을 만드는데에 직관성도 많이 떨어졌었고.\nWTL은 앞서 언급한 템플릿 메타프로그래밍을 이용하여 Windows API을 포장하고 “쓸만하게” 만들려는 시도였었다. 가볍고 쓸만했지만, 당시엔 이건 더 이해하기에 난해했다. 지금에야 Rust등을 통해서 사람들이 제네릭타입, 메타프로그래밍에 더 익숙해졌지만 당시엔 더 ‘dark magic’이었으리라 싶다.\nMS제품군에 대한 추측은, 당시 MS이 조성한 생태계의 구조와 관계가 있지 않을까 싶다. Visual C++으로는 “컴포넌트”를 만들고, 이런 컴포넌트는 COM/DCOM으로 노출되고, 그걸 조금 쓰기 수월한 Visual Basic에서 가져와 사용하는 방식으로 유도하고 싶었으리라 싶다. …물론 별로 직관적이지도 않았었고, 그래서 이후에 .NET을 시작하는 계기가 되었으리라 싶다.\n반면, 볼랜드는 Delphi이라는 기존의 터보파스칼을 확장한 Object-Pascal 언어와 VCL-을 통해 컴포넌트 기반으로 GUI을 그리고 개발할 수 있는 직관적인 환경을 내놓았다. 그 이전에 OWL이라던가 하는 접근법이 있었지만, VCL으로 델파이와 볼랜드의 C++ 컴파일러/IDE였던 C++Builder은 완전히 차별화에 성공했다.\n단순히 GUI Control만이 VCL 컴포넌트인 것이 아니라, 현대에 우리가 기대하는 DataSource 연결이나 DataGrid와 같은 데이터베이스에 접근하고 하는 non-Visual, 혹은 더 “Enterprise”-환경에 필수적인 컴포넌트들도 제공을 했었다. (…예를 들면, HTTP Client도 VCL 컴포넌트으로 집어놓고 호출해 쓸 수 있다거나)\n실제로는, 특별한 프로그래밍언어의 지원이 없이, 그냥 함수포인터의 연결을 통한 이벤트 콜백함수의 등록 등과 같은 것과 IDE, GUI Builder의 연동이 훌륭했었었다.\n그리고 지금도 VCL 컴포넌트 시장이 존재하고, Delphi은 다른 회사에서 계속해서 개발하고 판매를 하는 중이다. (…물론 그렇게 인기가 많진 않다)\nVisual Basic 6와 함께 델파이는 지금도 과거의 유산으로 남아 있는 경우도 많지만, 여전히 데스크탑, 중소형 ERP/기업용 애플리케이션을 유지보수/개발하는데 유효한 환경일 것 같다. (물론 현대의 다른 언어와 비교하면 좀 구닥다리로 느껴지지만)\n하지만, 비주얼베이직과 함께 델파이는, DB에 접근하고 하는 클라이언트-서버 방식이나 단순한 DB+클라이언트 방식의 업무용애플리케이션을 만드는데 지금도 충분히 편리할 것 같다.\n델파이는 그때 당시에도 확고한 충성스런 팬들이 있었던 것 같다. 그런데 어째서 볼랜드는 사라지게 되었을까?1\nhttps://www.reddit.com/r/programming/comments/39rdb4/why_did_borland_fail/ https://www.quora.com/Why-did-Borland-fail/answer/Danny-Thorpe?share=1\u0026amp; …정리해보면:\n볼랜드에 충성스런 고객들은 자발적으로 구매를 했던 개인들이거나, 그런 개인들이 성장한 기업들이었다. 그리고 그 이유는 완성도가 높은 컴파일러와 개발환경 제품임에도 낮은 가격과 개인의 접근이 수월한 낮은 사양의 PC환경에서도 잘 동작하는 제품들이었다. (터보씨, 터보파스칼) 그리고 델파이/볼랜드의 강점은 VCL이었었는데, 그 다음에 “Enterprise” 제품군을 위해 제품타겟팅을 바꾸면서 충성고객층의 이탈이 일어났고, 반면 유입을 기대한 기업고객은 그렇게 많지 못했다. (…더 많은 지불능력이 있는 기업일수록 MS제품을 더 선호할 수 밖에 없었을테니까) 그리고 그런 ‘선회’의 과정에서 지금으로선 짐작만 가능한 변화와 거기에서 회의를 느낀, 당시의 성공적인 볼랜드를 만들어낸 유능한 개발자들이 떠나가게 된다: 특히 Anders Hejlsberg-옹 같은 분들. 이런 흥망성쇠 이야기는 의외로 IT기업들에서 흔하지 않을까 한다. 황금알을 낳는 거위의 배를 가르려고 들거나, 기만만 일삼아서 하멜른의 피리부는 사나이의 이야기의 배경이 되어 버리거나 하는 기업은 흔하다.\n이런류의 몰락은, 각 단계가 점진적으로 이뤄지는 것 같다. 단번에 무너져 버리는 경우는 오히려 드라마틱해 보이기는 할 것 같지만 흔치 않다. 조금씩 하나씩 하나씩 더 안 좋은 방향으로 위에 인용한 글에서 사용한 표현과 같이 나선을 그리며 하강하게 된다. 그리고 각 하강의 단계에서 되돌리기는 매우 어렵다.\n어려운 이유는 그게 하강의 단계인지 인지하지 못하거나, 아니면 아예 착각에 의해서 그런 의사결정을 경영진이 스스로 내리기 때문이다. 그런 경우라면 더더욱 스스로 인지부조화를 강화하며 인정하기 어렵다. 당사자 개인 감정의 문제도 있고, 그 위치에서 결정과 판단을 내리는 스스로의 권력이나 그 유지에 위협이 되기 때문일 것이다. 설령 그게 잘못되었다고 하더라도, 그걸 적당히 포장해서 성공이고 실적인 것처럼 만들려고 하는게 대다수의, 그리고 그런 하강을 어쩔 수 없이 빠져나오지 못할 이들일 것이다. …이러한 자아에 사로잡힌, 근시안적인 실적주의가 일으키는 패턴은, 스스로 되돌이키지 못할, 이 하강의 매 단계에 동일하게 반복되어 간다.\n… 나머지는 우리가 아는대로다(좀 더 정확하게 말하자면, 아무도 알지 못하게 사라져간 볼랜드…가 더 알맞겠지만), 현재의 델파이-는 여전히 팔리고 있지만 굳이 진입하려고 하지 않을 것 같다.\n그리고 Hejlsberg옹의 그 이후의 작품들인 .NET/C#, TypeScript은 세상에 너무나 주류가 되어 버렸다.\nJava the “HotSpot”☕와 ‘The Rocky Horror Picture Show’🫦 당시의 Hype였던 객체지향/OOP을 더 맛보고 싶은 사람들은, 거기에 한참 대중화되어 가던 인터넷/웹을 위한 프로그래밍언어라고 마케팅하던, 자바에 나와 사람들은 열광했다.2\n어느 정도는 사실이었던게, 실제로 자바는 지금도 윈도든 맥이든 리눅스든 잘 동작한다. 서버나 데스크탑이 아니어도, 웹브라우저에서도 지금이야 HTML5 등이 보편적이지만, 동적인 웹페이지를 만들기가 어려웠었기 때문에, 자바 애플릿 같은 것에 끌릴 수 밖엔 없었었다.\n당시의 보수적인 사람들은, 자바는 메모리사용량이 너무 많고, VM이 인터프리터 방식이어서 느리고 무겁다며 절대 대중화되지 못할거라고 장담했었었다. 하지만, 지금에 와서 돌아보면, 하드웨어는 그보다 빨리 고사양화되었고, VM은 HotSpot기술이나 정밀한 JVM의 Garbage collector등을 탑재하고, (잘 쓰면) 꽤 빠른 언어에 속하게 되었다.\n물론, 어느샌가 시간은 흘러서, 자바사용자가 보수층이 되고, 그 이후에 유행하는 다른 다이나믹언어들을 보면서 또 똑같은 비평을 하는 광경까지 벌어졌었다. 하지만 그건 한참 이후에의 일이다.\n자바언어와 그 바이트코드의 Specifications이 표준화가 잘 되어 있고, 구현자가 달라도 거의 걱정을 할 필요가 없는 언어와 VM이다. 하지만, 당시에 자바의 이런 ‘표준성’을 무시하는, 혹은 무시하고 스스로가 시장에서 독점적인 위치를 차지하고 원래의 표준/자바를 대체하려고 하던 시도들이 조금씩 일어났었었다. …물론 시도뿐이고 크게 성공한 경우는 없다. 다행인지, 불행인지, 덕분에 자바는 아직도 어느 플랫폼에서나 비슷한 모양새로 적당히, 모든 플랫폼의 하한선에 맞춰진 GUI을 자랑하며 잘 동작한다.🙃\n아직도 약간 그런 경향이 남아 있지만, Java “EJB”서버시장이나, 당시에 유행하던 객체지향에 편승한 UML설계도구 + 자바IDE 시장은 각 기업별로 조금씩 특성이 달랐다. 하지만, 그럼에도 자바표준을 잘 준수하고 그 안에서 동작하려고 노력은 해온 것 같다. 그리고 2000년대 초에는 자바표준을 지켜온 모범적인 예와 그와 정반대인 괴이한 변종들이 나타났었었다.\n모범생🪿: Borland “JBuilder” 볼랜드도 이러한 자바 IDE을 내놓았었는데, 다른 C++ 제품과 같이 “Borland JBuilder”였었었다.\n그리고 C++ Builder, Delphi 제품과 유사한 GUI에 Java 특유의 AWT/Swing GUI을 직관적으로 제작할 수 있었었다.\nBorland JBuilder: 클래스 이름 등에서 Java 표준 Swing임을 알 수 있다\n이후에 유행하는 Eclipse JDT, IDEA IntelliJ와는 조금 다른 모양새의 Java IDE으로 보이는데, 이는 전자들은 서버쪽에 자바를 응용하는 것에 집중하여 더 코드 자체에 집중하는 모습인데 비해, 이 시대의 자바 개발은 Java Swing, Applet 등 GUI에 더 주목하고 있기 때문일 것 같다.\nApple맛🍏 Java: Rhapsody, Yellow Box, WebObjects 그리고 흥미롭게도, 다 망해가던 애플은, 이 시점에 스스로 잘못 뽑은 경영진에 의해 배신 당했었던 스티브 잡스와 그의 회사 NeXT을 다시 불러들이고 인수한다.\n새로운 OS, HW을 시작하려 준비를 하던 시기였다.\n애플의 “MacOS Classic”은 이미 가상메모리 시스템, 멀티태스킹 등 안정성에 관한 한계에 다다른지 오래였었다. 그리고 그에 대한 대안으로 Be, Inc.의 BeOS 등이 NeXT와 경쟁을 했었었다. BeOS와 현재의 HaikuOS, NeXT와 GNUstep, 그리고 현재의 OSX에 대한 이야기는 흥미로운 역사와 그 결과인데, 언젠가 다른 포스팅에서 해볼까 한다.\n👉 https://en.wikipedia.org/wiki/NeXT#1997%E2%80%932006:_Acquisition_by_Apple\n그리고 바로 이 시대에, 애플은 NeXTSTEP을 새로운 MacOS의 기반으로 선택하며 “Rhapsody”이란 실험적인 시도를 한다:\nMacOS Classic, NeXTSTEP, Rhapsody 스크린샷 Rhapsody은 스크린샷만 봐도, 애플의 MacOS스러움을 사실은 NeXTSTEP에 더한 느낌이다. 그리고 이게 현재의 MacOS X, 그리고 iOS의 전신이다.\n이때에 “하위호환”을 위해, 과거의 MacOS Classic 애플리케이션을 실행하기 위한 가상화레이어가 내장되어 있었는데, 이를 “Blue Box”이라고 하고, 새로운 NeXTSTEP 계층을 “Yellow Box”이라고 불렀다고 한다.\nNeXTSTEP/OPENSTEP은 이미 NeXT OS이 아닌, Sun社의 Solaris이나, 심지어 Microsoft Windows NT에도 이식되어 실행되었었기 때문에, Blue Box에 비해 이식은 수월했으리라 싶다.\n그리고 이때에 애플은 차세대 OS의 프로그래밍언어로서, 전통적인 NeXTSTEP/OPENSTEP에서 사용하던 Objective-C만이 아니라, 당시 트렌드키워드였던 Java 또한 사용해서 애플리케이션을 만들 수 있다고 말하기 시작했다.\n하지만 그다지 호응은 없었었다. 다행인거 같다. 어쩌면 당시 OPENSTEP의 부진이, 너무 다른 프로그래밍언어였던 Objective-C에 있다고 스스로 위축되어 있어서 이런 결정을 하지 않았을까 추측해본다.\n실제로 Objective-C은 RTTI와 Message-passing 같은 C++이나 자바에 비해서도 훨씬 동적이고, 오히려 스몰톡이나 Ruby 같은 다이나믹언어에 가깝다. 그런 이유 때문에 Visual C++와 같은 다른 프로그래밍언어 IDE에 비해서 자동완성이 당시 기준으로는 구현하기 어려웠었었다.\n..어떤 변수가 구체화된 클래스의 인스턴스를 타입으로 갖는 것이 아니라, 단순히 모든 객체를 나타내는 NSObject*-이나 더 극적으로 단순히 id-타입일 수 있는데, 그럼에도 원래 클래스의 인스턴스메서드를 ‘호출’해도 실행시간 message-passing이기 때문에 정상적으로 동작한다. 그런데 바로 이런 현재의 다이나믹언어와 같은 특성 때문에, IDE의 관점에서는 어떤 메서드를 호출할 수 있는 변수인지 추론하기 난해하다.\n이 문제는 현대에 Xcode에 들어서, LLVM팀이 유입되고, 정적분석이 수월해지면서 비약적으로 개선된다. 또, 이 LLVM의 Chris Lattner을 통해서 이후에 현재 애플의 프로그래밍언어인 Swift이 설계되고 개발된다.\nKHTML와 WebKit의 관계처럼, LLVM이란 오픈소스와 Xcode/Swift의 관계도 흥미롭다. 또한 LLVM JIT을 통해 현재의 JIT이 보편화된 시대의 이야기도 가능할 것 같다. 이런 이야기는 가능하면 다른 포스팅에서 더 이야기해보고 싶다.\n결국, 자바 언급은 Objective-C만으로는, 사람들의 관심을 끌기 어려울 것 같다는 자신감 부족 때문이 아니었을까 싶다.\n그렇지만, 이런 Apple + Java의 결합이 더 흥미로웠던 분야가 있었는데, 잘 알려지지 않은 애플의 제품중 하나였던 WebObjects-와의 결합이 그러했다.\n웹오브젝츠는 애플의 이전, 넥스트社일 때 공개된 제품이었었다. 어쨌든 훌륭한 개발환경이었던 OPENSTEP의 개발도구와 API을 활용하여 웹개발을 할 수 있는 제품이었었다.\n이미 2000년대 초에 ‘컴포넌트 기반’으로 웹개발을 할 수 있었었다. 그리고 흥미롭게도 아직도 그 영향을 받은 클론이나 웹프레임웍이 오픈소스로 공개되어 있다.\n웹오브젝츠와 함께라면 자바의 결합이 더 유효해 보이기는 한다. 하지만 웹오브젝츠 자체가 성공적이지는 못했었다. 그리고 그 덕분에 애플과 자바의 결합은 어느 측면으로도 성공적이지는 못했던 것 같다.\n🙂‍↔️ Microsoft의 Visual J++ 애플의 자바 융합시도와 마찬가지로, 비슷한 시대에 마이크로소프트 또한 자바를 융합하려는 시도를 했었다.\n그리고 심지어 Visual Studio 제품군의 일부로 포함되어 있었었다: 👉 Visual J++\n프로그래밍언어적으로는 자바이지만, 함께 포함된 API에는 당연히 MS제품이니 그렇긴 하지만, 자바에 익숙한 사람이라면 당혹스러운 느낌의 예제들이 있다. (위 Wikipedia 링크 참고)\n예를 들면, 직접 MS Windows API을 호출할 수 있다거나, 윈도애플리케이션 GUI을 구성하고, COM/ActiveX 컴포넌트를 호출할 수 있다거나…하는 ‘확장’들이 포함되어 있었었다.\nJ++은 이후 Sun社가 주도한 소송에 패배하여 더이상 계속되지 못했었다: Java스펙을 충족하지 못하는 제품이었기 때문이었기 라고 한다. 흥미롭게도.\n그런데, 단순히 이 키메라가 그런 점들을 가졌었고 사라졌다는 것보다 다음 사실들을 주목해야 한다고 생각한다:\nWindows API 사용 가능, COM/ActiveX 연동 가능, Windows GUI을 고수준에서 제작이 가능. Java에는 없는 ‘delegates’, ‘callbacks’ 같은 J++만의 언어적 확장. 그리고 설계자가 Hejlsberg옹. …위의 3가지 모두, 이후 마이크로소프트의 .NET/C#에 빼다 박은 듯이 그대로 나타나는 특징이다.\n.NET / C# 위에 설명한대로, 마이크로소프트는 자바를 사실상 흡수하여, 그 VM와 언어 자체를 마이크로소프트스럽게 만들고 확장한 .NET와 C#을 공개한다.\n그리고 그 이후에 Visual Studio 제품군은 Native 코드를 위한 Visual C++을 제외하고는 모두 .NET 기반이 계속된다. 그리고 심지어 C++ 또한 “Managed C++”으로 사실상 .NET을 위한 언어도 항상 함께 공개되어 왔다.\n그리고 시장의 전체를 장악하지는 못했지만, 자바와 그 밖에 다른 오픈소스들의 영향, 리눅스 서버의 영향 등등으로 인해서, 그래도 꾸준하고 안정적인 시장을 다져온 것 같다.\n웹개발의 측면 이외에, 윈도 데스크탑 애플리케이션을 만드는 분야는 분명히 기존 델파이를 써서 만들던 것만큼 쉽거나, 혹은 더 현대적으로 닷넷/C# 기반으로 많은 중소기업들이 이행했으리라 추측할 수 있다.\nC#은 현재에도 계속해서 확장되고, 다른 어떤 오픈소스 언어보다 빠르게 새로운 프로그래밍언어 이론의 연구 등을 반영해주는 상업적인 언어라고 생각한다.\n하지만, 몇 기가바이트나 하는 .NET 프레임웍을 함께 배포해야 하거나 하는 것 등은 가끔 아득해지게 만드는 요인이긴 하다.\n그리고 물론 Hejlsberg옹의 작품목록에는 C#이 포함된다.\nMS와 오픈소스, VSCode, TypeScript, WSL 현대의 MS은 오픈소스에 매우 친화적이려고 노력하는 기업이 되었다. 예전의 ‘M$’이라며 오픈소스, 리눅스 지지자들이 혐오하던 MS와는 많이 달라진 모습이다.\n심지어, MS제품에만 안목이 제한된 사람들은 눈치채지 힘들지만, 윈도에서 리눅스를 실행할 수 있는 환경인 WSL을 만들고 제공하기도 한다.\n그리고 2026년 가장 트렌디한 프로그래밍언어 중 하나인 타입스크립트 또한 MS와 Hejlsberg옹의 작품이다. 흥미롭게도.\n닷넷이 그 ‘프레임웍’을 함께 배포해야 했듯이, 타입스크립트로 만든 데스크톱 애플리케이션이 크롬을 내장한 Electron이 거의 그 정도 크기로 배포되어야 하는 것도 우습지만 흥미로운 점인 것 같다.\n델파이나 터보파스칼은 구닥다리이고, 요즘 누구나 다 쓴다는 타입스크립트를 해야 하고, 시장에서 개발자를 구하려면 어쩌고 하는 정도인 수준의 이야기는 나 스스로가 부끄러울 수준의 이야기일 것 같다. 오히려 어떤 영향을 어떻게 주고 받았을지, 어떤 흐름에서 어떻게 발전, 파생되었는지를 이해할 수 있는 편이 더 나을 것 같다.\n타입스크립트나 델파이, 혹은 씨샵의 공통점에 대해서는 언급할 필요가 없을 것 같다. 반면에, 이 포스팅에서는 드러나지 않은 역할자들을 조명해봤다. 오히려 닷넷이 있을 수 있도록 해준 공로는 자바에 더 크게 있다고 생각한다. 그리고 오히려 타입스크립트가 존재할 수 있던 이유에는 역설적으로 델파이에, 그리고 처음 프로그래밍을 접근할 수 있는 것으로 제공하던 터보파스칼에서부터 시작되지 않았을까 상상해볼 수 있다.\nFootnotes 1 실은 나도 이 글을 쓰면서 다시 조사해보고 인터넷의 글들을 읽고 당시의 상황을 다시 이해하게 되었다.\n2 객체지향을 C++으로…하려고 하던 시대였으니까. C++을 좋아하지만, 스몰톡같은 객체지향을 하기 보다는 Generic Programming을 하는게 훨씬 이득인 언어인데.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/perl-pagi/","title": "🧃 PAGI (Perl port of Python&#39;s ASGI) 그리고 Perl에 대한 생각",
     
     "tags": ["perl", "webdev", "asgi", "python", "async", "psgi", "plack", "http", "httpd", "websocket", "sse", "future", "template-toolkit", "rakulang", "dbm", "web-hosting", "cgilib", "CGI.pm", "apache", "mysql", "lisp", "clos", "mop", "smalltalk", "oop", "ruby", "cgi", "perl6", "moose", "moo", "mouse", "mojolicious", "websocket", "sse", "future", "promise", "anyevent", "poe"],
     
 "description": "(드디어) Perl에도 Async 웹개발 기반이 생겼다, 하지만 그럼에도 나는 시큰둥한 느낌이다",
 "contents": " CGI의 시대, 그리고 이내 “Classic” ASP, PHP 4의 시대 Perl1은 이제 많이 사용하는 사람들도 없고, 유입되는 사람들도 거의 없는 것 같다. 나도 2000년대 전에 펄을 접했었지만, 그때에 나에겐 너무 복잡하고 이해하기 어려운 프로그래밍언어였었다. 차라리 당시의 파이썬 1.5이나 Ruby 1.x, PHP 4 정도가 더 상식적으로 이해할 수 있는 언어였었다. 이미 Smalltalk, LISP을 이해하고 있었어서, 파이썬, 루비의 객체시스템이나 실행시간 Reflection, Meta-Programming 같은 주제들이 더 납득하기 좋았다.\n2000년대 전후의 웹개발은 ANSI C을 이용한 CGI프로그래밍을 하거나, 아니면 펄을 사용해야 했었던거 같다. 대부분의 ‘웹호스팅’계정들은 보통 MySQL을 제공하지 않거나 비싸서, cgi-bin의 스크립트가 직접 로컬파일에 데이터를 저장하거나, dbm파일을 db처럼 사용해야만 했었었다.2 그리고 CGI스크립팅 자체가 결국 문자열 파싱과 조립이니 펄의 CGI.pm 같은 모듈 지원은 인기가 좋을 수 밖엔 없었다.\n다만, 내가 CGI개발을 시작하던때는 이미 파이썬을 알고 있었고, 파이썬 1.5의 import cgi-이 펄의 use CGI;-보다 더 나는 좋았었다.\n물론, 2000년대 전후에 파이썬이나 루비에 관심을 갖는 것은 한국에선 그다지 인기 있는 일은 아니었다. 오히려 웹개발을 한다고 하면 CGI/C/Perl이거나 MS IIS을 위한 Classic ASP, 혹은 APM으로 불리는 Apache + PHP4 + MySQL이 더 대세였었다. 3\n그리고 나는 그때 PHP4, Python 1.5 + cgi모듈을 사용하던 때에, 멍청하게 print-문으로 HTML와 JS코드를 출력해대며 웹개발을 하던 때에, 나는 개인적으로는 정말 즐겁게 내딴에는 창의적으로 뭔가를 만들어 댔었었다. 🧓\n루비나 파이썬에 이미 익숙해진 다음에, 나중에(2000년대~2010년대?) 취미정도로 조금 더 진지하게 익혀가던 시점에, 이미 어떤 커뮤니티의 몇몇 분들은 너무나 특정언어에 경도되어, 뉴비가 유입되기엔 이미 별로였던거 같다. 이 포스팅에서도 계속 이야기해 나가겠고, 지금에 생각해보면 어느 누구에게도 유익할 것 없는 관점이지만 말이다.\n―이미 당시에도 펄은 유입이 거의 없었던거 같다. 한국이나 외국이나 어느 커뮤니티에서도 펄은 그저 농담거리 이상은 아니게 되었던거 같다.4\n(\u0026hellip;물론 나도 펄을 좋아하지만ㅎㅎ)\n질투, 흉내: CommonLISP, Smalltalk, Ruby 그리고 Moose와 Perl 6 파이썬, 루비가 더 인기를 끌게 된 이후, 펄은 새로운 Perl 6에 대한 계획을 발표한다. 거창한 계획이었지만 몇 년간 레퍼런스구현체도 없었고 너무 방대해 보이는 범위의 기능들을 포함한 문서만 계속 개정되어 갔었다. 5\nAudrey Tang의 Pugs-이 나오고 그 이후에 Raku으로 발전해나갔다. 하지만 내 생각엔 이미 너무 시간이 흘러버린 다음에야 진행된것 아닐까 싶다.\n펄5 커뮤니티는 Moose 이후 큰 변화가 있었긴 했다. 그리고 계속해서 Moose와 호환되는, 하지만 더 가벼운 Moo, Mouse 등등의 OO-라이브러리들이 계속해서 나왔고, 아직도 나오고 있는 것 같다. 🤐\n심지어 최근 버전의 펄은 자체적으로 드디어 class-키워드를 통해 OO을 하는 방식을 제공하기 시작했다: https://perldoc.perl.org/perlclass …그나마도 perldoc에 나타나지 않은, static-method/field 등을 만들려면 여전히 https://perldoc.perl.org/perlootut 의 펄의 전통적인 package + bless을 통한 Perl-OO의 내용을 알고 있어야 좀 쓸만해지지만.\nMoose은 CommonLISP의 CLOS, MOP 같은 강력함, 유연함을 제공하려는 노력인 것 같다.6 …실은 현실에서 바로 사용하지 못할거 같은 펄6, 혹은 더 나아가서 펄6이 의식하지 않았나 싶은 루비의 객체지향과 실행시간 메타프로그래밍 같은 것들을 지원하려 노력한 것 같다.\n하지만 여전히 펄답게, 펄을 좀 이해하고 나서야, 그것도 다른 파이썬이나 루비에 비해 더 많은 이해가 수반된 다음에야 재밌게 여길 수 있을테니… 글쎄다 싶다. 루비는 펄 사용자들을, 혹은 펄의 변절자들을 성공적으로 수용하지 않았나 싶다. 물론, 여전히 펄에도 유입이 있었을테고 계속해서 펄을 사용해온 사람들도 많이 있겠지만.\n거기에 Raku은 나온지 꽤 되었고, 루비나 커먼리습스러운 문법구성요소7-을 지원하지만, 생태계의 대부분은 여전히 Beta인 것 같다: https://cro.raku.org/\n…그냥 2026년 오늘에 와서도 펄+Moose, 혹은 “Perl6”을 쓸 바엔, 커먼리습이나 루비를 쓰는게 맞지 않을까 싶은 느낌이다.\nC10k, C100k, Erlang? 그런데 갑자기 Node.js, Go 한 때는, C10k problem, 지금에 와서는 C100k problem 같은게 논의되었었다. 그런 논의의 구현으로서, 그때의 인기였던 WhatsApp와 함께 Erlang이 주목 받기도 했었었다. 그리고 당시의 메인스트림이었던 MPM Prefork 방식의 Apache httpd2 등은 이제는 완전히 밀려나고, 이벤트 I/O 방식의 nginx이 남게 되었다.\n당시 메인스트림 언어였던 Java 또한 NIO이나 Netty 같은 것들이 각광 받게 되었었다. 하지만 사람들은 자바나 얼랭보다 더 단순하고 가벼운 스택을 선호했다: Node.js, Go.\n당연하지 않나 싶은 것이, FP언어라고 주장하던 Erlang 언어는 너무 당시의 메인스트림 언어와 달라서 이해하기 어려웠고8, OTP 같은 “훌륭한” 프레임웍이 함께 제공되었지만, 역시 너무 거리가 멀어보였고 너무 부담스러웠다.\n그리고 자바의 NIO, Netty 역시, 자바와 Servlet, 혹은 스프링프레임웍도 부담스럽게 여기는게 대부분인데, 거기에 또 다른 공부하고 익혀야 할 무언가일 뿐이어서 부담스러웠던 것 같다. 물론 자바가 더 성숙했었을 때였으니 Node.js, Go보다 Netty 적용을 한 경우도 많을 것 같다.\n그리고 지금은 파이썬도 async/await, asyncio 등을 잘 지원하고 대부분의 언어들이 고려가 되어 있다.9\nPerl의 비동기I/O: AnyEvent, POE, Async, Promise, ….그리고 또? Perl 5은 여전히 비동기입출력도 Moose와 OO라이브러리와 비슷한 상황이다. 펄에 우호적으로 표현한다면, 객체지향도 그렇고 이런 비동기입출력도 언어자체가 유연하니 얼마든지 확장할 수 있고, 펄 + CPAN 생태계 특유의 “건강한 무정부주의”라고 말할 수도 있을거다.\n하지만 객체지향과 마찬가지로, 새로 유입된 사람이 사용하기엔 골치가 아프다. 단순히 어렵거나 한 문제가 아니라 어떤 라이브러리가 더 나은지, 어떤 라이브러리에 시간과 노력을 투자를 해야 맞을지 알기 어렵다.\nPOE, AnyEvent, Async, IO::Async 등등… 나도 이젠 모르겠다.\nPlack, PSGI의 한계: WebSocket, SSE 기존 Perl 웹프레임웍, 웹서버들은 PSGI 스펙-에 기반.\n그런데, 막상 이걸 쓰면 좋긴한데, 웹소켓만 구현을 하려고 해도 제약이 생긴다: https://metacpan.org/pod/Plack::App::WebSocket#Prerequisites\n…문제는 저런걸 지원하는 웹서버구현체도 적고, Mojolicious 같은 웹프레임웍이 자체 웹서버 구현과 함께 웹소켓 등도 잘 지원하기는 한다.\n…하지만 Mojolicious을 제외하고는, 제대로 지원하는 조합을 펄에선 찾기 너무 어려웠다.\nPython의 ASGI, 이제는 펄도 PAGI 최근에 들어서 펄도 파이썬의 WSGI =\u0026gt; ASGI 확장처럼, PSGI 스펙을 확장하여 비동기방식을 지원하기 시작했다:\nhttps://github.com/jjn1056/pagi/ https://metacpan.org/dist/PAGI https://www.reddit.com/r/perl/comments/1puc5uv/perl_pagi_tutorial_early_access/ https://www.reddit.com/r/perl/comments/1q3xaeg/the_first_pagi_compliant_web_framework_on_cpan/ 흥미롭기는 하지만 아예 차라리 비동기이 아니더라도, 2026년 현시점에도 PHP이나 Ruby이 더 매력적으로 느껴지는 이유는 뭘까 싶다.\nFootnotes 1 이 포스팅에서 말하는 Perl은 ‘Perl 5’.\n2 MySQL 계정을 제공하지 않는 웹호스팅, 로컬 DBM파일만을 이용해야 하는 제약이 있던 시대는 정말 너무 오래된 이야기라서 검색을 해도 찾기가 어려울 정도가 되었다.\n3 특정 시대마다 그런 ‘테크스택’들이 있는 것 같다: CGI, Perl, ASP, PHP, Java/JSP/Spring, 혹은 Node.js, React.js, Prometheus, K8s, MSA, Saga-pattern, Tailwind, LLM 등등. 그런데 지금의 구인/구직란을 찾아보면 흔적도 남지 않은 경우도 많은거 같다. 현시대의 키워드들도 그럴 수 있지 않을까 싶다. …그리고 그런 관점에서 보면 과연 저런 키워드매칭을 통해 개발자를 찾는 것이 유의미한 결과를 낼까에 대한 고민도 든다. …여러 가지 이야기를 할 수 있겠지만, 이 포스팅보다 더 많은 이야기가 가능할 것 같다. 이 포스팅에서는 하지 않고 나중에 기회가 되면 그때 적어보겠다.\n4 내 dotfiles-이나 GitHub에 공개된 프로젝트-에 Perl으로 된 프로젝트들도 좀 있다. 쉘스크립팅만으로 복잡해지는거 같다면 나또한 펄을 애용한다. 내 블로그의 ‘perl’-태그갯수만 봐도, 내가 그냥 펄을 싫어만 하는 사람은 아닐 것 같다.\n5 https://www.perl.com/pub/2003/03/07/apocalypse6.html/\n6 언급한 ‘리습 같은걸로는 프로그램을 만들 수 없다’-던 어느 펄사용자의 말씀이 떠올라서 재밌다.\n7 예를 들면, ‘kebab-case’을 여기저기 사용한다거나, ‘keyword’-을 지원하는데 :foobar 같은 커먼리습/루비에서 익숙한 방식이거나 등등.\n8 실제로는 Prolog언어를 기반으로 했기 때문에 FP보다 더 사람들에게, 지금도 낯선 Logic Programming이니까.\n9 예외가 있다면, PHP, Ruby 정도인거 같다. 둘 다 아직은 라이브러리를 통해서만 지원하는거 같다. Fiber/Coroutine을 통해 언어적으로 흡수하려 하거나, 꽤 괜찮은 OpenSwoole, Concurrent Ruby 등의 라이브러리를 통해 지원한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2026-01jan/2026-01jan06--01-ping/","title": "🐦‍🔥 2026년 시작",
     
     "tags": ["ping", "webdev", "blogging", "css"],
     
 "description": "새로운 해 2026년🐎, 블로깅도 계속",
 "contents": " 연말동안 내려놓았던 블로그를 다시 열었다. 디자인을 좀 바꿔볼까 하다가 일단은 ㅎㅎ내버려두려고.\n영화, 책, 게임이나 프로그래밍 같은 그간의 취미들도 계속해서 올려볼까 함.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/go-away-python/","title": "🎍 “Go away, Python!” / Go으로 스크립트짜기",
     
     "tags": ["programming", "golang", "python", "scripting", "script", "sh", "shebang", "book", "books", "reading"],
     
 "description": "",
 "contents": " 💠 (원본글) Go away, Python!\nshebang으로 go언어으로 스크립트 짜기 1 2 3 4 5 6 7 8 //usr/bin/env go run \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34;; exit package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello world\u0026#34;) } …원본글은 //usr/local/go/bin/go run \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34;; exit-였지만 좀 바꿔봤다. 그리고 바꾼쪽이 나는 더 마음에 든다.\nshebang은 아니지만, shebang처럼 동작 https://en.wikipedia.org/wiki/Shebang_(Unix)\n…~sh~-이 //...-부분을 shebang처럼 처리하게 된다는데 재밌다. ㅎㅎ (‘원본글’에서 자세히 설명)\n그리고 이런 라이브러리도 이미 있어왔지: bitfield/script https://github.com/bitfield/script\n유닉스 쉘의 pipe, redirection은 물론이고 기본적인 유틸들까지 구현해놓았네. ㅎㅎ\n📕 The Power of Go: Tools 책은 나중에 읽어봐야겠다.\n나름 괜찮은 아이디어 처음 실행할때 컴파일이 살짝 돌아가서 느려 보이는걸 제외하고(그 이후엔 컴파일한 코드로 실행하니 느끼지 못하지만), 오히려 다른 스크립팅언어들보다 이게 더 나은거 아닌가 생각.\n솔직히 다른 언어들이라고 그렇게 안전하다거나 편리한지 이젠 잘 모르겠다. 오히려 다른 언어들이 타입시스템이니 멀티코어니 각자의 방식으로 애쓰는데, 오히려 Go언어는 이미 그런지 오래되지 않았나 싶다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec28--01-ping/","title": "🥴 youtube 가볍게 보기/듣기",
     
     "tags": ["ping", "youtube", "playlist", "music", "terminal", "gtk", "perl", "script", "tool", "linux", "unix", "mpv", "mplayer", "yewtube", "pipe-viewer"],
     
 "description": "",
 "contents": " 터미널 버전 스크린샷\n터미널에서 유튜브를 보거나, 음악을 틀어 놓는 용도로 원래는 mps-youtube/yewtube을 쓰다가 옮겼는데, trizen/pipe-viewer 써봤는데 나름대로 만족스러운거 같다.\nyewtube은 검색하고 그때 그때 “no-video”으로 실행하기 커맨드가 있어서 편했는데, pipe-viewer은 아예 처음에 실행할 때에 다음과 같이 같이 실행해야 해서 좀 다르지만. 그래도 마음에 든다.\n1 pipe-viewer --no-video 일단 광고로 휩쓸리지 않아서 좋고, 그다음엔 내 취향을 노출하면서 데이터를 제공할 필요가 없음. (대신 추천이 없지만 ㅎㅎ)\n그리고 오디오만 필요하니까, 비디오 실행한다고 괜히 무겁게, 전력소모 더 하고 팬소리 더 시끄럽게 돌리지 않아도 되니까 마음에 든다.1\nFootnotes 1 낮은 사양의 구닥다리 컴퓨터에서 편안하게 라디오 듣듯이 쓰고 있어서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec27--01-ping/","title": "⛹️ Rob “Commander” Pike의 AI극딜",
     
     "tags": ["ping", "ai", "gpt", "llm", "openai", "chatgpt", "consumerism", "late-capitalism", "startup", "rob-pike", "commander", "google", "golang", "gopher", "book", "books", "reading"],
     
 "description": "",
 "contents": " “제가 마지막으로 이렇게 화가 난게 언제인지도 모르겠습니다” HN 댓글: https://news.ycombinator.com/item?id=46392115 lobste.rs 댓글: https://lobste.rs/s/n4kxdf/rob_pike_goes_nuclear_over_genai AI스팸봇에 메일을 받고, 또 자기가 세상에 기여한 것들에 대해서 칭찬하는 “스팸”을 받고 화낼만 하신거 같다.\nRob “Commander” Pike은 우리가 아는 Golang의 설계자/‘개발자’, UTF-8 인코딩의 발명자1, Plan 9-의 개발 등으로 유명한 분.\n저분이 계셨었던 구글 또한 그런 반대하신다는 경향에 일조하고 있지 않느냐는 지적은 하고 싶지 않다. 오히려 저런 생각을 진심으로 갖고 계시다면, 그래도 구글이 그런 방향으로만 흘러가지는 않도록, 겉모습만이라도 조금은 더 낫도록, 흔히 말해지는 그래도 위선이라도 노력하게 만드는데에 일조하셨길 기대할뿐이다.\n심지어 위선일지라도 그것도 제대로 못해내거나, 우습게 여기는 사람이나 조직에 비하면 훨씬 낫다고 생각하기 때문이다. 그 차이를 이해하고 경험해본 사람은 그게 얼마나 희귀하고 고귀한지 조금은 알기 때문이다.\n그런 사람들은, 조금이라도 흠잡을게 보이거나 하면 허위라고, 위선이라고 깊이 볼 필요도 없다는 듯이 편리하게 말하고만 싶어한다. 그래서 그런 이들의 말과 주장은, 그가 비난하는 바나 대상을 조금이라도 이해하고 생각해보면 그에 대해 전혀 이해하지 못하고 있고, 또 내용을 알려고 시도조차 않았다는걸 금방 눈치챌 수 있다.\n그런데, 이런 이들이야 말로 아이러니하게도 저런 소비중심주의, 세태의 거품에 의해 휩쓸려 다니는 경제가 가장 잘 이용해먹는 대상이 그 자신이란건 절대 이해하지 못할거 같다. 단순히 금전적이거나 사회적인 것을 떠나서, 스스로의 생각, 마음도 그렇게 좌우되며 삶을 원치 않을, 혹은 알지도 못한 방향으로 그저 흘려만 보내게 될테니 싶다.\n글쎄다. 말의 내용이 중요한것이 아니라, 그 형식이나 동물로서의 본능에 기반하는 ‘베이직 토크’의 가치만이 세상에 흔하다고 하더라도 말이다.2 …그런 개념의 의미는 그런 테크닉으로 어떤 사람들을 대해야 한다는 뜻이지, 자기 스스로도 거기에 휩쓸리고 있어야 한다는 뜻은 되지 않을텐데 말이다.\n굳이 지금의 후기자본주의사회, 신자유주의, 소비중심주의 시대가 아니어도 그런 이들은 언제나 그래왔으리라 싶다.\nFootnotes 1 UTF-8은 흥미로운데, 왜냐하면, 기존의 ASCII/8비트 = 1바이트 = 1문자 기반의 C런타임, API들에서도 별 문제 없이 동작할 수 있도록 설계되었기 때문이다. 물론 모든 부분에서 그런 것은 아니지만, 그래도 최근에 블로그에서도 다룬 graceful degradation-하도록 설계되어 있다.\n2 무지한 자들과 대화하는 법 페터 모들러 (저) / 김현정 (역)\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/ruby-is-an-acceptable-lisp-reloaded/","title": "🔋 Ruby is an acceptable LISP (Reloaded!)",
     
     "tags": ["ruby", "lisp", "reloading", "zeitwerk", "bundler", "rubygems", "rails", "filewatcher", "common-lisp", "commonlisp", "smalltalk"],
     
 "description": "",
 "contents": " HN: Why Ruby is an acceptable Lisp (2005) (randomhacks.net)\ncommonlisp sly/slime 세션의 interactive development처럼 흉내내기. (제목의 “reloaded”-은 말장난)\ncommonlisp sly/slime? 커먼리습을 위한 emacs mode. 흥미로운 점은 실행중인 리습코드가 이미 루프를 돌아가고 있더라도, 다른 스레드의 swank1에서 코드를 변경+컴파일해서 로딩하면, 실행중인 루프에 바로 반영된다.\n이게 뭐가 편한가 싶은데, 만약 다른 언어였다면:\n코드를 수정. (OPTIONAL) 동작하고 있던 프로그램을 종료 (OPTIONAL) 새 코드를 컴파일하거나, 어쨌든 다시 처음부터 프로그램을 시작. … #1부터 반복. 물론, “watcher”-같은걸 붙여놓고 자동으로 파일이 변경되면 tests을 다시 실행하거나, 프로그램을 재시작하도록 하는게 ‘development’-mode에선 일반적이다.2\n물론 꼭 커먼리습/스몰톡 같이 변경이 실행중인 코드에 바로 반영되어야만 하는 경우는 많지 않을수도 있다.\n반면에, 그렇게 코딩단계를 쓰지 못하기 때문에, 현재의 tests을 변경에 따라 실행해 나가는 방식으로 자리를 잡게 되었는지도 모르겠다.\nrails은 그냥 되던데요 실은 rails 개발을 하면, 코드를 수정하고 즉시 웹브라우저에서 변경된 내용을 F5 / reload만 눌러서 확인이 가능하다.\nrails server을 다시 시작할 필요도 없고, 마치 php와 같이 변경이 바로 반영되어 확인할 수 있음.\n그런데 생각해보면, php은 실행모델이 원래 그러니까 자연스럽게 변경된 내용이 다음번 HTTP request에 바로 반영된걸로 보이는게 당연하다. php은 한 http request이 실은 php 파일을 로딩하고 처음부터 다시 실행되는게 기본전제이고, 현대의 php-fpm이나 frankenphp등의 다른 방식을 사용하더라도, 최소한 development-mode에선 이런 php의 특성을 그대로 유지하려고 애쓰는 모습이다. (개발단계가 엄청나게 편해지니까)\n그런데, rails은 별도의 루비코드가 하나의 요청-응답을 처리하는 서버프로세스로 이미 동작하고 있는데 어떻게 자동적으로 변경을 반영해줄 수 있을까?\n==\u0026gt; 답은, rails이 zeitwerk rubygem을 사용하고 있기 때문. 3\ncommonlisp, smalltalk의 또다른 (숨은) 편리함 바로 import / require 같은걸 쓸일이 없다는점.\n커먼리습과 스몰톡 모두 현재 VM이 로딩한 코드는 패키지나 카테고리 같은 namespaces으로 구분되기는 하지만 직접 이들을 로딩할 필요가 거의 없도록 한다.\n물론, 처음 코드를 파일시스템이나 Git에서 로딩하기 위해서 asdf이나 Iceberg등을 사용하기는 하지만, 처음에 한 번이다. 커먼리습은 코드파일을 변경하고 그걸 바로 컴파일+로드 해나가면서 작업하고, 스몰톡은 이미지에 계속 작업을 쌓아가다가 나중에 Git commit하거나 Export하므로.\n반면 Java 같은 나름대로 import하기 균일한 언어만 해도 IntelliJ/Eclipse JDT/LSP 같은 도구가 없다면 import을 하나씩 찾아주기 괴로워진다.\nnode.js에서 require/import은… 더 끔찍하다. commonjs module, esm 구분도 골치아파지고 쓸때마다 괴롭다.\n루비에서도 require은 있지만, 가장 단순한 형태에 속하는거 같다. 그냥 지정한 이름을 $LOAD_PATH-에서 찾아서 로딩하는것.\nPerl 5의 use 같은 신비롭고도 복잡한 방식은 아니라 다행이다.4\n그런데, rails을 쓰다보면, controller/service등의 코드에서 다른 클래스를 불러오기 위해 require-을 쓸일이 전혀 없다.\nzeitwerk? 위에 언급한 커먼리습과 스몰톡의 장점을 루비/레일즈에서 zeitwerk을 통해 얻을 수 있다5:\nrequire-없이 바로 클래스나 모듈에 접근이 가능하다. 소스코드 파일이 변경되면 자동으로 해당 코드만 reload하여 반영할 수 있다. 실은 rails 프로젝트를 개발하면, zeitwerk이 이미 세팅되어 있어서 신경쓸게 없다.\n여기에선 ruby가 이런 측면에서도 an acceptable lisp (reloaded!)임을 보이기 위해서 하나씩 시도해보려고 함. (그리고 재밌으니까)\n1단계: require 제거 내가 짠 클래스(MyLib::Greeter) 불러와 사용하는 스크립트.\nmain.rb :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/env ruby require \u0026#39;bundler/inline\u0026#39; gemfile do source \u0026#39;https://rubygems.org\u0026#39; gem \u0026#39;zeitwerk\u0026#39; end loader = Zeitwerk::Loader.new loader.push_dir(Pathname(__dir__) / \u0026#39;lib\u0026#39;) # \u0026lt;-- 요기에서 찾아서 로딩. loader.setup # vvvvv `require` 없이 바로 사용! puts MyLib::Greeter.new.greet lib/my_lib/greeter.rb :\n1 2 3 4 5 6 7 module MyLib class Greeter def greet \u0026#34;Hello, World!\u0026#34; end end end 여기서 사용한 내용들은:\nbundler/inline : https://bundler.io/guides/bundler_in_a_single_file_ruby_script.html zeitwerk : https://github.com/fxn/zeitwerk?tab=readme-ov-file#synopsis 2단계: code reloading main.rb (개선) :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #!/usr/bin/env ruby require \u0026#39;bundler/inline\u0026#39; gemfile do source \u0026#39;https://rubygems.org\u0026#39; gem \u0026#39;zeitwerk\u0026#39; gem \u0026#39;filewatcher\u0026#39; # \u0026lt;-- 추가 end loader = Zeitwerk::Loader.new # for_gem(warn_on_extra_files: false) loader.push_dir(Pathname(__dir__) / \u0026#39;lib\u0026#39;) loader.enable_reloading # \u0026lt;-- 추가 loader.setup # 별도 스레드에서 파일변경모니터링 =\u0026gt; zeitwerk-reload fsw = Filewatcher.new([\u0026#39;lib/\u0026#39;]) Thread.new(fsw) do fsw.watch do |_filename| loader.reload end end # 예시를 보이기 위해 계속 실행되어야 하므로. loop do # ...새로운 인스턴스에 변경이 적용되므로, # ...매번 new하도록. puts MyLib::Greeter.new.greet sleep 1 end …이제 이 스크립트를 실행시키고, lib/my_lib/greeter.rb-을 수정하여 메시지를 바꾸고 저장해보면, 실행중이던 스크립트의 출력이 즉시변경된다. 🎊\n한계점 위 예제에서 보듯이, 이미 존재하는 인스턴스를 바꿔치거나 하는건 동작하지 않을것 같다.\n하지만, 인스턴스를 바꿔쳐줘도 좀 혼란스러울거 같은데, 어떤 기준으로 어떻게 전환될지 이해하기 어려울거 같기 때문. 저정도만 해도 합리적인 수준인거 같다.6\nRuby에서 zeitwerk이 유용했던 이유? 앞서 언급한 루비 이외에 최근에 흔한 Node.js, Python 등의 다른 언어들이었다면, zeitwerk 같은 라이브러리가 있었다고 하더라도, 유용성이 적었거나, 그냥 현재의 아예 프로그램을 처음부터 재시작하는 방식이 더 나았으리라 싶다.\n그렇게 생각하는 이유는 루비의 설계가 Smalltalk + Lisp + … 이기 때문인거 같다.\n루비의 메서드호출은 스몰톡의 그것과 같이 message-passing으로 이루어지고, 이는 실행시간에 성능이 느리지만, 진짜 dynamic-dispatch이 가능하도록 해준다. 그리고 루비의 큰 장점인 metaprogramming도 이런 특성에 큰 덕을 보고 있다.7\n리습의 경우에도 유사하게, 함수의 심볼을 갖고 있고, 그 심볼에 연결된 함수를 호출하는, 결과적으로 message-passing와 거의 같은 효과를 갖는다.\n호출하는 쪽에서 코드가 변경되지 않더라도(reload하지 않더라도), 피호출 클래스나 코드가 변경된 것을 실행시간에 그대로 반영 받을 수 있는 구조이기 때문이다.\n실은, 자바스크립트나 파이썬도 실행시간에 메서드를 찾아내는 방식은 충분히 동적이다. ㅎㅎ그리고 루비 + zeitwerk도 완전히 모든 경우에 프로그램을 완전히 재시작할 필요를 없애주지는 못한다. 하지만, 이 글은 루비에 우호적인 글이므로 이렇게 써봤다.\n글쎄다. 다른 언어에서보다 이렇게 생태계나 툴링이 마치 리습이나 스몰톡을 복원한것처럼 되어온데엔, 기술적인 특징 이외에도, 원래 루비가 그런 조상들에 대해 호감을 갖고 있었기 때문이지 않을까.\nFootnotes 1 GitHub: Understanding the Slynk protocol? #529\n2 npm에서만 찾아봐도, nodemon, chokidar, node-watch등 딱 이렇게 쓰기 위한 도구들이 있다.\n3 물론, rails에선 zeitwerk을 그냥 그대로 사용하는것만이 아니라, 파일변경을 모니터링하고 reload을 요청하고 하는 모든 처리를 해준다.\n4 https://perldoc.perl.org/functions/use … @INC-로딩경로를 탐색도 하고, 거기에 나아가서 해당 ‘모듈’의 코드를 실행해서 importing도 처리해주고… 그리고 모듈만이 아니라 “pragmas”에 속하는 경고수준을 바꾸거나 하는 것도 모두 이렇게 구현되어 있어서 복잡하다. 그리고 이런 “훌륭함”이 JavaScript에도 전해져서 \u0026#34;use strict\u0026#34;-같은 갑자기 분위기 Perl인 문장들이 자바스크립트에 안어울리게 종종 튀어나오는 원인이 되기도 한다.\n5 “zeitwerk”은 직역하면 “time-work”(獨🇩🇪).\n6 커먼리습의 CLOS은 이미 존재하는 인스턴스의 클래스를 바꾸는게 가능하긴 하지만: https://funcall.blogspot.com/2025/03/advanced-clos-update-instance-for.html …괜찮다. ㅎㅎ\n7 과거의 Objective-C와 OSX의 NeXTSTEP API들도 모두 이런 스몰톡의 특징을 그대로 구현해놓았다. (API와 ObjC Runtime을 통해서)\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/haruki-manga-stories--super-frog/","title": "🗃️ 무라카미 하루키 “Manga Stories 1” 그래픽노블",
     
     "tags": ["ping", "무라카미-하루키", "haruki-murakami", "novel", "manga", "graphic-novel", "book", "books", "reading"],
     
 "description": "",
 "contents": " goodreads 리뷰\n책표지\n재밌게 읽었다. 이미 출판된 하루키의 단편들을 다시 그래픽노블 형식으로 출판한 책. 아마 2권도 마저 읽고, 3권도 구해서 읽을거 같다. 그리고 여기서 소개 받은 단편들을 다시 찾아서 읽게 될 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/script-defer-ftw/","title": "🕛 global hx-boost + &lt;script defer&gt;",
     
     "tags": ["htmx", "hx-boost", "blog", "blogging", "webdev", "css", "script-defer", "defer", "domcontentloaded", "onload", "ready"],
     
 "description": "",
 "contents": " 지금까지의 스토리🧚🔮🧌 블로그 + [htmx transition animation, loading indicator categories안녕👋 taxonomies 정렬 추가 htmx hx-boost을 사용하여, 블로그내의 링크이동을 빠르고 가볍게 만들었다.\n그런데, 페이지가 로딩된 다음 자동으로 실행될 자바스크립트를 지정하기 어려워졌다. 사례로 위 (2)-을 구현하는데에 현재 선택된 정렬기준을 표시해주는 JS이 페이지 로딩 때에 자동으로 실행됐으면 했는데 그게 좀 어려웠다…\nhx-boost와 onload 🦻 페이지가 로딩됐을때, JS이 실행되도록 하는 방법은 여러 가지가 있…: onload, ready, DOMContentLoaded 모두 조금씩 다른데 여기서는 소개하지 않겠다. 인터넷에 충분히 많은 좋은 설명이 있으니까.\nDOMContentLoaded, load, beforeunload, unload 이벤트 (dev.to) DOMContentLoaded vs window.onload 그런데 공통점은: JS코드를 실행해서 ‘원하는 시점’에 실행하길 원하는 코드를 등록하는 방식,이란 점이다.\n문제는 hx-boost-와 엮일 때에 발생했다: hx-boost은 웹브라우저의 현재페이지 컨텍스트를 모두 지우고, 새로 이동하는 페이지의 컨텍스트로 다시 시작하는 것이 아니라, 현재 페이지의 컨텍스트를 그대로 유지한 채, 새로운 페이지의 내용으로 그 컨텍스트를 변형해 나가는 방식이기 때문.\n그래서 생기는 문제는:\nhx-boost 링크를 통해 로드한 페이지에서 등록한 onload-등의 ‘이벤트핸들러’들이 실행되지 않는다. 대안 htmx:afterSwap ? 실제로 hx-boost이 페이지의 내용을 변화시킨것일뿐, 웹브라우저의 관점에서는 페이지컨텍스트를 새로 만든 것이 아니므로 그런 이벤트핸들러를 실행시켜주지 않기 때문. 😥\n그래서 대안으로, Event - htmx:afterSwap-을 지정할 수 있음. hx-boost-이 DOM을 변형한 이후에 실행해주기 때문에 onload에 유사하게 기대한 것처럼 동작할 수 있다. 🤩\n…하지만, 다음과 같은 문제가 여전히 있다. ☠️\nglobal hx-boost: 특정페이지를 위한 콜백을 실행해주는 htmx:afterSwap 이벤트를 지정하기 곤란하다.\nglobal hx-boost =\u0026gt; htmx:afterSwap =\u0026gt; per-page callback 호출하는 구조를 만들수는 있을 것 같다. 🩵\n하지만 일종의 특별한 이름/구조의 뭔가를 만들어주는 것이니 일단은 피하고 싶다. global hx-boost이 지정된 위치가 아닌, 불러들인 페이지의 요소에 htmx:afterSwap 지정을 지원하지는 않는 것 같다. 👪\n예: 불러온 페이지에서 \u0026lt;div ... hx-on::after-swap=\u0026#34;doThis(...)\u0026#34;\u0026gt; 같이 지정할 방법. 그런 방식이 가능하다면, 위 (1.1)-을 따로 구성할 필요도 없이 불러들이는 페이지마다 이렇게 지정하기만 하면 될테니. \u0026lt;script defer\u0026gt; 결국 특정한 시점을 JS에서 지정하거나, 등록하는 일들을 일반적인 웹브라우저 페이지이동 \u0026lt;=\u0026gt; hx-boost 간에 서로 잘 호환되지 못하는거 같다.\nhx-boost으로 불러들인 페이지는 그 페이지의 모든 \u0026lt;script\u0026gt; 등을 다 실행해주지만 시점을 지정하는 것이 어려웠을 뿐이었어서.\n==\u0026gt; 그래서 \u0026lt;script defer\u0026gt;-을 활용하는걸 좀 더 열심히 하게 되었다.\n아직까진 적당히 의도대로 동작해 주는거 같다. ㅎㅎ🤑\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/no-categories+taxonomy-revamp/","title": "🐅 categories안녕👋 taxonomies 정렬 추가",
     
     "tags": ["blog", "blogging", "programming", "css", "javascript", "js", "hugo", "taxonomy", "taxonomies", "sort"],
     
 "description": "",
 "contents": " 👉 새로운 묶음법: “📚시리즈(Series)” …추가하고 “😺카테고리(Categories)”,은 별로 쓸모가 없었구나 생각이 들어서 제외시켰다.\n이제 “📚시리즈(Series)” / “🏷️태그(Tags)” , 2개의 Taxonomy만 사용하여 블로깅을 해나가려고.\n아예 /categories-관련 페이지는 아예 생성하지 않기로. 표시도 않기로. 대신 tags을 정렬해서 보여주기로:\n참조빈도가 높은 태그부터 정렬해서 보여주면, 그게 사실 \u0026#34;카테고리\u0026#34;의 의도였던 \u0026#34;대분류\u0026#34;-처럼 쓰일 수 있으니까. /tags , /series 페이지에서 기본은 참조횟수로 역순정렬해서 보여주고, 추가적으로,\n이름 abc순서, 최근 갱신일, …의 추가 정렬기준에 따라 직접 재정렬해서 찾기 수월하게 바꿨다. …ascending/descending 순서으로 정렬도 구현해줬다. 뭔가 삽질에 완벽하게 깔끔한 구현은 아니지만, 적당히 htmx hx-boost으로 다시 만든 블로그 이동방식과 잘 어울리는거 같아서.\n이제 모든 포스팅 뒤적거리면서 태그를 붙이는 작업을 나중에 하면 마무리겠지. 🪓\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/blog-htmx-transition-anims/","title": "🧂 블로그 + [htmx transition animation, loading indicator]",
     
     "tags": ["htmx", "morphjs", "blog", "blogging", "webdev", "css", "loading-indicator", "animation", "effects", "progress-bar", "transition"],
     
 "description": "",
 "contents": " htmx hx-boost-을 적용하기 시작하면서(이 시리즈 전 포스팅 참고 👉 htmx 마법으로 링크성능 빠르게 + dark-mode 깜빡임 제거 ) 효과를 넣는게 가능해졌음.\nhtmx loading indicator 적용.\nhttps://dev.to/amal/global-progress-bar-for-htmx-50fa htmx view transitions animation 적용.\nhttps://htmx.org/examples/animations/#settling …좀 무던하게 적용해보려 뚝딱 🛠️\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/new-taxonomy--series/","title": "🧙‍♀️ 새로운 묶음법: “📚시리즈(Series)”",
     
     "tags": ["blog", "blogging", "hugo", "taxonomy", "taxonomies", "categories", "category", "tag", "tags", "series"],
     
 "description": "",
 "contents": " 기존에는 “😺카테고리(Categories)”, “🏷️태그(Tags)”만 설정해서 써왔었는데, 어느샌가, 일대기 형식으로 계속 묶어나가야 분류가 수월한 글들이 쌓여갔다: (예) dark-mode 지원하기\n그래서 새로운 “시리즈” taxonomy 추가하고, 페이지템플릿들 조금 고쳐서 지원 시작.\n음… 과거에 쌓은 글들을 좀 시리즈로 이렇게 더 묶어야 할까 고민도 들고,\n무엇보다, 그간 아무 생각없이 남들 다 그렇게 하니까, “카테고리”를 추가해서 써오던 것이 좀 후회스럽다. 사실은 저거 그냥 “태그”랑 다를게 없는데 싶기도 하다. 굳이 차이를 갖자면 “대분류”정도로서, 이맥스 글이나 프로그래밍 글끼리 묶기 수월한 점 + 그리고 태그목록보다는 훨씬 가짓수가 젂으니까 찾아보기 좋다는 점 정도?\n…그러니까 냅두자. ㅋㅋㅋ고민은 시작했지만 변명을 찾아버렸다.\n앞으로 시리즈 성격의 글을 쓰고 묶어 나가도 재밌긴 하겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/graceful-degradation+progressive-enhancement+elegant-degradation/","title": "🌬️ ‘graceful degradation’, ‘progressive enhancement’",
     
     "tags": ["progressive-enhancement", "graceful-degradation", "TIL"],
     
 "description": "",
 "contents": " 하나씩 정리해보자.\n이하의 정리는 “웹개발”, “웹페이지” 유지보수 관점/도메인의 시점에서, 다른 도메인(예=전자제품)에서의 정의와 완전히 일치하지는 않을거 같다.\n위키백과나 다른 블로그에서 소개한 글들은 전자제품, 전자통신 등의 관점, 개념, 용어 중심으로 풀어 설명했기 때문에 웹개발의 관점에선 잘 모르겠었어서. (원저자분들 죄송합니다. 🙇)\n즉, 이하에 소개할 링크에서 W3C의 정의에 따라 이해해보려고 함.\n“progressive enhancement” -or- “graceful degradation”? W3C Wiki Graceful degradation versus progressive enhancement 기계인간 John Grib 우아한 성능 저하 (graceful degradation) 조금 뭔지 모를 영어가 많이 나와서 혼란스럽다.\n“Graceful Degradation” ‘기능’ 구현의 대상이 현대적인 웹브라우저를 대상으로 구현. 그리고 그 구현대상인 현대 웹브라우저를 기준으로 ‘사용자경험’이 최적이 되도록 설계/구현. 반면, 구형 웹브라우저에서는 약간의 사용자경험이 떨어질 수는 있는. 하지만, 그럼에도 구형 웹브라우저에서도 기능적인 측면에서는 여전히 기본적인 기능이 잘 동작해야 함. 즉, 최적의/최대한의 사용자경험을 제공하는 것을 우선목표로 하고, 그 다음에 그걸 수행하지 못하는 환경을 배려하는 설계-구현을 더하는 방식. 즉, 가능하면 최신의 기능이나 지원을 잘 활용하여 설계-구현하되, 그게 지원되지 않는 환경에서도 적당히 쓸 수 있도록 하는 방식.\n(예: 👉 /posts/2025-12dec/htmx-hx-boost+dark-mode/ )\n“Progressive Enhancement” (반대로) 기초적인 사용자경험을 우선목표로 시작하는 방식. 그리고 거기에 추가적인 지원이 가능한 환경을 위해, 더 나은 사용자경험을 지원하는 설계-구현이 자동적으로 덧붙여질 수 있도록 하는 방식. 즉, ‘최대공약수’, ‘하한선’, ‘lower limit’에 맞춰서 설계-구현의 주요목표를 설정하는 방식. “우로 가나 모로 가나 그게 그거 아냐?” 최종결과물이 비슷하게 나온다면 그래 보일 수 있음. 😅\n하지만, 접근방식의 차이이기 때문에 그 과정과 선택하는 시점의 이유는 명확히 다른거 같다.\n이건 그냥 W3C 페이지에서 복붙하겠음:\ngraceful degradation을 고려할 때: 리거시에 대한 낮은 가시성/접근성 또는 개선을 위한 시간/자원의 부족:\nYou retrofit an old product and you don’t have the time, access or insight to change or replace it. You just don’t have time to finish a product with full progressive enhancement\n(often a sign of bad planning or running out of budget). 😥 혹은 변경에 따른 위험도가 너무 큼\nThe product you have is an edge case, for example very high traffic sites where every millisecond of performance means a difference of millions of dollars. Your product by definition is so dependent on scripting that it makes more sense to maintain a “basic” version rather than enhancing one (Maps, email clients, feed readers). progressive enhancement은: 적용가능하다면, 사용자와 개발자 양자를 모두 행복하게 할 가능성이 높다고.. 잘 isolated + high-cohesive + low-coupled 모듈의 정의와 유사함을 알 수 있음.\nRegardless of environment and ability you deliver a product that works. When a new browser comes out or a browser extension becomes widely adopted you can enhance to yet another level without having to touch the original solution — graceful degradation would require you to alter the original solution. When a new browser comes out or a browser extension becomes widely adopted you can enhance to yet another level without having to touch the original solution — graceful degradation would require you to alter the original solution. If you need to add new features, you can do so after checking if they are supported at a certain stage, or you can add it to the most basic level of functionality and make it better in more sophisticated environments. In any case, the maintenance happens at the same spot and not in two different places. Keeping a progressively enhanced product up-to-date is much less work than maintaining two versions. "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/htmx-hx-boost+dark-mode/","title": "‼️ htmx 마법으로 링크성능 빠르게 + dark-mode 깜빡임 제거",
     
     "tags": ["htmx", "spa", "morphjs", "progressive-enhancement", "dark-mode", "blog", "blogging", "webdev", "css", "graceful-degradation", "hx-boost", "darkmode.js"],
     
 "description": "",
 "contents": " 지난번 dark-mode 방식을 새로 만든 이후로, 눈에 띄는 단점이었던 페이지이동시 flash현상을 없애고, 또한 매 페이지 이동을 엄청나게 가볍게 만들었다.\n지난 포스팅: 🦹 darkmode.js… prefers-color-scheme …위 포스팅에서 “Wrap Up”-표를 확인해 보면:\ndarkmode.js (기존) 새로운 방식 ...생략... 😥-1 페이지 로딩시 flash 현상이 생긴다 😥-1 브라우저캐시에 없는 페이지를 로딩할 때에 발생할 수 있음. (OS/브라우저 prefs와 local-storage에 저장된 color-mode이 서로 다른 경우) ...darkmode.js보단 가볍게 사라짐. ...생략... …와 같이 된 부분을 다음과 같이 바꾼 것:\n여전히 처음 브라우저에서 방문할 때엔 OS/웹브라우저에 의한 color-scheme preferences에 따라 깜빡임이 발생할 가능성은 있음. 하지만 블로그 안에서 링크를 이동할 경우엔 발생하지 않게 방식을 변경했다. 🐻 그리고 블로그에서 페이지링크를 여는 성능도 훨씬 쾌적해졌다. 🎐 방식 🛠️ htmx의 hx-boost=\u0026#34;true\u0026#34;-만 적용했다. 끝 🚩\n모든 \u0026lt;a href\u0026gt;-링크 이동은 이제 자동으로, 이동한 페이지전체를 다시 로딩하지 않고, ajax으로 로딩하여 필요부분만 다시 렌더링한다. [참고] hx-boost [htmx.org] hx-boost “Why hx-boost is actually the most important feature of htmx” 어떻게 더 빠른가?🧩 hx-boost 이하에 적용된 링크들은 자동적으로, (htmx에 의해) 가로채진다. 가로챈 링크는 ajax request을 보내서 페이지의 내용을 얻음. 얻은 페이지의 내용은 페이지의 부분부분을 갱신한다. (“partial swap”) 웹브라우저의 URL을 History API을 이용하여 변경해준다.\n마치 링크를 이동했을 때처럼. Back버튼도 제대로 동작할 수 있도록. …이런 설명만 읽어서는… 오히려 htmx.js/ajax이 동작하는건데도 웹브라우저가 URL이동하는 것보다 어떻게 빠를까 싶은데:\n동일하게 이미 로딩되어 있는 CSS, JS등을 다시 로딩하거나 초기화하지 않음. 그리고 그와 관련된 Assets (fonts, 등등등)도 그대로 두니까. …결과적으로 훨씬 빠르고, 체감도 가볍게 렌더링된다.\n(마치 SPA 자바스크립트 애플리케이션의 화면 전환과 같이)\n실제로 Developer Inspector을 열어놓고 링크를 눌러보면, 네트웍 트래픽이 오가는 것을 볼 수 있거나(현재 페이지에서 추가적으로), 처음 열때의 페이지context을 그대로 유지한다는걸 관찰할 수 있다. (링크를 누를 때마다 새로운 page context으로 refresh되는 것이 아닌)\n“graceful degradation”: js을 지원하지 않는 웹브라우저도 괜찮을까? 😸 그렇다.\n어차피 ‘hx-boost’-이 영향을 주지 못한다면, 기존 링크들은 원래의 링크가 그랬듯이, 그냥 페이지이동을 하듯이 동작을 그대로 할테니까. ㅎㅎ\n물론, flashing현상이나, 약간 더 무거운 페이지로딩이 뒤따르겠지만. ㅎㅎ\n용어 ‘graceful degradation’\n👉 /posts/2025-12dec/graceful-degradation+progressive-enhancement+elegant-degradation/ "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/the-html-hell-page/","title": "😽 The HTML Hell Page",
     
     "tags": ["webdev", "css", "html", "hell", "hellish", "design", "hello", "humor", "toy", "fun", "crazy", "madness", "video", "audio", "midi", "js", "javascript", "flash", "shockwave", "abonimation", "gandalf", "sax", "imagemap", "90s", "2000s", "popup", "java", "applet", "reactjs", "electronjs", "marquee", "blink"],
     
 "description": "킹받는 웹페이지 디자인의 몯느것, 혈압을 위해 읽지않는걸추천",
 "contents": " 👉 요기에서 “영감”을 받아서: https://www.catb.org/~esr/html-hell.html\n하나씩 짜보니까:\n생각보다 더이상 인류가 접근할 수 없는 로스트테크놀로지들이 많아져서 안타까웠다. (예; 강제팝업창, Java Applet, Shockwave, Flash 등등등) 서양 웹디자인 기준으로 원본글이 작성되어져 있어서, 주옥 같은 한국의 현재진행형 흠좀무 웹/앱 디자인들은 정리하지 못했다. 누군가 용사가 나타나 정리해줘도 좋을 것 같다. 🗡️🛡️🩏 💡 깜빡이 / blinking text 💫BLINKING!!! 반짝반 \u0026nbsp;\u0026nbsp;짝작은 별 ! 🈙 불필요한 애니메이션 / gratuitous animation 휘이잉이이이잉이이이잉ㅇ🚁~~~~~~~~~~~~~~~~~ 🏃 marquee-s 🏃‍♂️Ruuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuun Forest Ruuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuun 🏃‍♂️ 🔥 불타는 배경 / garish backgrounds 🔥 FIRE WALK WITH ME... 👨🏿‍🚒☕🍩🪵 🤡 견딜 수 없는 텍스트/배경색 조합 / unreadable text/background combinations “웃자고 한 말에 뭘 그렇게 정색하세요?” 🖌 필기체/붓글씨체 제목 / brushscript headings 🗗 \u0026#34;이 사이트는 …에 최적화되어 있습니다\u0026#34; / \u0026#34;Best viewed with…\u0026#34; 🙊 “최적의 감상을 위해 브라우저 창크기를 32187379317913x2419873978139781391564181489으로 조절하세요.” 지시문 / “resize your browser to…” instructions 🐳 거대한 고정된 크기의 table / large fixed-size tables 합계 23,179,813,791 KRW 🍟 불필요한 border-spacing / unnecessary border spacing 합계 23,179,813,791 KRW 🤪 무의미한 \u0026lt;small\u0026gt; / \u0026lt;font size=...\u0026gt; 사용 / Pointless use of \u0026lt;small\u0026gt; or \u0026lt;font size=\u0026gt; 💦 자바스크립트으로 자기위안의 행위 / masturbation with Javascript ... 아 이것만은 만들 수 업읍니다... 이미 세상에 너무 많은 예제가 있으니 직접 찾아보세요. ☕ 불필요한 자바의 사용 / unnecessary use of Java 이제 자바애플릿을 실행할 수 있는 웹브라우저가 없을테니, 스샷으로 대체합니다. 💥 “팝업창” / pop-up windows ...일주일간 열지 ㅇ낳기. (원본 이미지: https://m.blog.naver.com/dasol825/220672901113 고맙습니다. 🙇)\n😔 image-map으로만 구현된 메뉴 / menus made entirely from image maps 아숩게도 2020년데엔 더이상 사용하지 않는 아름다운 기술이라, 생략. 🎷 묻지도 따지지도 않고 재생시작 / sound and video that launches without prompting 안타깝게도 2025년 현대의 웹브라우저는 자동플레이를 막아놓앗습니다. 😔\n부디 아래 비디오를 클릭하여 플레이 해주시기 바랍니다. 🥹🙏\n(원본 비디오\u0026amp;스크립트: https://davidepastore.github.io/gandalf-sax-guy/ 고맙습니다. 🙇)\n🔍 픽셀단위로 글꼴크기를 지정한 CSS / CSS that sets fixed-size fonts dimensioned in pixels ‘em‘, ‘rem‘ 단위로 지정하는게 맞다는거 같음.\nCSS that changes the hotlink colors 형형색색 …사실 링크 눌렀을 때 색상변화를 의미하는거 같은데, 이정도만 하고 참겠음.\n배경/글자색 한쪽만 강제해놓기 / Forcing one of background and text colour, but not both. 내가 보이나요? 🥸 나도 보이나요? 🥳 🎘 배경MIDI, 플래시, 쇽웨이브, 등등의 끔찍한 혼종 / background MIDI, Flash, Shockwave, and other abominations 이것도 더이상 쓰이지 않아서 슬픔 😔\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec19--01-ping/","title": "🛸 Ping 19/12/2025 .01.",
     
     "tags": ["ping", "youtube", "music", "song", "viktortsoi", "kino", "2025", "peterzeihan", "呑虛"],
     
 "description": "",
 "contents": " 2025년도 거의 다 지나가고 있다. 을씨년스럽다는 을사년(乙巳年).\n올해도, 그리고 한층 더 가소롭게 화려해보였지만, 쓸쓸한 그 알맹이의 거리였다. 참 이상하지. K문화니 뭐니 하지만 그안에서 살아가는 사람들은.\n언제나 그래왔지만, 유난히 다들 더 커보이려, 또는 자신이 아닌 위대해 보이는 무언갈 끌어다가 그 껍질이라도 뒤집어 쓰려고 드는, 불안과 두려움에 그러는 것을 더 숨기지 못하게 만드는 모습들.\n두렵게도, 천천히, 혹은 예상보다 훨씬 더 빠르게 말해진 미래가 훌쩍 뉴스가 되어 있었었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/prefers-color-scheme/","title": "🦹 darkmode.js... prefers-color-scheme",
     
     "tags": ["blog", "blogging", "webdev", "css", "sass", "js", "javascript", "darkmode.js", "chromastyle", "hugo"],
     
 "description": "사용하던 darkmode.js 방식을, CSS 방식으로 재작성했다.",
 "contents": " (기존) darkmode.js 방식 👉 Darkmode.js 도입기 #1: 처음 구현 도입기 #2: darkmode.js 사용 장단점 ... 장점 ❤️ 적용이 쉽다 장점 ❤️ darkmode 색상을 지정할 필요 없다.\n(자동으로 inverse색상으로 표시) 장점 ❤️ 전환 애니메이션이 멋있다 단점 😥 css이외에 darkmode.js 초기화시에 배경색 전달해줘야 단점 😥 inverse 색상이 가끔 괴랄하다 단점 😥 페이지 로딩시 flash 현상이 생긴다 단점 😥 페이지 스크롤시 아직 덜 칠해진 부분이 보이기도 한다 처음에 도입은 쉽고 좋았는데,\n어쨌든 반투명레이어 + color-inverse-css-filter을 이용해서 구현한 방식인거 같아서 위에 나열한 스크롤시 아직 레이어가 덮지 않은 영역이 보인다거나,\n페이지로딩 이후에 js이 실행되어 레이어를 올릴지 말지를 행동을 취하는 방식이기 때문에… 처음엔 무조건 light-mode이 보이고 빠르게 dark-mode으로 전환하는 과정에서 flashing 현상이 생길 수 밖엔 없는 구조.\n새로운 방식을 설계 + 구현시작 평범하게 css 사용 @media (prefers-color-scheme: dark) 방식을 알아봄: 👉 [MDN] (at-rules) prefers-color-scheme\n생각보다 해야 할 작업이 좀 됨:\nCSS에서 색상표/팔레트를 하나 더 준비해야 함: 🌻light-mode / 🌚dark-mode 그말은: 기존 CSS의 색상값들을 더 정돈해서 변수화해야 함. 별도의 CSS class을 만들지 않고, 동적으로 var(...)-기능을 이용하여, 웹브라우저가 자동으로 CSS variables 선택하도록 만들엇다: 👉 [MDN] var() 1\n색상표/팔레트 + CSS클래스에 적용 SASS에서 다음처럼 일단 색상표를 만들어 나감:\n1 2 3 4 5 6 7 8 9 \\:root color-scheme: light dark --bg-color: #{$bg_beige} --text-color: #{$blackish_text} @media (prefers-color-scheme: dark) --bg-color: #{$monochrome_black} --text-color: #{$monochrome_lgrey} color-scheme: 👉 [MDN] color-scheme $bg_beige, $blackish_text 등의 색상값들은 그 위에서 SASS변수로 등록:\n1 2 $bg_beige: #fffbeb $blackish_text: #5c5537 사용은 이런 느낌으로 했다:\n1 2 3 body background-color: var(--bg-color) color: var(--text-color) [추가❌] light-dark() 👉 [MDN] light-dark() 이런 것도 이제 지원하기는 하던데. 쓰진 않음.\n최근에 추가되어 호환성이 아직인거 같아서.\n아마 장점은, var(...) 사용하려면, :root pseudo-class에 css 변수들 등록해 놓아야 하는데, 그럴 필요 없이 바로 light/dark-mode에 따른 컬러값 literal 적어줄 수 있을거 같다.\n그런데 그냥 어차피 색상표/팔레트 정리하기로 마음 먹었으니 안썼다. 🍣\nJS: 색상토글하기, 선택테마한 저장+로딩하기 👉 [SO] How do I detect dark mode using JavaScript? 👉 [SO] How to override css prefers-color-scheme setting 위 링크들 베껴서:\n다크모드 토글버튼\n+다음에 페이지 다시 로딩되면, 선택한 색상테마가 다시 불리도록 local-storage 저장하기. 페이지 로딩되면:\n이전에 선택되어 local-storage에 저장해놓은 색상테마으로 전환. 아니면 냅두기. (사용자 OS/브라우저 preferences가 그냥 먹도록) [Hack 🪓] Hugo Syntax Highligthing Hugo 블로그생성기의 chromastyles으로 코드 문법강조를 사용하고 있었는데, 이걸 색상모드별로 적당히 전환하고 싶었다.\n원래는:\nhugo gen chromastyle 명령으로 특정한 1개 테마의 스타일시트를 미리 생성하고, (그걸 적용해도 문제가 없는게) darkmode.js이 color-inverse해줬으니 그럴싸하게 보였었다. 그래서:\n원하는 스타일시트 2개(light/dark)을 골라서 둘 다 다른 CSS파일으로 생성하도록 빌드스크립트를 수정.\n… chroma style gallery 참고해서 원하는 스킴을 지정했다. … Hugo config.toml-에 “공식”-설정키는 markup.highlight/style-이었는데, “비공식”-설정키 lightStyle / darkStyle-을 추가하고, 원래의 “공식“설정키는 무시하기로 했다. color-mode 전환시에 매칭되는 CSS파일을 페이지에 로딩하도록 JS. ㅎㅎ 상당히 hacky하지만 잘 동작한다.\n1 2 3 4 # config.toml [markup.highlight] lightStyle=\u0026#39;solarized-light\u0026#39; darkStyle=\u0026#39;solarized-dark256\u0026#39; 1 2 3 4 5 6 7 8 9 # Makefile chromastyles: hugo gen chromastyles \\ --style=`cat config.toml | perl ./scripts/toml-get.pl markup highlight lightStyle` \\ \u0026gt; static/css/chroma.light.css hugo gen chromastyles \\ --style=`cat config.toml | perl ./scripts/toml-get.pl markup highlight darkStyle` \\ \u0026gt; static/css/chroma.dark.css …위에서 config.toml-파일의 특정 설정키를 읽어서 hugo gen chromastyles 명령에 먹여주는 Perl스크립트는:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/env perl # # toml-get.pl # use strict; use warnings; use TOML; use Data::Diver qw(Dive); my $slurped = do { local $/; \u0026lt;STDIN\u0026gt; }; my ($t, $err) = TOML::from_toml($slurped); die $err if $err; print Dive($t, @ARGV); Data::Diver 사용해서 설정키 하위경로 접근을 커맨드라인에서 편하게 받도록 했다. …직접 스크립트를 고정해서 짜주거나 않아도 되어서 이것도 좋아하는 Hack🪓. 2\n그리고 마지막으로 JS쪽에서 테마에 따라 해당 문법강조 테마에 따른 CSS파일을 로딩해줬다. 👉 [SO] How to load in an external CSS file dynamically?\nWrap Up darkmode.js (기존) 새로운 방식 ❤️+1 적용이 쉽다. 😥-2 색상팔레트를 정의해야함. ❤️+1 darkmode 색상을 지정할 필요 없다. (자동으로 inverse색상으로 표시) ❤️+1 전환 애니메이션이 멋있다 😥-1 그런거없다.\n하지만 원하면 만들수도 있을거 같긴하다.\n(CSS animation and/or JS으로 전환시 효과) 😥-1 css이외에 darkmode.js 초기화시에 배경색 전달해줘야 ❤️+1 CSS만으로 끝. 깔끔. 😥-1 inverse 색상이 가끔 괴랄하다 ❤️+1 조절가능.\n이젠 CSS색상을 선택한 내 책임이다. 😥-1 페이지 로딩시 flash 현상이 생긴다 😥-1 브라우저캐시에 없는 페이지를 로딩할 때에 발생할 수 있음. (OS/브라우저 prefs와 local-storage에 저장된 color-mode이 서로 다른 경우) ...darkmode.js보단 가볍게 사라짐. 😥-1 페이지 스크롤시 아직 덜 칠해진 부분이 보이기도 한다 ❤️+1 그럴가능성이 없음. 그리고 무엇보다, 재밌었다.\n땀의 가치 100%! 🧑‍🌾 Footnotes 1 모오던 웹브라우저 다이스키다요💖\n2 https://thethreevirtues.com/\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/young40er-hugo-theme-1st-rel/","title": "👦 “영포티”(“young40er”) hugo theme 공개",
     
     "tags": ["webdev", "css", "sass", "js", "javascript", "hugo", "theme", "archie", "young40er", "release", "first"],
     
 "description": "모두가 염원해온 스윗영포티를 위한 위대한 테마가 탄생했다.",
 "contents": " 그간 심혈을 기울여 작업해온 테마를 공개하기로 결심했다. 힘든 결심이었지만, 나 또한 한사람의 ‘영포티’로서 大義를 위해 어쩔 수 없었다.\n👉 Github Repo.\n자랑스러운 스크린샷 모음 뿌듯하다. "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec16--03-ping/","title": "🔤 hover 애니메이션 지정해봤다",
     
     "tags": ["blog", "blogging", "sass", "css", "animation", "effect", "hoverjs"],
     
 "description": "역시 애니메이션이 있는편이 보기 즐겁다.",
 "contents": " 블로그에 점점 뭔가 덧붙여 나간다. 다행히 sass 컴파일러가 똑똑해서 배포용 css이 엄청커지진 않았다. ㅎㅎ\n(마우스🖱️를 올려보세요, 호랑나비🦋의 행운의 기운이 함께할겁니다.) …이제 좀 자제해야겠다.\n🎹 BGM: Love Bites (So Do I) / Halestorm\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec16--02-ping/","title": "😱 Emacs 일기: vi-mode은 그만 쓰고, windmove은 쓰기 시작",
     
     "tags": ["evil-mode", "vim", "vi", "emulation", "layer", "spacemacs", "doomemacs", "windmove", "ace-window", "emacs", "editor", "ansi-term", "keybinding", "general.el", "hydra", "leader-key", "defhydra"],
     
 "description": "",
 "contents": " vi emulation-layer: evil-mode을 그만 쓰게됐다 이맥스는 거의 20년 넘게 써온거 같다. 물론 예전엔 지금보다 훨씬 더 제대로 이해하고 쓰진 못했었다.🥟 그리고 evil-mode-도 10년 넘게 써온거 같다.\n이맥스를 다시 메인으로 계속 써오면서, 처음엔 Spacemacs / doomemacs 같은 preconfigured된 것들을 적용해 쓰면서 익숙해져 갔던거 같다. (이미 Vi/Vim은 계속 써오고 있었으니까)\n그런데 계속해서 뭔가 키바인딩이 이상하다는 느낌을 받아온거 같긴하다. 그도 그럴것이, 좀 다른 major-mode마다 다른 키바인딩을 vi/vim스럽게 맞춰주는 evil-collection-으로 맞춰주며 동작하는데, 이게 항상 좀 일관성이 있기는 어려운 것 같았다.\n예를 들어, magit, eshell, sly/slime 특히 realgud 같은 모드들이랑은 evil-mode이 불편했었다.\n그러다가 문득 아예 evil-mode을 끄고 기본이맥스 키바인딩만으로, 그걸 조금 확장해서 쓰기 시작했는데, 오히려 가볍고 좋았다. 어차피 이맥스 키바인딩 자체는 이미 오랬동안 익숙해져 온 것이니까.\n가장 불편한 점은 normal-mode / insert-mode 구분이 없어서 언제든 무슨키가 입력되면 바로 버퍼가 편집된다는 근거없는 Vi/Vim중독증상이다. 🫠\n아마 앞으로도 계속 이렇게 쓸거 같다. 그래도 정말 vi/vim-keys이 필요하면 그때 toggle해서 evil-mode을 쓰거나, emacs에 내장된 viper-mode을 써도 될테니까…\nEmacs 기본키바인딩 + 조금씩 확장해서 쓰기: hydra, which-key evil-mode 🙈 + general.el1 ⭐ -으로 예전엔 다른 emacs-layers들처럼 쓰려고 하다가 내겐 더 불편했다.\n그래서 그냥 대부분은 이맥스 키바인딩에 만족하고, 또 계층으로 키바인딩을 나눌 때엔 defhydra-으로 정의해서 쓰고 있다. 이렇게 하는게 나는 더 편안하다.\ngeneral.el의 공식이미지(왼쪽) / hydra의 공식이미지(오른쪽) (이 이맥스 패키지들은 어째서 다 이모양일까 싶다.) 창선택/이동: ace-window + windmove도 사용 편하다 이맥스를 쓸 때에, 한 frame/tab 안에서, 여러 window으로 나눠서 코딩을 하거나 해왔는데, 이것도 꽤 불편하게 써오던 것 같다.\nevil-mode을 사용하면, Vim스럽게, Control-W h/j/k/l 같은걸로 윈도포커스전환이 쉬웠는데, 이게 없어져서 C-x o / ace-select-window 쓰니까 매번 창번호 눌러줘야 하고 좀 그랬다.\n그래서 좀 알아봐서, emacs 내장 windmove을 키바인딩해서 방향키조합으로 바로 움직일 수 있도록 했다. 좀 편해졌다.\nFootnotes 1 “leader”-key을 제공하니까… “장군님.el”이라고 프로젝트 설명에. 쿨럭.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/2025-12dec16--01-ping/","title": "👒 Hugo 블로그 디자인 고쳐나가면서 생각",
     
     "tags": ["blog", "blogging", "hugo", "css", "sass", "scss", "js", "javascript", "html", "sh", "bash", "gmake", "makefile", "esbuild", "perl"],
     
 "description": "",
 "contents": " 2024년엔 “CSS/JS에 의존하지 않는 블로그를 만들자”-였다가, 조금씩 뜯어고쳐 나갔다. 사용편의나 읽기 적당하도록 색상과 정렬정도를 고쳐나갔다.\n그러다가 2025년 올해엔 아예 Hugo theme을 새로 정리해서 다시 만들었다. 이전에 해오던 것들을 더 정제하고 구조를 만들어 나갔다.\n처음엔 다른 CSS프레임웍1 을 더 가져와 쓰려고 고민하다가, 그냥 이대로 적당한거 같아서, 가장 가벼운 상태에서 진행해왔다.\n생각보다 Responsive / Mobile 지원은 재밌었다.\n다만, 외양요소가 조금씩 변경될 때마다, 결국 회귀적인 검토과정이 필요한데, 이걸 Layout 체크, BrowserStack와 같은, 혹은 그런 빌드스크립트를 만들어서 스크린샷 비교 기능 같은걸 자동화 테스트하면 유리하겠단 생각. 물론 개인 정적사이트 블로깅에 그런건 오버킬이지. ㅎㅎ하지만 어차피 취미영역이기 때문에 뭘 어떻게 내가 즐겁고 편하게 한다면 가치가 있을것 같다.\n그리고 다른 일들도 마찬가지지만, 대부분은 자기가 뭘 쓰고 있고, 뭘 하려고 하는지를 잘 이해하고 알아차리는게 정말 중요한것 같다. 실망스러운 경우엔, 그걸 스스로 그러고 싶어서, 그래야 자기 기분이 충족되니까 오해하거나, 아니면 정말 이해의 범위와 깊이가 그래서 제한되는 경우도 종종 있을 것 같다. 하지만 실상을 잘 살펴보면, 더 적합하고 단순하고 효과적인 것들을 찾아내거나 재발견해야 했던거 같다. 그리고 그게 즐겁다.\nFootnotes 1 Bootstrap 5, Tailwind CSS, Bulma을 고려했었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/hugo+esbuild/","title": "☘️ esbuild js build for blog",
     
     "tags": ["esbuild", "deno", "bundling", "blogging", "blog", "mjs", "cjs", "javascript", "npm", "concurrently", "makefile", "hugo", "npm", "npx"],
     
 "description": "",
 "contents": " 그간 자바스크립트를 이 Hugo으로 생성하는 블로그에 사용하면서, 여기저기 그냥 \u0026lt;script\u0026gt;-태그를 써왔었다. 한군데로 정리하기도 뭐하고, 자바스크립트를 쓰는 기능은 메인이 아니라고 생각해와서.\n검색, darkmode만 자바스크립트를 사용하고 조금씩 붙여놓은 easter eggs도 사용하니까 조금씩 늘어난 것 같다.\n그냥 cdnjs 같은걸 써도 되겠지만, 그냥 패키지로 내려받아서 아예 내 블로그에 올리는게 남에 cdn bandwidth을 줄여주는 도리인 것 같았다…만 github cdn의 bandwidth은 여전히 사용하는 것. 😜\n여튼, 그렇다고 사용하는 의존성(예: jquery)의 크기를 줄여서 내보낸 것도 아니고 점점 의존성관계가 복잡해지는거 같아서 정리를 시작해봤다.\n(아참!) CSS은 Hugo / SCSS 컴파일으로 관리하고 있다 즉, 다른 일반적인 웹앱 프로젝트와 달리 별도의 이미지 에셋이나 CSS관련 빌드를 신경 쓸 필요가 없다는 뜻. 이하의 내용들도 그걸 염두에 두고 고려했다.\n🥡 첫 시도: deno bundle 최초 시도는 그냥 deno bundle-기능을 사용하는 것: 👉 https://docs.deno.com/runtime/reference/bundling/\n[장점👍] 그냥 mise 같은걸로 deno만 설치하고 바로 적용가능. [장점👍] watcher-mode 지원한다.\n입력파일, 의존성이 변경되면 자동으로 rebuild해줘서 개발할 때 편리하다. [장점👍] 적당히 빠르다 + minification도 잘 지원한다.\n찾아보니까, tree-shaking도 해주고 할건 다 하는 느낌이었다. minified : 570KB =\u0026gt; 280KB 정도로 줄여줌. [단점👎] 하나의 output만 지원가능.\n…어차피 하나의 bundle.js-만 생성하는데 사용하고 있지만😅 장점으로는, 확실히 로딩자체가 더 가벼워진 느낌적 느낌이 들어서 쾌적했다.\n그러나 문득 이걸로 만족해도 되겠는가 하는 강박이 들었다.\nDukkha! 그래서 요즘 누구나🐕🐮 사용한다는 Vite을 시도해봤다.\n😰 실패: npm + vite 다른 웹애플리케이션 프로젝트에선 개인적으로나 일터에서 조금씩 써왔지만, 막상 적용하고 나니까… 후회스러웠다.\n(장점은 적지 않겠다: 어차피 지원할거 다 지원하니까)\n단점은:\n의도하지 않은 html/image 에셋들도 번들링한다고 난리였다.\n오히려 그러지 않도록 뜯어 말리는 설정이 너무 컸다. ㅋㅋㅋ node.js package.json type=module|cjs 광란의 블루스가 다시 살아났다. 어차피 live-reload 같은 \u0026#34;vite server\u0026#34;-에서 기대하는 기능들, \u0026#34;hugo server\u0026#34;-이 이미 제공하고 있어서 있어도 무의미했다. XXXXXX, XXXXXX never change... 굳이 내 개인블로깅을 하는데, vite 같은 누구나 쓰지만, 남들이 쓴다니까 옆사람이 써서 나도 써야 하는… 그 기술이 꼭 그자체로 나쁜건 아니지만, 그런 상황과 순환은… 굳이 …괜찮았다. 🙂‍↔️1\n‍🔥 재시도: deno run npm:esbuild 그래서 그냥 deno에서 esbuild 실행하는걸로 바꿈: …하지만, deno import와 node_modules/-에 위치하기를 기대하는 esbuild와의 차이로 제대로 동작하지 않았다. 😥\n그래서 그냥 npx/npm으로 재시도.\n🐦‍🔥 최종판: npm + esbuild [장점👍] 빠르다\nesbuild 자체가 가벼워서 좋은거 같다. 다른 parcel, vite보다 가벼울거 같다. [장점👍] 다수 입력=\u0026gt;출력 설정 쉽다. [장점👍] deno-bundle보다 용량도 준거 같다: 280KB =\u0026gt; 200KB [단점👎] 모르겠다. 1 2 3 4 5 6 7 8 9 10 11 # Makefile NPX ?=npx ESBUILD_ADDOPTS ?= bundle-js: -$(MKDIR) -pv ./static/js $(NPX) esbuild --bundle --minify --target=chrome58,firefox57,safari11,edge16 $(ESBUILD_ADDOPTS) \\ ./js/bundle.mjs --outfile=./static/js/bundle.js https://esbuild.github.io/getting-started/#bundling-for-the-browser 참고해서 베껴왔다.\n🎁 보너스: Makefile-와 npx concurrently 그리고 추가적으로 Makefile-에서 hugo 서버를 시작할 때에, 동시에 \u0026#34;esbuild watcher\u0026#34;-도 concurrently-을 이용해서 실행하도록 추가했다.\n1 2 3 4 5 6 7 8 # Makefile # ...생략 watch-bundle-js: ESBUILD_ADDOPTS=--watch $(MAKE) bundle-js serve: $(NPX) concurrently \u0026#39;hugo server\u0026#39; \u0026#34;$(MAKE) watch-bundle-js\u0026#34; ✏️ [EDIT] “하지만 hugo은 js.Build(esbuild)을 내장하고 있는걸요?!” [2025-12-20 Sat]\n그렇게 쓸 수 있으면 좋은데 몇 가지가 내 “취향”에 맞지 않아서 그냥 Makefile + esbuild + concurrently 방식이 더 편하다:\n무엇보다: 내가 사용하는 theme-에 적용하는 방식으로, 나는 config.toml-에서 주입하는 방식을 쓰는데, 이걸 많이 바꾸지 않는 이상은 매 페이지 생성 때마다 esbuild을 실행하려고 해서 마음에 들지 않았다. node_modules 의존성 및 내가 작성한 파일들 의존성을 연결해주는데에 난 포기했다. js.Build-을 위해 Resource-을 얻어야 하는데, 이건 assets/-디렉토리에 위치해야함. 언젠가 나중에 원하면 바꿀지도 모르겠지만 일단은 이대로 쓰자. Footnotes 1 (그리고 더 골때린건 그걸 써야한다고 옹호하는 emotionally attached한 사람은, 아는 node.js/typescript 잘한다는 형이/웹사이트가/어디어디서 그렇다고 \u0026#34;카더라\u0026#34;라고 해서… XXX/YYY이 나빠잉,한다고 카더라 해서…라는게 이유인 경우라면… 더 안습)\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/hands-of-necromancy/","title": "😵 Hands of Necromancy와 영포티의 추억벤또 🍱",
     
     "tags": ["gaming", "fps", "boomer-shooting", "young40", "90s", "건잠머리", "shareware", "cdrom", "linux", "slackware", "netbsd", "openbsd", "wolf3d", "duke3d", "heretic", "hexen", "catacomb-3d", "apogee", "추억", "갬성", "doom", "doom2", "linus", "486", "486dx2", "bfg-9000", "steam", "gzdoom", "ion-fury", "hands-of-necromancy", "fps"],
     
 "description": "",
 "contents": " 👉 Steam 페이지: Hands of Necromancy\n예전에 사놓았다가 최근에 다시 플레이.\n사양, 지원 GTX 1050+ 이상은 되어야 잘 동작할거 같다. SteamDeck / Linux 기본 지원 Gamepad 지원: 그런데 그냥 마우스+키보드로 해도 편함. boomer-shooting의 고전적인 키맵이랑 완벽히 동일. 아쉽지만 한국어는 지원않음. Heretic와 Hexen, 그리고 Doom 고전적인 boomer-shooting / heretic, hexen을 연상시킨다.\n어린 Doom, Doom II 빠돌이였던 나는1 어떻게(???) 헤러틱을 구했던거 같다. 아마도 Shareware였거나, 어쩌면 운이 좋아서 Full version이었던거 같다. 당시 사양이 그렇게 좋지 않은 컴퓨터를 쓰고 있었는데(CPU: 486DX2 50Hz, RAM: 4MB), 펜티엄을 가진 친구에게도 돌려보라고 💾 3.5\u0026#34; 디스켓으로 복사해주곤 했던 것 같다.\n그리고 그 이후에 Hexen도 비슷하게 구해서 플레이를 했었었다.\n그래픽이나 에셋은 전반적으로 그때 당시 내 시각으로 봐도 둠의 완성도보다 낮아 보였다.\n하지만 둠보다 뭔가 산뜻한 물의 이미지라던가, 하늘을 날 수 있다거나 시점이 진짜 3D인 것 마냥 조절이 가능한 것들은 신선했다.\n나중에 알게 된 것이지만, 실제로 3D 렌더링은 아니지만, 그래도 3D 공간좌표 안에 납작한 종이인형 같은 캐릭터들을 세워놓은 것 뿐이었던 구현이었던 것 같지만, 그래도 둠의 (당시로서는) 점프도, 수영도 없고, 시점도 고정되어 있던 것에 비하면 정말 어지러울 정도로 자유로운 기분이었던 것 같다.\n포스터 이미지만 봐서는 기합차다 그렇다. 헤러틱, 헥센의 포스터 이미지만 봐도 원조기합의 \u0026#34;Doom (1993)\u0026#34;의 구도를 연상시킨다.\n원조기합: 10점 만점에 12점인 사나이 …하지만 당시엔 솔직히 둠만큼 열심히 플레이 하지도 않았던 것 같고, 맵, 퍼즐을 다 풀어서 진행해 내지도 못했던 것 같다. 사실 치트키를 먼저 구해서 그냥 맵을 돌아다니며 학살하면서 놀기만 했던거 같다. …치트키는 게임의 재미와 흥미를 급격히 잃게 만드는 진리를 당시엔 깨우치지 못했었다. 🙈\n하지만 특유의 게임의 분위기: 마법사와 괴물들, 마법과 판타지풍의 세계는 매력적이었었다.\nHeretic 스크린샷 울펜슈타인3D의 습기찬 곰팡이 냄새나는 나치스 기지의 느낌이나 클래식 둠의 방사능 오염되는 느낌의 맵들과는 다른 공간을 돌아다니며 놀 수 있었으니까.\n울펜슈타인3D(왼쪽)과 DOOM의 스크린샷(오른쪽) 그리고 다른 Duke3D이나 스타워즈: 다크포스 같은 둠 이후로 터져나온 수 많은 fps들도 기억이 난다. 둘 다 각각의 특징이 있고, 또 다른 걸작들이었지만.\n괴작: 카타콤 3-D🪦 ─와 \u0026#34;건잠머리\u0026#34; CD-ROM 둠에 중독된 이후에 그런 유사한 게임을 찾아서 계속 플레이하려고 들었던 것 같다.\n그중에 하나가 카타콤 3-D였었다: 👉 위키백과\nCatacomb 3-D 스크린샷\n- CGA 느낌의 팔레트가 너무 쩔어서 👁️‍🗨️안구가 아프다 얻어낸 경로는 아마도 기억이 \u0026#34;건잠머리 쉐어웨어 CD-ROM\u0026#34;이었던거 같다.\n뉴스기사: 전자신문: 건잠머리컴퓨터연구소, 국내에 셰어웨어 돌풍 주역 (발행일 : 1995-01-21) 건잠머리 CD으로 리눅스도 처음 접했었고, Turbo C 2.0 이외에 다른 씨언어 컴파일러를 해보고 싶어서 시도를 했었던 것 같다. 지금 생각해보니 리누즈형에게 크게 낚였던거 같다.\n리누스大兄\n당시 국내잡지에 실린 존안사진이다... 미화는 1도 없었구나 하옇튼, 다시 게임 얘기로 돌아와서, 위키백과에서도 설명하듯이, 카타콤은 울펜슈타인3d 엔진의 프로토타입을 사용했었다고 한다. 그런데 내 기억 보정인지는 몰라도, 그렇게 나쁜 경험은 아니었었다.\n지하묘지의 개념이나, 서구의 로마시대의 억압받는 특정종교✝️에 대한 이미지가 내 머릿속엔 없었기 때문에, 정말 낮선 세팅의 세계관이었던거 같다. 그리고 지면을 뚫고 튀어나오는 좀비들은 어린 내게 자극 그자체였었다.\n아마 조만간에 abandonware 같은 곳에서 구해서 다시 플레이 해볼거 같다.\n🧟🧟‍♂️🧟‍♀️ 다시 Hands of Necromancy 얘기 ↩️ 게임엔진은 GZDoom이라고 한다.\n클래식 둠을 고사양의 세팅, 화면 효과 등을 켜고 플레이하기 위해 종종 사용해본 오픈소스 엔진.\n첫 인상은 비운의 Build 엔진 게임을 다시 활용해 출시하는 최근 boomer-shooting 게임, Ion Fury 같은 게임이랑 유사하게 느껴진다.\n그런 이유는 내 생각엔:\n일부러 픽셀이 튀어 보이게 만든 그래픽 에셋들, 그러면서도 맵의 구성은 완벽한 3d 방식이고, 시점의 전환도 자유롭고, 날아다니거나 기어다니는 적이 튀어나와서 마우스를 제대로 활용해야 한다. 🖱️ 그리고 종종 튀어 나오는 ``납작종이인형\u0026#39;\u0026#39; 느낌의 데칼들. 그리고 솔직히 Ion Fury을 처음 플레이 할 때보다 솔직히 친절하지는 않았다. 왜냐하면, 이온퓨리의 경우에는 대놓고 어떻게 움직일지, 어디로 가야할지 보였던거 같다. 반면, 핸즈오브네크로맨시는 좀 많이 돌아다녀 봐야 하고, 좀 더 많이 뒤적거리면서 게임과 맵에 익숙해져야 진행이 수월했었다.\n이온퓨리나 전통적인 퀘이크 I/II 시리즈와 같이 에피소드의 맵들을 엮는 허브 역할의 맵으로 다시 되돌아가고, 열쇠를 모아서 문을 따고 하는 식의 전개들은 좀 혼란스럽다.\n하지만(!!!) 그럼에도 맵은 충분히 아름답고, 돌아다니면서 풀어나가는 재미가 있었다.2\n이제 진짜 장점과 재미에 대해서 이야기하자.\n[재미] 동료만들기 🧟‍♂️ (강제) 제목처럼(\u0026#34;네크로맨서\u0026#34;3), 내가 죽인 적 몬스터를 다시 소환해서 내편으로 만들 수 있다.\n직접 조종을 할 수 있는 것은 아니지만, 그래도 나를 위해 맵을 돌아다니고, 내 적군들을 미리 알아서 청소해주는 건 정말 편하다. 적당히 소생해서 부릴 수록 전투 자체가 쉬워지는 요소다.\n아쉬운건, 나를 따라오는건 좋은데, 내가 잠수하거나 맵에 깊은 물이 있으면 거기 빠져서 헤어 나오지 못하는 경우가 많아서 AI이 좀 아쉬웠다.\n[재미] 변신 🐍 변신주문을 얻을 수 있고, 변신주문 자체가 맵/퍼즐을 푸는데 필수적으로 필요하다. 변신해서 쓸 수 있는 능력에 따라 맵의 특정 요소들을 조작할 수 있는 제약이 걸려 있기 때문.\n그런 이유 이외에도 그냥 재밌다. 변신해서 얻을 수 있는 장점을 이용해서 맵을 더 신나게 샅샅히 뜯어먹을 수 있다.\n\"이르케 변신하면 기부니 조크든요.\"\n(출처 = 한국일보: [영상] X세대가 말했다 \"이르케 입으면 기부니 조크든요\") [재미] 사악함 🙊 죽은 몬스터를 소생시켜서 죽음으로부터 영원한 안식을 얻지도 못하도록 착취하고, 원하는 능력을 갖춘 형태로 변신도 하고, 투명인간이 되어 기게스의 반지를 얻은 것처럼 행동할 수 있다.\n그리고 내가 등장할 때마다, 적 인간형 몬스터들은 \u0026#34;사악한 마법사다!\u0026#34; / \u0026#34;죽여라!\u0026#34; ─같은 대사를 외쳐주며 나의 등장에 환호해준다. 😅4\n전투 난이도 ⚔️ 전투난이도는 그렇게 높지 않다. 다만 몇 대 맞으면 데미지가 생각보다 커서 아주 아프다. 잘 피하면서 무빙하고 쏘고, 또 소생시킨 몬스터에 의지하고 해야 하는 부분이 더 큰 것 같다.\n얻어내는 무기도 전통적인 WOLF3D, DOOM와 같이 갑지기 쓸어버리는 BFG-9000 같은 느낌의 레벨링은 아직 없다.\n오히려 얻는 무기들은 단조로 몇 가지 종류인데, 그걸 적에 따라서, 상황에 따라서 잘 이용하는게 더 전투를 재밌게 해준다. 예를 들어, 강한적이지만, 특정한 속성이나 효과를 일으키는 무기에 더 약하거나… 상성이나 불러일으키는 밀어내기 같은 물리적 속성에 따라서.\n생각보다 무기 효과도 잘 만들었다. 그래서 슈퍼무기를 꼭 필요로 하게 만들지는 않는다…만 생각해보자: 마법검이나 파이어볼 지팡이, 토네이도 주문서 …등등만 해도 이미 현실에 비춰 생각해보면 쩌는거 아닐까. 🪄 (…다른 게임들의 너무 쩌는 화려한 무기들에 너무 익숙해져서 둔감해진게 아닐까)\n그래서🤯 적어도 나같은 취향의 사람이라면, 플레이할 가치가 있는 게임 같다. 그리고 처음엔 좀 투박하고 익숙해지기 어려워도🔰, 조금 인내심을 갖고 익숙해져 나갈수록 게임에서 발견할 수 있는 즐거움 중 하나인, 새로운 능력 등을 발견해 나가는 재미와 맵의 퍼즐을 푸는 재미가 충분한 게임.\n그리고 무엇보다: 이런 세계관/세팅을 탐험해 나가는걸 좋아한다면 추천한다. 어둡고 안티히어로적이고, 고딕풍이고 그러면서도 배경에선 편안해지는 류트연주가 살살 흐른다. 🖖\n한국에선 별로 인기가 없을거 같은 취향인거 같기도 하다.😥…만 2탄도 발매/세일하고 있다: 👉 스팀: Hands of Necromancy II\nFootnotes 1 당시 아마 \u0026#34;국민학생\u0026#34; 내지는 중학생이었을 것 같다. 지금 봐도 그렇게 교육적으로 훌륭하지 못한 게임들이다. 🔫👾😱💀\n2 아직 다 플레이를 마치지 않았다. 이제 에피소드1 부분을 거의 다 깨어가고 있다. 3 위키백과: 네크로맨서\n4 현실에서의 나는 충분히 보편적이고 윤리적으로 살아가고 있다. 이 글을 읽는 사람이 엉뚱하게 게임세계에서의 재미를 갖고, 오해하지 않았으면 좋겠다. 😆\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/factor-and-io/","title": "🚥 (주절주절) Factor와 Io",
     
     "tags": ["factor", "factorcode", "io", "iolanguage", "language", "prototype", "prototype-based-inheritance", "forth", "stack", "concatenative", "functional", "object-oriented", "smalltalk", "lua", "self-language", "jedit", "minecraft", "metaprogramming", "opensource", "korean", "euckr", "euc-kr", "johab", "iso-2022-kr", "ruby", "ioke"],
     
 "description": "",
 "contents": " Factor와 Io 모두 예전에 덕질하던 프로그래밍언어.\n이번엔 추억놀음이나 포스팅해보려고.\nFactor https://factorcode.org/ https://en.wikipedia.org/wiki/Factor_(programming_language) 팩터는 Functional, Concatenative programming언어인데, Forth와 같은 방식의 평가규칙을 가졌지만, Semantics은 Smalltalk이나 Lisp 같이 고수준의 추상화를 작성하기 적절했었다. 그리고 Native compilation + Image-based 시스템이어서 커먼리습이랑 비슷하게 사용도 가능해서 좋았었다.\n오랬만에 \u0026#34;ego searching\u0026#34; 해봤다 😶‍🌫️ :\nhttps://docs.factorcode.org/content/vocab-io.encodings.euc-kr.html 같은 문서를 어떻게 요악해서 AI이 보여주는지 잘 모르겠다, 신기할 정도다.\n\u0026#34;Hallucination 🫥\u0026#34;도 좀 있긴하다. 다른 부분은 다 맞는거 같은데(ㅋㅋ), 윈도 빌드를 제공하거나 했다는 언급은, 내가 그랬었나 싶다. ㅎㅎ\n다시 원래 이야기로 돌아와서, Factor + Emacs은 FUEL이란 이맥스확장이 지원되어서, 마치 커먼리습의 SLIME 혹은 Sly-처럼 편안하게 사용하기 좋았었다.\n그리고 Forth, Smalltalk, Lisp처럼 DSL을 만들기도 유연하고 명확한 문법이어서 딱 그렇게 쓰려고 했던거 같다.\n1 2 3 4 USING: dice formatting ; ROLL: 2d8+4 \u0026#34;You do %s points of damage!\u0026#34; printf …위에 보이듯이 2d8+4 같은 부분들이 dice 모듈에서 제공하는 DSL.\n그리고 커먼리습처럼 compile-time meta-programming이 자연스러운 언어여서, 실제로 데이터파일을 읽거나 하는걸 컴파일시점에 처리하고, 그거에 따라 코드를 미리 생성해서 런타임엔 최적화된 코드로 실행할 수 있도록 메타프로그래밍이 가능했다. (커먼리습처럼.)\n재밌었고, 많은 부분이 커먼리습의 그것과 유사해서 더 좋아했던거 같다.\n지금은 글쎄, package manager도 없고, 코드 컴파일속도도 오히려 커먼리습이 더 빠른거 같아서 굳이 끌리지는 않는다. ㅎㅎ 이걸 더 발전시켜서 사람들과 같이 재밌게 쓰고 싶다는 마음도 별로 들지 않는다. 나는 그렇게 하라면 할수도 있겠다,싶게 아직도 좋아는 하지만.\n이후에 다른 Concatenative programming languages이 연구와 시도되는거 같지만, 대부분은 이렇게라도 성장시켜내지 못한거 같다.\n사족인데, 아마 원 Slava Pestov 원래 프로젝트의 시작목적은 Java/JVM 상에서 실행될 게임을 위한 스크립팅언어로 시작했다고 한다. Forth / Stack-based 언어가 그렇게 시작하기 좋지 싶다. ㅎㅎ그런데 어느새 네이티브컴파일이 가능하고 ㅎㄷㄷ…\n하옇튼 Slava Pestov의 jEdit도 한 때 정말 좋아하던 코드편집기였었었다.\n만약 게임을 만들던 그 시도에 더 집중했었더라면 Minecraft처럼 Java으로 짠 성공적인 게임이 되었을까 대체역사를 상상도 해본다. ⛏️\nIo https://iolanguage.org/ https://en.wikipedia.org/wiki/Io_(programming_language) https://wiki.kldp.org/wiki.php/IoLanguage/Tutorial 또다른 추억놀음 언어는 Io. 이건 개인적으로는 코딩퍼즐을 푸는 장난감으로 쓰거나 한국어으로 튜토리얼을 번역해 공개하거나 하는 정도로 익혔던거 같다.\n객체지향이지만, Lua, JavaScript와 유사한, 하지만 많이 다른 Prototype-based OO였고, Message-passing OO + Lazy evaluation이어서 정말 유연했다.\n예를 들어서, 클래스-메서드 선언, Control-structure 등이 따로 Keyword이 없고 그냥 메서드로 구현되어 있거나(스몰톡처럼), 리습처럼 유연한 매크로를 만들 수 있었었다.\n그 이후에 Ioke 같은 언어을 기대하긴 했지만 이것도 조용해서 ㅎㅎ\n역시 마찬가지로 커뮤니티나 패키지매니저가 따로 없고, 웹프레임웍 등이 공개된게 있지만 15~17년 이상 그대로여서 다시 손에 잡을 생각이 들지는 않는다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/pgrp-rhapsody/","title": "🐮 process-tree 정리의 rhapsody",
     
     "tags": ["posix", "unix", "linux", "kill", "signal", "pgrp", "pid", "pgid", "sid", "procfs", "freebsd", "osx", "darwin", "yt-dlp", "aria2", "aria2c", "sigint", "sigterm", "ipc-open3", "perl", "fork", "exec", "system", "cgroups", "docker", "k8s", "kubernetes", "plan9", "vfs", "windows-api"],
     
 "description": "",
 "contents": " 발단 상황배경:\n내 프로그램은 순박하게 yt-dlp을 실행한다. 실행된 yt-dlp은 또 내가 지정한대로, 실제 다운로더로서 aria2c을 실행하고, 이렇게 실행된 aria2c은 다시금 내가 지정한대로, 충실히, 자기자신을 10개 정도의 동시프로세스으로 복제하여 병렬실행된다. …그런데…\n갑자기 Control-C(SIGINT)을 눌러 내 프로그램을 종료했다. 😕 yt-dlp 프로세스와 그 하위 aria2c 프로세스 10여개는 종료되었을까? … yt-dlp, aria2c에 기대하는 behavior은: 그렇다-이다.\n그런데 그렇지 않을 경우도 있을테고(순전히 각 애플리케이션의 처리에 따를테니까, 플랫폼(예: linux / freebsd)에 따라 그렇게 되지 않는 경우도 있다. 😑\n그렇다면, 이런 상황을 제대로 처리하는 \u0026#34;내 프로그램\u0026#34;을 만들 수 있을까? 🤔\n[접근법] 하위프로세스를 검색하여 다 정리 너무 당연해 보이고, 심지어 자연스러운 발상에 기반한 접근법.\n모든 프로세스-는 자신의 PID (Process ID)-와 부모프로세스의 PPID (Parent-)을 갖고 있으니, 내 프로그램의 하위프로세스 PID와 그 PID을 부모로 하는 모든 프로세스를 찾아서 종료하면 되겠지.\n그런데… 그 \u0026#34;모든 프로세스\u0026#34;, 혹은 \u0026#34;자식 프로세스\u0026#34;를 enumerate하는 일이 플랫폼마다 다르다…🌋 baam! 히밤쾅.\nPython도 \u0026#34;배터리\u0026#34; 표준라이브러리에 없고, psutil 사용\n어째서, 별거 아닌거 같은 라이브러리가 gh-stars⭐이 1.1만개나 받았을까…하고 내가 하려는 짓을 의심해 보아야 한다. \u0026#34;Elegantly get list of descendant processes\u0026#34; 스택오버플로우\n\u0026#34;우아하게\u0026#34; 하위프로세스 목록을 구하는 방법에 대해 물었더니, ps, pstree, pgrep 등의 유닉스 도구를 실행해서 그 출력을 파싱하라는 \u0026#34;우아한가?\u0026#34; 싶은 답변만 달려 있다. 실은, 정답은 아마 이럴 것 같다:\n리눅스라면,\nprocfs /proc-을 디렉토리/파일 순회를 하면서 알아서 PID/PPID 정보를 모아서 사용해라. https://docs.kernel.org/filesystems/proc.html : /proc/${PID}/status 파일에 Pid:, PPid: 필드가 친절하게 있다.🤣 FreeBSD 쪽이라면,\n리눅스와 같이 procfs을 지원한다!\n하지만, 이걸 설정해놓는건 선택적 사항이므로… 🚷 https://man.freebsd.org/cgi/man.cgi?procfs kvm_getnprocs(3) 함수를 사용한다. Windows이라면: EnumerateProcesses 함수를 사용한다. Mac OS X이라면,\nNSWorkspace / NSRunningApplication 클래스를 사용한다. (AppKit)\nhttps://stackoverflow.com/a/3338118 https://developer.apple.com/documentation/appkit/nsworkspace/runningapplications?language=objc BSD sysctl-을 쓰는 방법도 있는거 같지만, 이식성과 편의성 면에서는 …AppKit 쓰는거보다 딱히 나을게 없는거 같아서 …넘어가자. 그렇다. psutil 같은 별도 패키지가 아예 따로 있고, \u0026#34;Cross-platform!\u0026#34;이라고 마빡에 써붙인데에는 다 이유가 있던 것이다.\n개인적으로 선호하는 방식은(빈정거리기는 했었어도), 특별한 시스템 호출이 필요 없는 procfs 방식으로 노출하는게 맞다고 생각한다. https://en.wikipedia.org/wiki/Procfs …어쨌든 userland 구현 라이브러리에서 호환성 생각 않고 접근하기도 좋으니까.\n내가 좋아하는 것과 상관없이, 현실에선 모든 플랫폼에 적용하기 어렵다.\n그런데, 이런 \u0026#34;하위프로세스의 정리\u0026#34;-같은건 일반적인 상황이라 남들도 충분히 고민을 해왔을 것 같은데, 정말 겨우 이런 수준까지만 가능한걸까?\n[접근법] kill -- -${PGID} 현대의 유닉스는 이런 문제를 위해 (PID 이외에) \u0026#34;Process Group\u0026#34; 개념을 지원한다. 👉위키백과 ..이 글에선 \u0026#34;Session ID\u0026#34; 대신 \u0026#34;Process Group\u0026#34;-만 소개하겠음. (이유는 이후 \u0026#34;차이점\u0026#34; 섹션 참고)\n하옇튼, 이를 위해 kill(1) manpage에선 다음과 같이 설명:\nkill -SIGTERM -123\nSend the signal SIGTERM to process group 123.\nThe signal name or number is required if specifying process groups with a negative PID.\n혹은 다음과 같이 실행해도 된다: kill -- -123\n\u0026#34;-${PID}\u0026#34; 같이 표기하면, \u0026#34;123\u0026#34;부분이 SIGNO인줄 알고 제대로 동작 않으니 ---으로 구분. 보내는 시그널은아마 기본인 SIGTERM.\n💲 PGID을 PID처럼(대신 \u0026#34;-\u0026#34;을 앞에 붙여서), 지정하면 해당 process-group의 프로세스를 종료해준다.\nSession ID와의 차이점? 구글 검색하니 AI이 다음과 같이 정리해준다:\nsetpgrp()-은 현재 세션-에서 프로그램그룹만을 분리. setsid()-은 완전히 새로운 세션-을 시작하고, 현재 터미널(pty등)에서 프로세스를 분리(detached)한다. setid-이 더 격리된 환경을 만들지만, 프로세스 daemonization등에 더 적합. 반면 setpgrp-은 프로세스제어, 즉 내가 하려는 하위프로세스의 정리에 더 적합. (혹은 딱 그 정도에 부합) [실험] process-group 지정해보기 하위프로세스으로 예시로 쓰기 위해, 무한루프 + 1초마다 시각을 찍는 간단한 프로그램을 만들었다:\n1 2 3 4 5 6 7 8 #!/usr/bin/env perl # clock.pl while (1) { print \u0026#34;\u0026#34; . localtime, \u0026#34;\\n\u0026#34;; sleep 1; } (naïve) system() == 👌 1 2 3 4 5 6 7 8 9 #!/usr/bin/env perl # w-system.pl system(\u0026#39;./clock.pl\u0026#39;); __END__ $ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 1916 2444 2444 2444 pts/0 2444 Ss+ 1000 0:00 perl ./w-system.pl 2444 2445 2444 2444 pts/0 2444 S+ 1000 0:00 perl ./clock.pl 위와 같이 짜서 clock.pl 실행하고,\n다른 터미널에서 ps j-을 실행한 결과를 붙여 넣었다: (L-5 이하) PGID=2444으로 동일하게 설정되고, 원 호출PID와 같다. (자동으로 설정됨.) IPC::Open3 == 👌 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/env perl # w-popen3.pl use strict; use warnings; use IPC::Open3 qw( open3 ); my $cmd = \u0026#34;./clock.pl\u0026#34;; my $pid = open3(undef, \u0026#39;\u0026gt;\u0026amp;STDOUT\u0026#39;, \u0026#39;\u0026gt;\u0026amp;STDERR\u0026#39;, $cmd); waitpid( $pid, 0 ); __END__ $ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 1916 2869 2869 2869 pts/0 2869 Ss+ 1000 0:00 perl ./w-popen3.pl 2869 2870 2869 2869 pts/0 2869 S+ 1000 0:00 perl ./clock.pl 이번에는 조금 더 복잡한 경우를 대비해서, IPC::Open3 패키지를 사용해봄. 역시 잘 동작함을 확인. fork + exec == 👌 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env perl # w-fork-exec.pl use strict; use warnings; my $child = fork; if($child){ waitpid $child, 0; }else{ exec \u0026#39;./clock.pl\u0026#39;; } __END__ $ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 1916 3144 3144 3144 pts/2 3144 Ss+ 1000 0:00 perl ./w-fork-exec.pl 3144 3145 3144 3144 pts/2 3144 S+ 1000 0:00 perl ./clock.pl 이렇게도 잘 동작. ㅎㅎ 직접 ⚙️제어하기: setpgrp == 👌 다음처럼 setpgrp 직접 호출해서, 원하는 시점/프로세스에서 pgrp을 새로 시작해도 됨:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env perl # w-fork-exec-2.pl use strict; use warnings; my $child = fork; if($child){ print STDERR \u0026#34;PARENT-PGID: \u0026#34;, getpgrp, \u0026#34;\\n\u0026#34;; waitpid $child, 0; }else{ print STDERR \u0026#34;MY-PGID (BEFORE): \u0026#34;, getpgrp, \u0026#34;\\n\u0026#34;; setpgrp; print STDERR \u0026#34;MY-PGID (NOW): \u0026#34;, getpgrp, \u0026#34;\\n\u0026#34;; exec \u0026#39;./clock.pl\u0026#39;; } __END__ $ ps j PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 1916 4064 4064 4064 pts/0 4064 Ss+ 1000 0:00 perl ./w-fork-exec-2.pl 4064 4065 4065 4064 pts/0 4064 S 1000 0:00 perl ./clock.pl perldoc: setpgrp Windows에서는? setpgrp-은 아마 제대로 동작하지 않을 것 같다.\nCreateProcess API:\nhttps://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags CREATE_NEW_PROCESS_GROUP (0x00000200) The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process.\nThe process identifier of the new process group is the same as the process identifier, which is returned in the lpProcessInformation parameter. Process groups are used by the GenerateConsoleCtrlEvent function to enable sending a CTRL+BREAK signal to a group of console processes. If this flag is specified, CTRL+C signals will be disabled for all processes within the new process group. This flag is ignored if specified with CREATE_NEW_CONSOLE.\n…그리고 흔히 사용하는 TerminateProcess API은 이렇게 동작 않을거 같다. 차라리 taskkill /F /PID ${PID} /T-와 같이 커맨드라인 유틸리티를 사용하라고 하는거 같다. (…그리고 이건 아마도 \u0026#34;프로세스 나열하기\u0026#34;-방식으로 하위프로세스를 찾아서 종료하겠지 싶다. ㅎㅎ procmon으로 확인해봐도 재밌을거 같다.)\n안습한 점은, node.js의 \u0026#34;kill-process-group\u0026#34; 패키지를 봐도, 윈도에선 그냥 taskkill 유틸리티를 호출한다. (윈도 지원이라고 해서 설레였었다…)\nhttps://github.com/Kikobeats/kill-process-group/blob/39ce518916c746d1445aba4ffdab8bf59d001874/src/index.js#L10\n결국:\n윈도에서도 process-group을 흉내내려고 하려면,\nhttps://learn.microsoft.com/en-us/windows/win32/procthread/job-objects 을 쓰는게 가장 맞는 방법인 것 같다.\n(내가 프로세스를 시작한다면) 그게 아니라면, 그냥 enumerate =\u0026gt; terminate 방식으로 구현하는게 맞을 것 같다. [Addendum] cgroups – 갑자기 docker \u0026amp; kubernetes 정말 별거 아닌 일을 하기 위해서 process-group으로 분리하고 하는 일들을 보였는데, 의외로 이런 방식들이 발전을 계속하여 현재의 경량가상화 / 혹은 컨테이너화를 위한 단계까지 온 것 같다.\npgrp만이 아니라 다른 chroot 같은 \u0026#34;오래된\u0026#34; 유닉스개념들이 더해지고 발전하여 현대의 docker / kubernetes 같은 경량컨테이너화 기술의 기반이 되었다.\n👉 LWN Control groups, part 1: On the history of process grouping\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-12dec/reactjs+nextjs-rce/","title": "🌋 (주절주절) react.js / next.js RCE 보안문제와 아기 히틀러 딜레마",
     
     "tags": ["javascript", "nextjs", "reactjs", "rce", "vulnerability", "tcl", "scheme", "rms", "webdev", "guile", "scheme", "branden-eich", "vercel", "security", "netscape", "nodejs", "newsgroup", "flamewar", "debate", "discussion", "gnu", "siod", "gimp", "script-fu"],
     
 "description": "",
 "contents": " 2~3일 전부터 해외 커뮤니티에서는 크게 이슈가 됐고, 한국 뉴스피드 등은 이제 좀 올라오는거 같다.\nHN: RCE Vulnerability in React and Next.js (github.com/vercel) 댓글을 보면 충격적이다.\n예전 log4j RCE보다 내 생각엔 위험할 것 같다. …왜냐하면 누구나 아무 생각 없이 그냥 써왔을거고, 그러려고 선택한 스택일테니까. 🥟\n공교롭게도, HN: 30 years ago today \u0026#34;Netscape and Sun announce JavaScript\u0026#34; (archive.org) …였다고 한다. 🎂\n그리고 문득 또 다른 거의 30여년 전의 어떤 논쟁, 세상을 뒤바꾼 논쟁이 떠올랐다:\ncomp.lang.tcl: Why you should not use Tcl\n그리고 나머지는 잘 아는대로, Brendan Eich은 원래는 Scheme을 웹브라우저에 넣고 싶었지만, 마케팅에 유리할 것 같은 \u0026#34;Java스러운\u0026#34; 언어를 10일만에 만들고, 그게 JavaScript이 되었다고 한다. 1\n어쩌면 그 언어가 Tcl이었을수도 있고, 어쩌면 그냥 Scheme이었을수도 있겠지만.\n아참. comp.lang.tcl-의 저 유명한 rms의 글의 내용도, Tcl언어가 외부의 입력을 그대로 실행(eval)해버릴 위험이 크므로, Tcl은 제발 그만 쓰고 (자기가 좋아하는 리습계열인) Scheme을 써야 한다는 주장이다.\n하지만 흥미롭게도 현재의 우리는 스킴을 쓰지도, 웹브라우저에 스킴이 내장되지도 않은 시대를 살고 있다. 더더욱이 rms의 GNU Guile도 그렇게 메인스트림 언어나 스크립팅 언어라고 하기엔 좀 인기가 많이 부족한 느낌이다.\nGNU GIMP의 Script-Fu이라던지 나는 재밌게 써보긴 했었다. 그런데 그마저도 Guile이 아니라 SIOD 구현이었던 것 같다.2 ㅎㅎ\n어차피 현대 사회의 모습을 남들이 이해하건 않건 규정한 자유소프트웨어/오픈소스의 시작인 GNU Manifesto-에서부터 \u0026#34;…(우리는) 커먼리습을 다 구현해놓았고, 앞으로 다들 그걸 쓰게 될 것이다.\u0026#34;-는 식의 말들도 지금에 와서 보면 이게 뭔 뜬금 없는 과거의 상상화스러운 미래비전인가 싶다.\n흥미롭다.\n이해하건 못하건, 현재의 인터넷과 모든IT 기반이 오픈소스에 깊이 의존하는데, 그 시대를 만든 안목자의 선언에서 그다지 이뤄지지 않은 부분도 많다는걸 생각해본다. 지금 시대에 유명인사들이 하는 모든 말들이 꼭 예언적이진 않을거란 생각을 하게 된다.\n그리고 이상하게도, Tcl 같은 언어에서 멀리 떠나가 Scheme + Java =\u0026gt; JavaScript 같은 요상한 조합을 만들어 내면서까지 웹브라우저에 스크립팅 언어를 심었는데, 그게 결국엔 먼 시간을 돌고 돌아서 보안문제를 마치 원래 Tcl이 심어져 있었더라면 일으켰을 양상을 보안이슈를 만드는 것 같기도 하다.\n문득 역사나 예언을 전혀 모르지만 이런 이야기가 떠올랐다: 위키백과: \u0026#34;Killing baby Hitler\u0026#34; 💀\nFootnotes 1 https://www.reddit.com/r/programming/comments/16v7zv2/was_javascript_really_made_in_10_days/\n2 카메라로 OpenCV 안면인식을 하고, 그에 따라 얼굴에 \u0026#34;가상화장\u0026#34;을 적용해주는 프로젝트에 참여한 적이 있다. GIMP Headless Server을 만들고, 좌표들에 따라 Scheme스크립트를 실행해서 이미지에 \u0026#34;필터\u0026#34;를 적용해주는 부분, JSON/Telnet기반 프로토콜을 정의하고 요청을 받아 처리하는 서버를 만들었던 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-11nov/blog-post-title-emojis/","title": "🐌 블로그 디자인 수정 + 제목 자동 emoji 붙여주기",
     
     "tags": ["ping", "css", "emoji", "programming", "hugo", "template", "templating", "webdev", "sha1", "sha", "mod", "remainder", "hash"],
     
 "description": "",
 "contents": " 블로그 CSS을 또 수정하고, 레이아웃도 좀 더 고쳤다. 간단하게 가볍게 보였으면 해서.\n그런데 그간 고민해오던 것들이 있음:\n(예전에) 귀찮아서 new-ping.pl-스크립트 같은거 짜놓고 자동 생성한 포스팅 제목으로 그대로 포스팅한 \u0026#34;Ping …..\u0026#34;-같은 제목의 포스팅들은 archives에서 봐도 뭐가 뭔지 구분이 안됨. h1-같은 markdown/org-mode에서 export한 제목과 각 포스팅의 제목(이것도 h1-같은 태그인)이 눈에 딱 들게 구분이 되지 않았음. archives에서 각 포스팅의 preview을 표시했다 조금 내용도 나오니까 찾아보기 더 수월해진거 같다. ㅎㅎ 그리고 막상 이렇게 전체 목록 / 시간에 따라, 내용을 조금이나마 보여주니까 일대기 형식이라 재밌네.\n포스팅 제목에 자동으로(!) emoji을 붙여주도록 했다 🤖 랜덤하게, 혹은 특정한 값에 의해, emoji 목록에서 선택하여 자동으로 붙여주기,,를 하면 좀 각 포스팅별로 구분되어 보일 것 같아서 시도.\n그런데, 페이지 렌더링 때마다 매번 랜덤하게 붙여주면, 그 포스팅의 개성이 사라지는거 같아서, 해당 포스팅의 제목/내용 같은 문자열 조합에 따라서 emoji 목록에서 선택하는 방식으로 구현해 봤다.\n어차피 static site generator을 사용하고 있으므로, 선택지는:\njavascript : 웹브라우저가 페이지 렌더링 할 때에. static site generator templating : 포스팅 publish 전에 html에 생성. 자바스크립트를 쓰면 쉽겠지만, 자바스크립트가 없는 웹브라우저를 쓰는 누군가👽를 위해서 (2)번 방식, static site generator templating만을 쓰기로 했다.\n그래서 구현해봤다:\n1 2 3 4 5 6 7 {{- /* layouts/partials/emojibyhash.html */ -}} {{- $emojis := slice \u0026#34;😀\u0026#34; \u0026#34;😃\u0026#34; /* ...여기에 엄청 많이 이모지 목록 나열... */ -}} {{- $h := crypto.SHA1 .input -}} {{- $hn := cast.ToInt (add \u0026#34;0x\u0026#34; (slicestr $h 36)) -}} {{- $emoji_idx := mod $hn (len $emojis) -}} {{- $emoji := index $emojis $emoji_idx -}} {{- return $emoji -}} 어떤 문자열을 전달 받고(.input), 그걸 sha1 \u0026gt;\u0026gt; slice _ 36 \u0026gt;\u0026gt; ToInt-해서 작은 정수값으로 만들고, 그 정수값으로 remainder연산해서 이모지목록에서 선택하는 방식.\n주어진 문자열(.input)만 고정되어 있다면, 항상 같은 이모지를 선택해주도록 했다.\n사용하는 곳에선:\n1 2 {{- $emoji := partial \u0026#34;emojibyhash.html\u0026#34; (dict \u0026#34;input\u0026#34; .Title) -}} \u0026lt;h1\u0026gt;{{ $emoji }} {{ .Title }}\u0026lt;/h1\u0026gt; hugo template partials을 활용해서, 이렇게 function-or-macro 같이 사용할 수 있더라. shortcodes1으로 만들어서 쓰는 방식도 가능하던데, 일단 그냥 partials으로 무식하게 만들어봤다.\n…재밌었다. ㅎㅎ\n포스팅에 자동으로 emoji을 붙여주니 좀 걱정도 생긴다 🫣 음… 자동으로 붙여주는건 정말 좋은데 걱정이: …포스팅 제목에 따라서 붙은 이모지 조합이, 종종 nsfw하거나 괴상한 의미로 읽힐 수도 있을거 같은 예가 좀 보여서.\nFootnotes 1 https://gohugo.io/templates/shortcode/\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-11nov/scripts-rofi-perl5-release/","title": "😪 scripts-rofi-perl5 릴리즈",
     
     "tags": ["rofi", "dmenu", "perl", "script", "launcher", "opensource", "programming", "scripting", "desktop", "drun", "dbd", "dbi", "sqlite", "sqlite3", "storable"],
     
 "description": "",
 "contents": " https://github.com/ageldama/scripts-rofi-perl5\n스크립트 많이 작성해서 자동화해서 쓰는데, 터미널 열거나 하기 귀찮고, 모두 한 디렉토리에 넣어두기도 정리가 안되는거 같아서 작성해서 몇 년 전부터 써왔다.\n자동으로 최근 실행한 스크립트부터 표시하도록 히스토리를 저장해서 순위표시.1\n최근에 \u0026#34;터미널 내부에서 실행하기\u0026#34; 기능을 추가하고 좀 많이 다듬어서 릴리즈.\n터미널 안에서 실행되어야 하는 스크립트인데, 그냥 창없이 실행되면 낭패이기 때문에2, 과거 실행내역에 따라서, 터미널에서 실행하던 스크립트라면 다시 터미널에서 실행되도록 권해주기 기능도 추가.\n나 같이 x윈도 환경을 커스터마이징해서 내게 맞춰서 쓰는 사람이나 좋아할거 같은 도구. ㅎㅎ\nFootnotes 1 원래는 DBD/SQLite3을 썼다가, 더 가볍게 그냥 Perl 내장 Storable으로 수정.\n2 직접 프로세스 찾아서 kill 해주기 귀찮으니까.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-11nov/python-3.14-concurrent-interpreters-and-tcl/","title": "🌘 Python 3.14 &#34;no-GIL&#34;보다 concurrent.interpreters, 그리고 Tcl 데자뷰",
     
     "tags": ["python", "thread", "threading", "multicore", "parallelism", "gil", "tcl", "interp", "concurrent", "concurrency", "queue", "ipc", "pythonic", "cpython", "programming", "commonlisp", "ruby", "asyncio", "multiprocessing", "threading", "contextvars", "perl", "dynamic-scoping"],
     
 "description": "",
 "contents": " 최근의 파이썬은 아주 오랬동안 multicore/parallelism을 지원하기 위해 걸림돌이었던 GIL에서 자유로워진 \u0026#34;no-GIL\u0026#34; 옵션이 베타 단계. (\u0026#34;free GIL\u0026#34; 혹은 \u0026#34;free threading\u0026#34;이라고도 부르는듯) https://blog.jetbrains.com/ko/pycharm/2025/08/faster-python-unlocking-the-python-global-interpreter-lock/\n\u0026#34;no-GIL\u0026#34;이 분명히 중요한 변화이겠지만, 내겐 Python 3.14에 concurrent.interpreters 추가된 것이 더 흥미롭다.\n이게 과연 Parallelism을 지원하기 위한 방식일까 하고 바로 알아차라기는 어렵지만 조금 생각해보면:\n새로운 프로세스를 만들지는 않는다 (multiprocessing 모듈) 직접 같은 GIL을 공유하는 스레드를 만들지도 않는다 (threading 모듈) 하지만, 같은 프로세스 안에서 다른 GIL을 사용하는, 파이썬 인터프리터를 만들고, 다른 인터프리터와 적당한 정도로 IPC이 가능하고 (Queue 정도) 다른 인터프리터가 실행했으면 하는 파이썬 코드를 전달 가능. 별거 아닌거 같지만 얻을 수 있는 이점은:\n파이썬에 별다른 변경을 가하지 않아도, 또 기존의 CPython C-API에 의존하는 라이브러리들이 제대로 동작하지 않을까 하는 호환성 걱정 없이, multiprocessing보다 오버헤드가 적게, 멀티코어를 사용할 수 있다. As a significant bonus, interpreters are sufficiently isolated that they do not share the GIL, which means combining threads with multiple interpreters enables full multi-core parallelism. (This has been the case since Python 3.12.)\nPython스러움, Pythonic한 방식? 파이썬은 다른 동시대의 언어들의 유행과는 조금 다른 길을 가는 파이썬스러운 특유의 방식이 언어, 표준라이브러리(흔히 \u0026#34;batteries\u0026#34;으로 부르는)에 있다고 생각한다.\n문법을 확장하기 보다는, 잘 정제된 문법을 갖고, 그 문법에 적용할 수 있는 패턴들을 확장해 쓸 수 있게 해왔다고 생각한다.\nRuby이나 Lisp 계열 언어들이 closure-block을 전달하거나, with- / each--등의 방식으로, 반복자(iterator), 자원관리을 접근할 때에,\nPython은 Generator, with-statement, __enter__-magic method 정도로 잘 소화해온 것 같다.\n1 2 3 4 5 File.open(\u0026#34;/etc/passwd\u0026#34;, \u0026#34;r\u0026#34;) do |file| file.each_line do |line| # ... end end …같은 코드라면:\n1 2 3 with open(\u0026#34;/etc/passwd\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: # ... 이렇게 언어 자체를 확장하거나 하지 않으면서 라이브러리 모듈을 통해 dynamic scoping처럼 동작하는 contextvars 모듈도 좋은 예라고 생각한다. 다음 커먼리습 코드1:\n1 2 3 4 5 6 7 8 9 10 (defparameter *xxx* nil) (defun print-xxx () (format t \u0026#34;XXX = ~a~%\u0026#34; *xxx*)) (defun dyn-scoping () (let ((*xxx* 42)) (print-xxx))) (dyn-scoping) ;; ==\u0026gt; \u0026#34;XXX = 42\u0026#34; 이걸 파이썬이었다면2:\n1 2 3 4 5 6 7 8 9 10 11 import contextvars xxx = contextvars.ContextVar(\u0026#39;xxx\u0026#39;, default=\u0026#39;???\u0026#39;) def print_xxx(): print(f\u0026#39;XXX = {xxx.get()}\u0026#39;) with xxx.set(\u0026#39;42\u0026#39;): # Python 3.14+ 전용 print_xxx() print_xxx() 이런예 이외에도, 파이썬은 그 시대의 유행하는 언어들, 혹은 그 언어들의 idiom와는 조금 다르면서도, 파이썬 자기자신스러움을 잃지 않고 발전해왔다고 생각한다.\n그리고 이런 측면 때문에 no-GIL 방식의 CPython 자체의 변화보다는, concurrent.interpreters 방식이 더 파이썬스럽고 내겐 흥미롭다고 여겨지는 것 같다. (물론 파이썬 자체 PEP에서 열심히 논의한 결과로 no-GIL을 진행하고 있겠지만 말이다)\n(EDIT: 2025-11-20 Thu) concurrent.futures + interpreters https://docs.python.org/3/library/concurrent.futures.html#interpreterpoolexecutor\nThe InterpreterPoolExecutor class uses a pool of interpreters to execute calls asynchronously. It is a ThreadPoolExecutor subclass, which means each worker is running in its own thread. The difference here is that each worker has its own interpreter, and runs each task using that interpreter.\nThe biggest benefit to using interpreters instead of only threads is true multi-core parallelism. Each interpreter has its own Global Interpreter Lock, so code running in one interpreter can run on one CPU core, while code in another interpreter runs unblocked on a different core.\ninterpreters + threading 이미 바로 쓸 수 있도록 해놓은 모듈이 3.14+ 부터 추가됨. ㅎㅎ 직접 interpreters와 스레드를 묶어서 쓰려고 애쓰지 않아도 바로 쓸 수 있도록.\n(부록) Tcl 데자뷰 Tcl도 (파이썬만큼이나 역사가 30년이 넘은 언어이니만큼) GIL 이슈가 동일했다.\n그리고 CPython처럼 Tcl도 Reference-Counting 방식의 C-API여서, GIL이 중요하다. (예: CPython의 Py_INCREF / Tcl의 Tcl_IncrRefCount)\n하지만, 파이썬과 달리 Tcl은 별로 GIL문제가 크게 부각되지 않아왔었는데(파이썬에 비한다면 사용자층도 거의 남지 않았지만 ㅎㅎ), 이미 예전부터 interpreter 생성과 실행위임 기능을 갖고 있었었고, 스레딩 방식도 아예 이런 분리된 인터프리터를 이용하는 방식이었었다.\nhttps://www.tcl-lang.org/man/tcl8.6/TclCmd/interp.htm https://www.tcl-lang.org/man/tcl8.6/ThreadCmd/thread.htm 이번 \u0026#34;최신의\u0026#34; 파이썬 모듈 변화를 보면서, 이상하게 오래 된 Tcl의 interp 커맨드, thread 패키지가 기억에서 떠올랐다. (할아버지 감성 👴🏽)\nFootnotes 1 Perl 5도 local-을 통해 이를 지원한다.\n2 thread-local 같이 동작하게 만들거나, 분리된 call-stack에서는 원래의 값을 유지한다던가 하는 dynamic-scoping의 구현의 수준은 언어별로 많이 다를 것 같다. 하지만 contextvars 정도의 구현수준으로 대부분의 케이스는 커버가 되는 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-11nov/my-elisp-requires/","title": "🕯️ 내 emacs elisp &#34;requires&#34;",
     
     "tags": ["emacs", "elisp", "emacs-lisp", "configuration", "macro", "require", "provide", "byte-compile", "bytecode", "compile", "performance", "parsing", "loading", "startup-speed", "defmacro"],
     
 "description": "",
 "contents": " Emacs 설정을 모듈별로 분리해서 정리해서 사용한다.\n다음처럼 init.el-파일에서 로딩함: 사용예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 (ag-requires :tag-:*feats :compile ;; ... 바이트컴파일 \u0026#39;ag-feat-recentf ; dpkg=+ \u0026#39;ag-feat-savehist ; dpkg=+ \u0026#39;ag-feat-avy ; dpkg=elpa-avy :nocompile ;; ... 여기부터는 바이트컴파일X \u0026#39;ag-feat-rg ; dpkg=elpa-rg \u0026#39;ag-feat-c ; dpkg=+ \u0026#39;ag-feat-perl5 ; dpkg=+ ) 자동으로 byte-compile해서 로딩속도 빨라지도록 매크로 짜놓았음:\nhttps://github.com/ageldama/configs/blob/d7595e9f07599cbe56ee45a108d3898c5990a7bc/emacs/boot/ag-00-boot.el#L61-L95 예전에 짜놓은거, 버그 고치고 다시 빠르게 로딩되도록 잘 써먹어서 기분 좋음. "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-11nov/cl-defmacro-fwd-declaration/","title": "🧬 [TIL] common-lisp defmacro와 forward-declaration",
     
     "tags": ["TIL", "common-lisp", "lisp", "macro", "defmacro", "declaration", "sbcl", "compiler", "runtime", "commonlisp", "bug", "disassemble", "assembly", "disassembly", "reversing"],
     
 "description": "",
 "contents": " 의외로 단순한건데, 컴파일한 sbcl image에서 runtime에 unbound variable 컨디션을 발생시킬 수 있음.\n1 2 3 4 5 6 7 8 9 10 11 12 (defmacro with-foo-bar (base-str (foo-var bar-var) \u0026amp;rest body) \u0026#34;BASE-STR에 foo, bar 문자열을 붙인 FOO-VAR, BAR-VAR 바인딩을 만들어, BODY을 해당 바인딩을 적용하여 실행\u0026#34; ;; NOTE let-대신 symbol-macrolet 사용해도 ok: `(let ((,foo-var (format nil \u0026#34;FOO:~a\u0026#34; ,base-str)) (,bar-var (format nil \u0026#34;BAR:~a\u0026#34; ,base-str))) ,@body)) ;;; 매크로 with-foo-bar 사용: (with-foo-bar \u0026#34;hello\u0026#34; (a b) (format t \u0026#34;~a // ~a~%\u0026#34; a b)) ;; [OUTPUT] FOO:hello // BAR:hello 단순하게 코드가 커지면1, defmacro-선언보다 해당매크로 호출이 컴파일러가 볼 때에 먼저 위치할 수 있는데, 그런 경우엔 좀 어이없지만, unbound variable 런타임 컨디션이 발생.\n이유를 생각해보면,\n단순히 with-foo-bar-자체를 참조하지 못해서가 아니라, (with-foo-bar \u0026#34;hello\u0026#34; (a b) ...)-에서 (a b)-부분 때문.\nmacro expansion rule이 아니라, form expression의 평가규칙을 적용하느라, 즉, a-함수를 (b)-을 인자로 호출하려고 시도. …컨디션의 에러메시지는 매크로이름이랑 상관 없이, Unbound variable: a / b-와 같이만 표시하므로 더 혼란스러워짐. 일단 추론은: sbcl 컴파일해도, 결국 실행시간에 defmacro한 것도 macro-expansion을 수행하려고 하는구나.\n…그말인 즉, 컴파일시간에 확장해놓고 실행해도 될 부분도 그렇게 하는게 기본 컴파일된 코드구나 싶어서 당혹. …라고 납득하려고 했으나, 말이 않되는거란 생각: 그럴거면 뭐하러 eval-when 등으로 컴파일시점을 분리해놓았겠는가;; 그래서 실험: https://github.com/ageldama/defmacro-forward-declaration--example\ndisassembly -bug 다음과 같이, 그리고 알고 있는 것과 같이, macro-expanded한 코드를 생성한다.\n다른 함수를 호출할 것도 없이, 그 함수 내용으로 코드가 복사된 것을 확인. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 ; disassembly for DEFMACRO-FORWARD-DECLARATION:MAIN ; Size: 294 bytes. Origin: #xB8000952BF ; DEFMACRO-FORWARD-DECLARATION:MAIN ; 2BF: 498B4510 MOV RAX, [R13+16] ; thread.binding-stack-pointer ; 2C3: 488945F8 MOV [RBP-8], RAX ; 2C7: 488B0592FFFFFF MOV RAX, [RIP-110] ; \u0026#39;DEFMACRO-FORWARD-DECLARATION:MAIN ; 2CE: 488B5009 MOV RDX, [RAX+9] ; 2D2: 85D2 TEST EDX, EDX ; 2D4: 0F8408010000 JE L0 ; 2DA: 4883EC10 SUB RSP, 16 ; 2DE: B902000000 MOV ECX, 2 ; 2E3: 48892C24 MOV [RSP], RBP ; 2E7: 488BEC MOV RBP, RSP ; 2EA: FF15D0E3A6FF CALL [RIP-5839920] ; DISASSEMBLE ; 2F0: 4883EC10 SUB RSP, 16 ; 2F4: 488B156DFFFFFF MOV RDX, [RIP-147] ; \u0026#34;FOO:\u0026#34; ; 2FB: 488B3D6EFFFFFF MOV RDI, [RIP-146] ; \u0026#34;hello\u0026#34; ; 302: B904000000 MOV ECX, 4 ; 307: 48892C24 MOV [RSP], RBP ; 30B: 488BEC MOV RBP, RSP ; 30E: FF15AC80A7FF CALL [RIP-5799764] ; SB-KERNEL:%CONCATENATE-TO-STRING ; 314: 4C8BCA MOV R9, RDX ; 317: 4C894DE0 MOV [RBP-32], R9 ; 31B: 4883EC10 SUB RSP, 16 ; 31F: 488B1552FFFFFF MOV RDX, [RIP-174] ; \u0026#34;BAR:\u0026#34; ; 326: 488B3D43FFFFFF MOV RDI, [RIP-189] ; \u0026#34;hello\u0026#34; ; 32D: B904000000 MOV ECX, 4 ; 332: 48892C24 MOV [RSP], RBP ; 336: 488BEC MOV RBP, RSP ; 339: FF158180A7FF CALL [RIP-5799807] ; SB-KERNEL:%CONCATENATE-TO-STRING ; 33F: 4C8B4DE0 MOV R9, [RBP-32] ; 343: 488955F0 MOV [RBP-16], RDX ; 347: 4D8B8578030000 MOV R8, [R13+888] ; tls: *STANDARD-OUTPUT* ; 34E: 4983F8FF CMP R8, -1 ; 352: 4C0F440425307D0450 CMOVE R8, [#x50047D30] ; *STANDARD-OUTPUT* ; 35B: 4C8945E8 MOV [RBP-24], R8 ; 35F: 4883EC10 SUB RSP, 16 ; 363: 498BD1 MOV RDX, R9 ; 366: 488B7DE8 MOV RDI, [RBP-24] ; 36A: B904000000 MOV ECX, 4 ; 36F: 48892C24 MOV [RSP], RBP ; 373: 488BEC MOV RBP, RSP ; 376: FF158CB5A6FF CALL [RIP-5851764] ; WRITE-STRING ; 37C: 4883EC10 SUB RSP, 16 ; 380: 488B1501FFFFFF MOV RDX, [RIP-255] ; \u0026#34; // \u0026#34; ; 387: 488B7DE8 MOV RDI, [RBP-24] ; 38B: B904000000 MOV ECX, 4 ; 390: 48892C24 MOV [RSP], RBP ; 394: 488BEC MOV RBP, RSP ; 397: FF156BB5A6FF CALL [RIP-5851797] ; WRITE-STRING ; 39D: 4883EC10 SUB RSP, 16 ; 3A1: 488B55F0 MOV RDX, [RBP-16] ; 3A5: 488B7DE8 MOV RDI, [RBP-24] ; 3A9: B904000000 MOV ECX, 4 ; 3AE: 48892C24 MOV [RSP], RBP ; 3B2: 488BEC MOV RBP, RSP ; 3B5: FF154DB5A6FF CALL [RIP-5851827] ; WRITE-STRING ; 3BB: 4883EC10 SUB RSP, 16 ; 3BF: BA510A0000 MOV EDX, 2641 ; 3C4: 488B7DE8 MOV RDI, [RBP-24] ; 3C8: B904000000 MOV ECX, 4 ; 3CD: 48892C24 MOV [RSP], RBP ; 3D1: 488BEC MOV RBP, RSP ; 3D4: FF1546B1A6FF CALL [RIP-5852858] ; WRITE-CHAR ; 3DA: 498BD4 MOV RDX, R12 ; NIL ; 3DD: C9 LEAVE ; 3DE: F8 CLC ; 3DF: C3 RET ; 3E0: CC0F INT3 15 ; Invalid argument count trap ; 3E2: L0: CC13 INT3 19 ; UNDEFINED-FUN-ERROR ; 3E4: 00 BYTE #X00 ; RAX(d) disassembly +bug (추론대로) A, B 심볼을 함수로서 호출하려고 애쓰다 디버거로 빠져든 상황이다.\n디버거에서 disassemble: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 debugger invoked on a UNBOUND-VARIABLE @B80009505A in thread #\u0026lt;THREAD tid=37091 \u0026#34;main thread\u0026#34; RUNNING {1200030003}\u0026gt;: The variable DEFMACRO-FORWARD-DECLARATION::B is unbound. Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL. restarts (invokable by number or by possibly-abbreviated name): 0: [CONTINUE ] Retry using DEFMACRO-FORWARD-DECLARATION::B. 1: [USE-VALUE ] Use specified value. 2: [STORE-VALUE] Set specified value and use it. 3: [ABORT ] Exit from the current thread. (DEFMACRO-FORWARD-DECLARATION:MAIN) source: (A B) 0] (disassemble #\u0026#39;dmfd:main) ; disassembly for DEFMACRO-FORWARD-DECLARATION:MAIN ; Size: 323 bytes. Origin: #xB800094F1F ; DEFMACRO-FORWARD-DECLARATION:MAIN ; 4F1F: 498B4510 MOV RAX, [R13+16] ; thread.binding-stack-pointer ; 4F23: 488945F8 MOV [RBP-8], RAX ; 4F27: 4C8B05A2FFFFFF MOV R8, [RIP-94] ; \u0026#39;DEFMACRO-FORWARD-DECLARATION::B ; 4F2E: 418B50F5 MOV EDX, [R8-11] ; 4F32: 4A8B142A MOV RDX, [RDX+R13] ; 4F36: 4883FAFF CMP RDX, -1 ; 4F3A: 490F445001 CMOVE RDX, [R8+1] ; 4F3F: 80FA09 CMP DL, 9 ; 4F42: 0F8411010000 JE L0 ; 4F48: 4883EC10 SUB RSP, 16 ; 4F4C: B902000000 MOV ECX, 2 ; 4F51: 48892C24 MOV [RSP], RBP ; 4F55: 488BEC MOV RBP, RSP ; 4F58: FF153A97A7FF CALL [RIP-5793990] ; DEFMACRO-FORWARD-DECLARATION::A ; 4F5E: 480F42E3 CMOVB RSP, RBX ; 4F62: 488955E8 MOV [RBP-24], RDX ; 4F66: 4C8B056BFFFFFF MOV R8, [RIP-149] ; \u0026#39;DEFMACRO-FORWARD-DECLARATION::A ; 4F6D: 418B50F5 MOV EDX, [R8-11] ; 4F71: 4A8B142A MOV RDX, [RDX+R13] ; 4F75: 4883FAFF CMP RDX, -1 ; 4F79: 490F445001 CMOVE RDX, [R8+1] ; 4F7E: 80FA09 CMP DL, 9 ; 4F81: 0F84D5000000 JE L1 ; 4F87: 4C8B0542FFFFFF MOV R8, [RIP-190] ; \u0026#39;DEFMACRO-FORWARD-DECLARATION::B ; 4F8E: 418B40F5 MOV EAX, [R8-11] ; 4F92: 4A8B0428 MOV RAX, [RAX+R13] ; 4F96: 4883F8FF CMP RAX, -1 ; 4F9A: 490F444001 CMOVE RAX, [R8+1] ; 4F9F: 3C09 CMP AL, 9 ; 4FA1: 0F84B8000000 JE L2 ; 4FA7: 488945F0 MOV [RBP-16], RAX ; 4FAB: 4D8B8D78030000 MOV R9, [R13+888] ; tls: *STANDARD-OUTPUT* ; 4FB2: 4983F9FF CMP R9, -1 ; 4FB6: 4C0F440C25307D0450 CMOVE R9, [#x50047D30] ; *STANDARD-OUTPUT* ; 4FBF: 4C894DE0 MOV [RBP-32], R9 ; 4FC3: 4883EC10 SUB RSP, 16 ; 4FC7: 488B7DE0 MOV RDI, [RBP-32] ; 4FCB: B904000000 MOV ECX, 4 ; 4FD0: 48892C24 MOV [RSP], RBP ; 4FD4: 488BEC MOV RBP, RSP ; 4FD7: FF153BC3A6FF CALL [RIP-5848261] ; PRINC ; 4FDD: 4883EC10 SUB RSP, 16 ; 4FE1: 488B1500FFFFFF MOV RDX, [RIP-256] ; \u0026#34; // \u0026#34; ; 4FE8: 488B7DE0 MOV RDI, [RBP-32] ; 4FEC: B904000000 MOV ECX, 4 ; 4FF1: 48892C24 MOV [RSP], RBP ; 4FF5: 488BEC MOV RBP, RSP ; 4FF8: FF150AB9A6FF CALL [RIP-5850870] ; WRITE-STRING ; 4FFE: 4883EC10 SUB RSP, 16 ; 5002: 488B55F0 MOV RDX, [RBP-16] ; 5006: 488B7DE0 MOV RDI, [RBP-32] ; 500A: B904000000 MOV ECX, 4 ; 500F: 48892C24 MOV [RSP], RBP ; 5013: 488BEC MOV RBP, RSP ; 5016: FF15FCC2A6FF CALL [RIP-5848324] ; PRINC ; 501C: 4883EC10 SUB RSP, 16 ; 5020: BA510A0000 MOV EDX, 2641 ; 5025: 488B7DE0 MOV RDI, [RBP-32] ; 5029: B904000000 MOV ECX, 4 ; 502E: 48892C24 MOV [RSP], RBP ; 5032: 488BEC MOV RBP, RSP ; 5035: FF15E5B4A6FF CALL [RIP-5851931] ; WRITE-CHAR ; 503B: 488B15AEFEFFFF MOV RDX, [RIP-338] ; \u0026#34;hello\u0026#34; ; 5042: 488B7DE8 MOV RDI, [RBP-24] ; 5046: 498BF4 MOV RSI, R12 ; NIL ; 5049: B906000000 MOV ECX, 6 ; 504E: FF7508 PUSH QWORD PTR [RBP+8] ; 5051: FF253996A7FF JMP [RIP-5794247] ; DEFMACRO-FORWARD-DECLARATION::WITH-FOO-BAR ; 5057: CC0F INT3 15 ; Invalid argument count trap ; 5059: L0: CC19 INT3 25 ; UNBOUND-SYMBOL-ERROR ; 505B: 20 BYTE #X20 ; R8(d) ; 505C: L1: CC19 INT3 25 ; UNBOUND-SYMBOL-ERROR ; 505E: 20 BYTE #X20 ; R8(d) ; 505F: L2: CC19 INT3 25 ; UNBOUND-SYMBOL-ERROR ; 5061: 20 BYTE #X20 ; R8(d) 결론 sbcl이 컴파일할 때에, 해당 참조를 찾지 못하면 그냥 함수려니하고 코드를 생성해버림. asdf:make, sbcl 둘 다 나빠 ㅠ.ㅠ 경고라도 뛰워주던가…\n(lisp-implementation-version) ; =\u0026gt; \u0026#34;2.5.10\u0026#34; (asdf:asdf-version) ; =\u0026gt; \u0026#34;3.3.1\u0026#34; …그래서 시도했지만 별 차이 없음:\n1 2 3 4 5 6 7 8 9 (setf asdf:*asdf-verbose* t *load-verbose* t *load-print* t *compile-verbose* t *compile-print* t) (declaim #+sbcl(sb-ext:unmuffle-conditions style-warning)) (declaim #+sbcl(sb-ext:unmuffle-conditions compiler-note)) [EDIT] [2025-11-10 Mon] 위 disassemble 같이 만든 상황을 다시 재현하기 어려움. 흠좀무. 다행이라면 다행. 그리고 사실 (declaim (ftype ...))-으로 함수라면 전방선언(forward declaration)이 가능하겠지만, 매크로는 컴파일러가 동작하는 시점에 필요하므로 불가하다고. …결국 asdf system definition에 serial으로 의존성순서에 맞게 넣어줘야함. ㅎㅎ Footnotes 1 최근에 작업한 코드에서 겪은 문제라.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/throttled-restart--perl-oneliner--and--tcl/","title": "▶️ [throttled-restart.tcl] throttling 적용하여 파일변경시 자동으로 프로세스 재시작하기와 Tcl 취향고백",
     
     "tags": ["fswatch", "inotify-tools", "inotify", "filesystem", "fam", "perl", "oneliner", "shell", "xargs", "tcl", "tcllib", "webdev", "restarting", "server", "process", "command", "throttled-restart.tcl", "throttle", "throttling", "lisp", "metaprogramming", "eias", "closure", "lambda", "apply", "asyncio", "gil", "threading", "callback-hell", "function-coloring", "async-await"],
     
 "description": "",
 "contents": " 코딩을 하다보면, 파일변경시에 자동으로 빌드, 서버재시작, 혹은 테스트케이스를 실행 되도록 하면 꽤 편리할 수 있다.\n커먼리습 같은 경우엔 바로 실행중인 코드가 변경되는 방식이어서 신경 쓸게 별로 없고, Rails 같은 웹프레임웍은 자동으로 재시작하거나 변경된 코드를 다시 로딩해주기도 하고, PHP 계열도 웹브라우저를 refresh하면 자동적으로 새 코드으로 실행하게 된다.\n다른 컴파일이 필요한 언어나, 파이썬, 펄 같은 언어들, 혹은 자동으로 코드에 반영되는 언어/프레임웍을 사용하더라도, 원하는 태스크(예: 테스트케이스 실행) 같은걸 걸어 놓으려면 커맨드라인에서 지정해두는게 낫다.\n문제 #1: 파일변경을 모니터링하기 대부분의 언어/프레임웍들은 이런 \u0026#34;파일변경 모니터링\u0026#34; 기능이 없다.\n==\u0026gt; 다른 외부도구를 커맨드라인에서 연결해서 사용하면 될 것 같다. 시도 #1: fswatch으로 파일변경을 모니터링하고 지정한 커맨드 실행하기 fswatch 커맨드라인 도구를 사용하기로 했다. (freebsd, linux 모두 지원) 일단 간단하게 시작: 모든 변경을 STDIN으로 전달 받음 1 2 3 4 5 6 7 8 9 10 11 12 # fswatch: ~/w 디렉토리 이하의 모든 변경을 모니터링. # -L (follow-symlink) # -r (recurse-subdir) # # perl: STDIN 입력을 모두 그대로 출력. (echo) $ fswatch -Lr ~/w | perl -ne \u0026#39;print\u0026#39; # STDOUT출력이 있을 때마다 make 실행되도록 xargs 연결: $ fswatch -Lr ~/w | perl -ne \u0026#39;print\u0026#39; | xargs -n1 -IXXX make # xargs -n1 -IXXX : # .. STDIN의 첫번째 줄만 전달 (-n1) # .. 커맨드라인(make) 부분에서 XXX 부분을 STDIN 문자열으로 대체 (-IXXX) 시도 #2: throttling, Perl One-liner (문제) 한 변경에 너무 많은 triggering 갯수\n$HOME/w 디렉토리에 한 번에 여러 파일이 생성/삭제/수정되면 그게 한 라인씩 찍힘. 한 뭉치 변경은 하나의 라인으로 뭉치면 좋겠다. 한 단위시간 동안 이미 트리거 되었다면, 단위시간내에 다시 발생한 이벤트는 트리거하지 않도록 무시하자. ==\u0026gt; throttling하자 1 2 3 4 5 6 7 8 9 10 11 12 $ fswatch -Lr ~/w | perl -ne \u0026#39; BEGIN{ $|=1; # autoflush(STDOUT) $SECS=5; $last=time; } { my $cur=time; if($last \u0026lt; ($cur - $SECS)){ print $_; $last=$cur; } }\u0026#39; 조금 문제: 시작하자마, $SECS-이내에 발생한 이벤트는 무시된다. 커맨드 실행은, 위의 xargs 부분 파이프연결을 더하면 된다. 문제 #2: pid-file, kill-switch이 필요해졌다 트리거링 이벤트/입력에 대해 스로틀링하고, 원하는 커맨드를 실행하는 것도 했지만, \u0026#34;재시작\u0026#34;을 위해서는 재시작 대상 프로세스가 좀 더 지원해줄 필요가 있었음.\npid-file : 재시작을 위해 기존 프로세스 id (pid)을 파일에 기록해 두서 그걸 kill해야 하거나, kill-switch : (or) 재시작 대상이 되는 프로세스가 별도의 unix named pipe / socket file을 열고, 그 입력에 따라 스스로 gracefully shutdown 하는 지원이 필요. 기존 프로세스를 종료하려면 어떤 프로세스인지 알아야 할테니까. (단순하게 pkill 등으로 프로세스 이름을 적당히 찍어서 그렇게 해도 되긴 하겠지만)\n시도 #3: 그래서 짜버렸다 throttled-restart.tcl https://github.com/ageldama/throttling-restart.tcl\ntcl 8.6, tcllib 이용해서, 원하는 커맨드를 시작/재시작하고 자동으로 STDIN에 따라 종료/재시작하는 작은 유틸리티를 작성해봤다.\n자동적으로 프로세스를 시작하고, pid을 관리/종료도 자동으로 해주니 재시작 대상 프로그램은 변경/확장될 필요가 전혀 없다.\n후기: tcl 지금 생각해보니, subprocess을 꼭 분리된 thread 안에서 관리할 필요는 없었을거 같기도 하다. 처음 설계할 때엔 blocked 상태에 빠질까봐 분리를 했었지만.\ntcl을 사용해서 뭔가를 진지하게 짜기 시작하니까 재밌었다:\n[ GOOD ] event-loop, evented i/o이 기본이어서 좋았다.\nnode.js, python의 asyncio 등처럼 콜백지옥도 별로 없고, 또 async/await 같은 function coloring 문제도 없었다. 적당히 golang의 i/o system처럼 비동기이지만 적당히 동기형처럼 짤 수 있어서 좋았다. 분명히 callback을 지정해서 이벤트를 처리하는데도 그렇게 콜백지옥이 되지 않아서 신기할 정도. 특히 tcl 입출력 모델은 정말 깔끔하고 편리한 것 같다. [ GOOD ] 스레딩도 신선했다.\nPython, Ruby 등이 모두 GIL문제을1 우회하려 애써야 하거나 했던데 비해서, 단순하게 그냥 Tcl/C API 수준에서 스레드를 만들고 분리된 Tcl Interpreter을 만들어 서로 연결되도록 하는 방식이어서, 문제가 생길 여지가 훨씬 적었다. Perl으로 짰었다면,\nperl / thread으로 좀 고민 했을거 같고, (어차피 결국 안썼겠지만) AnyEvent 모듈을 적절히 썼을거 같다. [ BAD ] 여전히 Tcl 문법, expansion등에 대해서는 가끔 생소해진다.\n현대에 익숙한 언어들(펄, C/C++, Go, Java, Python) 등와는 많이 다르기도 하고. 의외로 Tcl의 간단한 규칙2에서 파생되는 복잡해지는 상황이나, 내장된 String interpolation / Evaluation 규칙 때문에, Escaping이 필요한데, 그럴 방법이 잘 떠오르지 않을 때도 있었던거 같다. [ BAD ] Closure이 바로 지원되지 않아서 거 좀…\nlambda, apply, {*}… 그리고 EIAS으로 해결이 가능하지만, 아직 낯설다. [ BEST ] 그런데 위 (4), (5)은 Tcl이라 생기는 이슈이고, 사실 그런 이슈 때문에 String을 기반으로 한 리습언어 같다, 거기에 바로 현재 쓸 수 있는, 그리고 리눅스/유닉스 시스템에 잘 녹아있는 것이라 좋은거 같다. Footnotes 1 파이썬은 3.14 이후로 GIL을 끈 방식으로 실행할 수 있도록 했지만, 사용해보진 않아서.\n2 https://learnxinyminutes.com/tcl/ 간단한 기본 문법규칙. 정말 다른 언어에 비해서 단순하긴 하고.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/the-x-files-90s-vibe/","title": "🧑‍⚖️ &#34;the x files&#34; / 90년대의 분위기",
     
     "tags": ["the_x_files", "90s", "tv", "show", "thriller", "horror", "mystery", "dana", "scully", "mulder", "fox", "dubbed", "nostalgic"],
     
 "description": "",
 "contents": " 90년대 중반, 학생일 때, KBS2였나에서 그 유명한 시그널 음악과 성우들의 더빙으로 엑스파일을 처음 접했었다. 나는 당시에 이미 \u0026#34;에일리언\u0026#34;, \u0026#34;터미네이터\u0026#34; 같은 헐리웃 영화들을 접해오며 SF취향의 싹을 키워오던 때였던 것 같다.\n그런 \u0026#34;공상과학\u0026#34; 영화나 해외TV 드라마는 SF에 대한 취향, 더 나아가서는 여러가지 가능성의 상상과 특정한 분야에 대한 흥미를 갖는데 도움이 된 것 같다.\n실제로 \u0026#34;스컬리효과\u0026#34;1를 받거나, 철학2에 대한 흥미를 갖기 시작한 것 같다. 물론 \u0026#34;멀더스러움\u0026#34;도 많이 익히게 되었지 않았을까.\n요즘에도 그냥 방에서 뭔가를 할 때에, 항상 틀어 놓고 할일을 하게 된다. 책을 읽건 코딩이나 글을 쓰고 있건.\n수사중이나 수사가 마무리 된 다음에 컴퓨터 앞에 앉아 저널을 쓰고 있는 멀더나 스컬리의 모습을 좋아했던 것 같다. 그리고 지금의 나또한 내가 그런 수사 저널을 정리하듯 글을 쓰고 있다.\n당시 조류에는 가장 트렌디했던지 모르겠지만, 신시사이저를 많이 활용한 bgm은 요즘에도 틀어놓기 좋다. 요즘 관점에선 synthwave/retrowave/futuresynth 감성이어서 편안하다. …오히려 그때 들을 때보다 세련된 음악이란 느낌을 더 받는다. (솔직히 내겐 그땐 신시사이저음악이 촌스럽다고 느꼈었다.)\n물론 더빙판 오디오트랙과 원본오디오트랙을 둘 다 비교해서 들어보면, 원본은 돌비스테레오로 좋은 음질으로 녹음되어 있고, 더빙판은 더빙의 특성 때문인지 당시 kbs에서 구현 가능한 기술적 한계였는지 배경음 등이 더 묻히는 느낌에다가, 전체적으로 모노에 느낌으로 들린다.\n더빙에 오역도 많았던 것 같고. 그도 그럴 것이 잘 들리지 않는 단어, 직역하기 어려운 단어와 표현, 혹은 아예 이해하기 어려운 경우도 있었으리라 짐작해본다. 해외와의 교류가 지금처럼 활발하지 못한 당시를 생각하면 그랬으리라 싶다.\n90년대 서울말투가 그대로 느껴진다. 또 영어버전은 실은 공손히 말한 것도 당시 한국정서에 비춰 봐 캐릭터 간 상하관계가 (약간 일방적으로) 설정되고 그에 따라 경어사용이 on/off되고 표현/뉘앙스/감정강약이 달라지는 경우를 느낀다.\n전혀 어색하다고 느끼지 못했었는데, 이젠 좀 어색하다. 당시엔 세련된 더빙이라고 느꼈었는데. 흥미롭다.\n아마도 그렇게 틀어 놓는 가장 큰 이유는, 어릴적에 TV이란 매체가 그랬었기 때문인 것 같다. 옆에 틀어 놓고 책을 보거나, 컴퓨터를 하던 습관. 그리고 그때의 느낌, 따뜻하고 포근한 집, 내 방에서의 그 평범하던 평온한 날들을 아마도 그대로 다시 느끼고 싶으니까 같다.\n3\nFootnotes 1 https://www.reddit.com/r/XFiles/comments/rvsxz0/the_scully_effect_is_real_and_relevant_today/?tl=ko 엑스파일의 의학박사이자 FBI수사관인 대나 스컬리의 영향으로 많은 여성들이 STEM분야에 대한 흥미를 갖고 진출도 늘었다고 한다.\n2 SF 철학 / 마크 롤랜즈(저)\n3 s03e04 Clyde Bruckman\u0026#39;s Final Repose 마지막 부분에서. 강아지 \u0026#34;퀴퀙\u0026#34;은 이후에도 출연한다. (분량이 너무 적어서 슬펐다)\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/netscape-30yrs-jwz/","title": "🥣 (주절주절) jwz의 netscape navigator 2.0 출시 30주년, 내 기억들, 그리고 오늘",
     
     "tags": ["netscape", "jwz", "lisp", "xscreensaver", "web", "webdev", "js", "javascript", "ie", "mozilla", "firefox", "browser", "webbrowser", "dotcom", "startup", "bubble", "firefox", "msie", "activex", "iphone", "html5", "khtml", "kde", "webkit", "safari", "apple", "nodejs", "chatgpt", "gpt", "openai", "llm", "npm", "shai-hulud-worm", "supply-chain", "antitrust"],
     
 "description": "",
 "contents": " https://www.jwz.org/blog/2025/09/netscape-navigator-2-0-was-released-30-years-ago-today/\njwz1이 넷스케이프 웹브라우저 2.0 출시 30주년 포스팅을 올렸다. jwz은 커먼리습, Lucid Emacs, Xscreensaver 등으로 유명하지만, 가장 역사적으로 큰 족적은 아마도 넷스케이프 웹브라우저의 초기 개발자라는 점일거 같다.\n넷스케이프는 90년대의 닷컴시대를 열고, 우리가 현대에 알고 있는 웹브라우저를 대중이 쓸 수 있도록 만들어준 제품이었다고 생각한다. 그 이전의 Mosaic 브라우저는 내 생각엔 더 딱딱하고 techie이 아닌 사람이 접근하기는 좀 껄끄러웠을 것 같다.2\n넷스케이프 2.0 시점에, 우리가 알고 있는 \u0026#34;JavaScript\u0026#34;이 웹브라우저에 도입되었고, 그이후에 마이크로소프트의 유명한 \u0026#34;Internet Explorer\u0026#34; 시대가 시작된다. (이하 \u0026#34;IE\u0026#34;)\nIE와 Windows 95/98에 끼워팔기으로 시장을 독점하기까지, 넷스케이프는 좋은 웹브라우저였었다.\n사업적으로도 (IE에 밀리기 이전까지는) 성공적이었으리라 생각한다. 물론 제품이 잘 팔렸다기 보다는 IPO을 통한 성장이었던거 같다. 최초 IPO까지 창립후 16개월이 걸렸고, … US$75 during the first day of trading, nearly a record for first-day gain. The stock closed at US$58.25, which gave Netscape a market value of US$2.9 billion 라니까, 지금 환율으로 계산하면, 한화 40조원이고, 당시/지금 인플레이션율을 감안하면 더 엄청난 가치였을 것 같다.3\n내 기억에 따르면, MS Windows와 IE 끼워팔기는 미국의 반독점 재판에 MS이 지기는 하지만… 이미 시장에서 넷스케이프는 밀려나고, IE이 시장을 장악한 이후였었다.\n현대의 웹, 웹브라우저, 웹개발의 형태가 어느 정도 결정된 시점이었다는 생각이 든다. 물론 Viaweb 같은 흥미로운 스타트업/제품이 더 있었고, 그와 관계된 이야기들도 현재의 웹, 스타트업, 웹개발 등등의 모양과 흐름을 결정했으리라 생각한다.4\nIE에 밀려난 이후에, Netscape은 퇴색하고, 오픈소스 재단인 Mozilla이 시작된다. 초기에 IE 이외에 제대로 웹브라우징이 가능한 브라우저가 없었던것 같다. 특히나 한국에서는 더욱 더. 더욱이 리눅스에서 (당시로서는) 현대적인 웹브라우저 대안이 없었었는데, 그나마 Mozilla 웹브라우저가 희망이었었다. (지금엔 Firefox까지 이어지는 계보의 시작)\n당시 상황을 떠올려보면, IE에 의해서 웹환경은 표준에서 멀어졌고, IE이 아니면 웹브라우징을 제대로 하기 어려운 상황이 되어버렸다. 예를 들어, 불과 iPhone이 출시되고, 스마트폰의 영향으로 모바일앱/html5이 제대로 웹표준을 정리해나가기 이전까지, (내 기억이 맞다면) 그러니까 적어도 2007년~2009년도 정도까지도 대부분은 \u0026#34;윈도/IE을 대체할 수 없을 것\u0026#34;이란 인식이 팽배했다. ActiveX, 공인인증서, \u0026#34;보안솔루션\u0026#34; 등등 때문에 기업/인터넷뱅킹 등을 제대로 쓸 수 없었었으니까.\n그 사이에 \u0026#34;누가 리눅스에서 데스크탑 환경 같은걸 기대해?\u0026#34; 같은 시선에 상관 없이, KDE 같은 프로젝트를 진행하던 진영에서 Konquerer 웹브라우저가 개발되어 갔고, 이 웹브라우저를 위한 레이아웃엔진, WebKit이 오픈소스였고, 이 웹킷이 현대의 사파리, 크롬 등등의 웹브라우저의 기반인 것은 누구나 아는 이야기일 것 같다….만 웹킷이, Konquerer이, KDE이, 리눅스와 오픈소스가 그 시작점이었다는걸 제대로 기억하는 사람은 그보다는 적을 것 같다.\n흥미롭게도, 과거의 MSIE 반독점처럼, 최근에 Google Chrome 또한 반독점 재판의 결과가 나왔다. 결과는 MSIE때와는 좀 다르게 나온 것 같지만 말이다. …한 시대가 저물었었고(MSIE), 또다른 한 시대가 한창이었다가 끝나가는 시점이지 아닐까 생각해본다.\n또다른 흥미로운 점은, 최근 \u0026#34;샤이-훌루드 웜공격\u0026#34;을 받은 node.js 커뮤니티도, (직접 관계는 없지만) netscape의 제품 중 웹애플리케이션 서버에서 \u0026#34;server-side javascript\u0026#34;이 이미 시도되었었다고 하더라.5\n그냥 이것저것 기억들이 떠올라서 적어내렸다. 예지나 식견이 빛나는 내용도 아니고 그냥 중얼거림.\n글쎄, 다음에, 언젠가 또 지금 이 시대가 저물어 갈 때쯤 나는 오늘을 어떻게 기억하게 될까. 지금 대단하다고 하는 것들, GPT/LLM 등등이 세상을 어떻게 바꿨을까, 아니면 그저 당시의 버블으로 기억하게 될까.\nFootnotes 1 https://en.wikipedia.org/wiki/Jamie_Zawinski\n2 https://en.wikipedia.org/wiki/NCSA_Mosaic\n3 https://en.wikipedia.org/wiki/Netscape\n4 https://en.wikipedia.org/wiki/Viaweb … \u0026#34;해커와 화가\u0026#34; 같은 서적을 통해서 접할 수 있는.\n5 https://docs.oracle.com/cd/E19957-01/816-6411-10/816-6411-10.pdf \u0026#34;Server-Side JavaScript Guide\u0026#34;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/blog-css-redesign-again/","title": "🚍 블로그 css 조금 더 수정",
     
     "tags": ["blog", "blogging", "css", "css3", "sunview", "solaris", "90s", "gui", "sparc", "sun", "sunos", "cde", "motif", "webdev"],
     
 "description": "",
 "contents": " 너무 흰색 배경에 눈이 짠한거 같아서 바꿔봤다.\ndarkmode 켜면 되기야 하겠지만.\n과거 Solaris/SunOS의 SunView이나 CDE환경 색상을 좀 흉내내고 싶었다.\nhttps://en.wikipedia.org/wiki/SunView https://en.wikipedia.org/wiki/Common_Desktop_Environment 나는 마음에 좀 드는거 같다.\nhugo theme을 정리해서 공개/공유해도 좋겠다는 생각을 하는데… 너무 정리가 않되어 있어서. 다음으로 미뤄야겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/freebsd-why/","title": "🍆 freebsd + 고물랩탑 쓸만하다(재밌다!)",
     
     "tags": ["freebsd", "linux", "laptop", "refurb", "debian", "samba", "asus", "e502ma", "firefox", "chrome", "mpv", "emacs", "dotfiles", "icewm", "evince", "poppler", "pdf", "zathura", "coolreader", "epub", "koreader"],
     
 "description": "",
 "contents": " 시도하기 이전에는 좀 오래되고, 이것저것 맛이 가기 시작한 싸구려 랩탑 asus e502ma-을 서브랩탑으로 집책상에서 써왔었다.\n메모리도 4GB, 확장이 불가능하고. 배터리도 조금 부풀었고 충전도 잘 되지 않는다. 거기에 외부전원어댑터를 붙이지 않으면 어째서인지 eDP이 출력되지 않는다. ㅎㅎㅎ\n그래도 어쨌든 debian-stable 설치해놓고 samba 서버로 책상에서 쓰거나 하기엔 적당했다. 딱히 동영상을 틀어 놓거나 하는 것도 포기해야 할 정도로 빠르지도 않았다. 웹브라우징도 느렸다.\n그러다가 freebsd 설치를 했다 (14.3-RELEASE 1) 원래도 freebsd이 gui이나 latency이 중요한 체감이 훨씬 가볍고 부드럽게 느껴지는걸 알고 있었다. 그런데 이번에는 너무 극적으로 즐거웠다.\nmpv 동영상 보기도 부드럽고(1080p정도도 조금 framedrop이 있긴 하지만), firefox으로 웹브라우징도 나쁘지 않다.\n그리고 emacs 쓰는 것도 부드럽고 좋다. 계속 쓰려고 한다. ㅎㅎ\nSony PS3, PS4, PS5와 Nintendo 3DS, Switch 모두 FreeBSD 커널을 갖다 사용하는걸로 알고 있다. 그리고 단순히 BSD License 때문만이 아니라, 체감성능상 이점이 명확한 것 같다.2\n어떻게 쓰는게 좋았나 리눅스를 쓰는 것처럼 (wayland/gnome/kde 같은 것들을 어차피 원래도 바라지 않았지만) 쓰려고 하지 않고, 약간 포기할거 포기하고 더 가볍게 쓰니 편하고 좋다.\nicewm 만으로 편하고 좋다. ++ 내 dotfiles으로 편안하다.\n원래 리눅스 설정으로도 특별히 무겁다고 생각하진 않았는데 훨씬 가볍게 쓸 것들이 더 남아 있던거 같다. (예를 들어, bashmount을 써왔는데 그런 것도 그냥 안쓰고 doas mount ...-정도로 만족한다)\n사용하는 애플리케이션들도 evince =\u0026gt; zathura, koreader =\u0026gt; coolreader3 정도로 바꿨다.\nevince, koreader도 가볍지만, 더 가볍고 단순한 프로그램들, 그러면서 잘 동작하는 bloat이 적은 애플리케이션들이 더 좋아졌다\n그럼에도 그래도 리눅스데스크탑, 랩탑을 더 사용하고 있다. 물론 집책상에서 혼자 쓰는 메인드라이버는 그냥 freebsd이 되었지만.\nSteam을 돌리거나 다른 애플리케이션이 필요하거나 하면 여전히 리눅스/debian을 계속 쓰겠지만. ㅎㅎ 책을 읽거나 코딩, 글쓰기, 간단한 웹서핑을 위해서는 그냥 앞으로도 freebsd으로 만족하려고.\nFootnotes 1 freebsd은 CURRENT -\u0026gt; STABLE -\u0026gt; RELEASE 순서로 안정화/릴리즈를 해나가니 조금 ports 버전이 더 옛날 것들. (debian의 unstable -\u0026gt; testing -\u0026gt; stable)\n2 MacOS이 FreeBSD의 네트워크 스택 코드나 POSIX Userland만을 갖다 사용하고 커널은 XNU/mach 계열을 쓴 것과 달리. 또한 Linux kernel의 GPL라이센스는 게임콘솔 HW에서 사용하기엔 라이센스가 부담되었을 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/freebsd-exfat-faster-usb-exthdd/","title": "🔴 [작은 팁] freebsd 외장hdd 빠르게 쓰기 (exfat 파일시스템)",
     
     "tags": ["exfat", "ntfs", "fusefs", "fuse", "linux", "hdd", "usb", "exthdd", "filesystem", "freebsd", "luks"],
     
 "description": "",
 "contents": " freebsd을 써오면서 좀 불만이었던게1, usb으로 외장 hdd을 연결할 때 호환성 혹은 성능이 너무 느림.\n그래서 아예 빠른 유선랜을 연결해놓고 samba으로 파일을 백업/공유했었다.\n호환성은 linux luks 지원도 아쉽지만, 대부분의 외장하드 파일시스템을 잘 지원하지 못하는거 같았어서.\n그런데, 이번에 다시 시도하면서 그냥 얌전하게 fusefs + fusefs-exfat 사용하니 그럭저럭 괜찮은 성능이 나와서 이렇게 해야겠구나 생각.\nfusefs + ntfs 같은 port도 있는데, 이것도 빠를거 같지만, exfat이 더 구현이 빠를거 같다. (파일시스템 구조부터 훨씬 단순할테니까)\nFootnotes 1 물론 이런 불만 말고도 freebsd은 wifi칩, bluetooth, gpu지원 등등 hw driver지원이 항상 부족하지만.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-09sep/no-pagefind-anymore/","title": "🩰 블로그 검색을 다시 짰다 (PageFind 제거)",
     
     "tags": ["blogging", "blog", "pagefind", "index.json", "jquery", "ajax", "hugo", "webdev", "fts", "search", "js", "javascript", "rust", "npm", "freebsd"],
     
 "description": "",
 "contents": " pagefind이 freebsd 환경에서 동작하지 않아서, 그냥 다시 짰다.\nfuse.js을 사용하는 예제 등이 있었지만1, 그럴거면 그냥 ajax으로 얻은 index.json-을 직접 검색해도 될거 같아서 그냥 javascript 작성 오랬만에.\n그리고 ui등도 내 취향에 맞게 간단하게 만들어서 만족스럽다.\npagefind처럼 검색어에 따라 필요한 만큼만 http get하는게 아니라 조금 아쉽지만, 전체 index.json-fetch해도 500kb 안쪽인거 같아서 괜찮지 않을까 싶음. (거기에 브라우저캐슁도 먹으니까)\nFootnotes 1 https://findstar.pe.kr/2021/07/10/fuse-search-on-hugo/\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-05may/term-ddakong-v1.1-release/","title": "🩳 ddakong v1.1 릴리즈: FreeBSD / kqueue",
     
     "tags": ["freebsd", "kqueue", "epoll", "select", "linux", "terminal", "fbdev", "fbterm", "korean", "hangul", "hangeul", "input", "method", "im", "ime", "c99", "opensource", "ddakong"],
     
 "description": "",
 "contents": " 릴리즈 v1.1 freebsd 지원: 빌드가능하도록 수정 + kqueue 이벤트처리 추가\n(원래는 epoll/linux만 지원)\n\u0026lt;https://github.com/ageldama/term-ddakong/releases/tag/v1.1\u0026gt;\ndarwin/osx, openbsd 등은 빌드+실행될거 같은데 확신은 못하겠믐. 매 릴리즈마다 크로스컴파일해서 바이너리릴리즈해왔는데, 리눅스는 aarch64, armhf, i686, x86_64 자동화해놨는데, freebsd은 아직이라 이번엔 스킵. …오랬만에 freebsd 켜서 쓰는데, 반응속도감 역시 엄청좋다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-05may/term-ddakong-v1.0-release/","title": "🌹 ddakong v1.0 릴리즈: lua scripting 시스템",
     
     "tags": ["linux", "terminal", "fbdev", "fbterm", "korean", "hangul", "hangeul", "input", "method", "im", "ime", "c99", "ddakong", "shared-object", "shared-library", "dll", "plugin", "lua", "scripting"],
     
 "description": "",
 "contents": " 릴리즈 v1.0 ANSI C/DLL 플러그인만이 아니라, Lua scripting plugin 만들어서, 그냥 루아스크립팅만으로 플러그인 같은 확장이 가능해졌다.\n그리고 이것저것 안정화/문서화하고, 더욱 hackable🪓🔥하고 가벼운 터미널입력기가 되었음.\nhttps://github.com/ageldama/term-ddakong/releases/tag/v1.0\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-05may/term-ddakong-v0.0.8-release/","title": "✝️ ddakong v0.0.8 릴리즈: 안정화 및 플러그인 시스템",
     
     "tags": ["linux", "terminal", "fbdev", "fbterm", "korean", "hangul", "hangeul", "input", "method", "im", "ime", "c99", "ddakong", "utf8", "armhf", "aarch64", "i386", "x86_64"],
     
 "description": "",
 "contents": " 스크린샷: \u0026lt; https://github.com/ageldama/term-ddakong \u0026gt;\n\u0026lt; https://github.com/ageldama/term-ddakong/releases/tag/v0.0.8 \u0026gt;\n릴리즈 v0.0.8 안정화/문서화하고, 이제 플러그인 시스템을 도입해서 원하는대로 hackable🪓🔥한 터미널용 입력기가 되었다.\n플러그인 작성해서:\n한글만이 아니라 다른 언어 입력기로 사용할 수도 있음. UTF-8 이외에 다른 인코딩으로 출력가능함. (예: EUC-KR, EUC-JP …) 토글키(Control-H) 마음에 안들면 바꾸면 됨. 등등등 오늘 한 작업들은:\n안정화 많이 진행했다. 코드 문서화 주석작성 다 했다. cross-platform build 자동화해서 릴리즈 때 편해졌다.\narmhf (raspberry pi 32bit), aarch64 (raspberry pi 64bit), i386 (32bit), x86_64 모두 릴리즈하고 있다. ..혹시나 어디선가 i386 기계 터미널에서 한글을 입력하고 싶은 사람이 있을거 같아서. "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-05may/term-ddakong-initial-release/","title": "👶 ddakong 한글입력기 릴리즈",
     
     "tags": ["linux", "terminal", "fbdev", "fbterm", "korean", "hangul", "hangeul", "input", "method", "im", "ime", "c99", "ddakong", "raspberrypi", "rpi", "raspberry-pi", "armhf", "aarch64", "arm64", "epoll", "utf8", "lua", "dlopen", "c99"],
     
 "description": "",
 "contents": " https://github.com/ageldama/term-ddakong 일단 내가 fbterm에서 가볍게 한글쓰고 싶어서 만듦.\nansi c99만으로 가볍게 작성했다. 다른 라이브러리 의존않고. 만족스럽다. 빌드하니까 25 KB 정도 나오네. 만족.\n더 했으면 하는 일들은:\nlua -or- dlopen 등으로 다른 입력기 지원하기 (예: 3벌식) utf-8 이외의 인코딩 지원하기 raspberry pi 32/64 바이너리 릴리즈 (armhf, arm64) 소스코드 조금 포매팅, 주석작성, 문서화 빌드개선 : 사용하는 함수 등 체크하기 강화 (예: epoll …어차피 거의 다 있지만.) 스크린샷? ㅎㅎ "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-04apr/2025-04apr09--01-i3-bindsyms-rofi-dmenu/","title": "🧬 i3 키바인딩을 rofi으로 확인하고 실행하기",
     
     "tags": ["perl", "i3", "i3wm", "rofi", "dmenu", "which-key", "script", "scripting"],
     
 "description": "",
 "contents": " i3wm 써서 매일 리눅스 사용.\n키보드만 써서 사용하는건 좋은데, 키바인딩이 늘어나서 맨날 i3 키바인딩 까먹음.\n그래서 만들어봤다:\n현재 i3 config에 등록된 키바인딩 자동으로 표시 🖥️ rofi에서 선택하면, 그걸 또 실행까지 해줌 🚀 gist: https://gist.github.com/ageldama/377d00159cfe0cb387f20297ca6a5e6b\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env perl use strict; use warnings; use Carp; use IPC::Open2; sub escape_html { $_ = shift; s/\u0026amp;/\u0026amp;amp;/g; s/\u0026lt;/\u0026amp;lt;/g; s/\u0026gt;/\u0026amp;gt;/g; s/\u0026#39;\u0026#34;\u0026#39;/\u0026amp;quot;/g; return $_; } my @bindsyms = grep(/^bindsym/, # only `bindsym`-s. grep(!/(^#)|(^\\s*$)/, # omit comment or empty lines. qx\u0026lt;i3-msg -t get_config\u0026gt;)); chomp @bindsyms; map { s/^bindsym //g } @bindsyms; my @key_to_cmd = map { my @m = $_ =~ /^(?\u0026lt;key\u0026gt;\\S+)\\s+(?\u0026lt;cmd\u0026gt;.+)$/; \\@m; } @bindsyms; my @dmenu_items = map { my ($key, $cmd) = ($_-\u0026gt;[0], $_-\u0026gt;[1]); $key = escape_html($key); $key = \u0026#34;\u0026lt;span size=\u0026#39;large\u0026#39; weight=\u0026#39;heavy\u0026#39;\u0026gt;$key\u0026lt;/span\u0026gt;\u0026#34;; $cmd = escape_html($cmd); $cmd = \u0026#34;\\t\\t$cmd\u0026#34;; my $result = join \u0026#34;\\n\u0026#34;, $key, $cmd; $result .= \u0026#34;\\0\u0026#34;; $result; } @key_to_cmd; # p @dmenu_items; my $pid = open2( my $stdout, my $stdin, \u0026#34;rofi -dmenu -p \u0026#39;i3 keybindings\u0026#39; -sep \u0026#39;\\\\0\u0026#39; -eh 2 -markup-rows -format i\u0026#34; ) or confess; foreach (@dmenu_items) { print $stdin $_; # print $_; } close($stdin); my $stdout_ = do { local($/); \u0026lt;$stdout\u0026gt; }; close($stdout); waitpid($pid, 0); my $exit_code = $? \u0026gt;\u0026gt; 8; # print STDERR \u0026#34;exit_code: $exit_code\\n\u0026#34;; if ($exit_code == 0) { chomp $stdout_; my $cmd = $key_to_cmd[$stdout_]-\u0026gt;[1]; print STDERR \u0026#34;STDOUT: [$stdout_] =\u0026gt; [$cmd]\\n\u0026#34;; `i3-msg \u0026#39;$cmd\u0026#39;`; } else { print STDERR \u0026#34;EXIT: $exit_code\\n\u0026#34;; } 요걸 저장하고, $HOME/.config/i3/config 에 다음을 추가하여 ⌨️ Super+F1 으로 등록:\nbindsym $mod+F1 exec ~/.config/i3/helpers/i3-keys-rofi.pl …추가 CPAN모듈 의존성 적게 만드는데, shell oneliner으로 처음에 하다가, 그냥 펄로 짜는게 더 가볍고 명확한거 같아서 이렇게 짰음.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-04apr/2025-04apr02--01-antix-linux/","title": "7️⃣ 가볍고 빠른 antiX Linux + runit, koreader 그리고 bloatware",
     
     "tags": ["ping", "linux", "laptop", "retro", "vintage", "hardware", "debian", "runit", "init", "sysvinit", "systemd", "distro", "distrohopping", "software_bloat", "bloatware", "electron", "feature_creep", "ebook", "koreader", "epub", "pdf"],
     
 "description": "",
 "contents": " antiX linux 오래된 랩탑으로 fedora 그냥 아무 생각없이 대충 쓰는데 좀 버벅. 어차피 메인드라이버도 아니고 그냥 그러려니 하고 살다가, 좀 답답해서 lightweight linux distro을 골라봤다.\nhttps://antixlinux.com/\n거기에 이전에 시도했던 void linux에서 마음에 들었었던 runit을 init으로 쓰는 spin으로 선택해서 설치했다.\n결과는… 놀라울 정도로 가벼웠다.\nluks disk encryption + btrfs을 기존에는 적용했다가(btrfs이 기본옵션이어서 귀찮아서), 이번에는 그냥 ext4만으로 설치해서 더 가벼운걸까 싶기도 하고.\nsystemd은 익숙해질수로 편안해지기는 했었는데, 그럼에도 확실히 전통적인 linux/unix의 그것과는 조금 달라서 처음에 당혹스럽긴 했었었다.\n기본적으로 im-config, ibus-hangul 정도만 설치하고 쓰면 한글입력기도 세팅되고, 이것저것 gui control-center을 제공해서, 거기에서 시스템의 각종부분들을 쉽게 세팅할수도 있게 잘 만들어져 있었다.\nantix 자체가 icewm/jwm/fluxbox으로 기본 \u0026#34;데스크탑환경\u0026#34;-을 제공하지만1, 내겐 복잡해 보이고 해서 다 지우고, 그냥 내가 쓰는 dotfiles + i3wm 써서 사용한다. 이게 더 가벼울지는 잘 모르겠다만.\n만족스럽다. 가볍고 정말 빠르다. 어차피 debian stable 기반이라서 패키지도 다양하다. 조금 오래된 랩탑을 쓸만하 쓰기 좋다.\nkoreader https://koreader.rocks/\n전자책 리더, 이것도 산뜻하고 가벼웠다. 그렇다고 지원하는 플랫폼이 적다거나, 기능적으로 별로인 것도 아니었다.\n오히려 자기들이 뭘 만드는지 알고, 필요한 것들을 적절히 선택해서 잘 만든 경우인거 같다.\nbloatware, feature creep …요즘엔 software bloat도 심하고, 실제로 사용도 못할 정도로 무겁게 만드는데, 그렇다고 그 목적을 잘 달성하는 소프트웨어도 흔치 않은거 같다.\nFootnotes 1 파일관리자 rox, zzzfm 같은것도 붙어 있고, 정말 될건 깔끔하게 다 잘된다. "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-03mar/2025-03mar20--01--darkmode-js/","title": "👞 darkmode.js으로 변경",
     
     "tags": ["ping", "blog", "blogging", "css", "js", "javascript", "npm", "darkmode", "webdev", "darkmode.js"],
     
 "description": "",
 "contents": " 직접 짠 css/js에서 darkmode.js으로 변경했다. css에서 보색관계를 고려하는 것도 좀 귀찮고 해서.\n변경도 예쁘게 애니메이션 나오고, system preference 지정도 자동으로 되고.\n(미래의 나를 위해) css/html에서 class 1 2 3 .darkmode--activated .logo { mix-blend-mode: difference; } 1 \u0026lt;span class=\u0026#34;darkmode-ignore\u0026#34;\u0026gt;😬\u0026lt;span\u0026gt; "},
 {
     "permalink": "https://ageldama.github.io/posts/2025-03mar/2025-03mar18--01-xrandr/","title": "🎃 xrandr 🖥️모니터 연결 자동전환 스크립트🐫",
     
     "tags": ["xrandr", "i3wm", "config", "perl", "xorg", "display", "monitor", "script", "scripting", "linux", "windows", "icewm"],
     
 "description": "",
 "contents": " 요즘 메인으로 사용하는 💻랩탑을 i3wm으로 세팅해서 쓰고 있다. 다 편한데, 🪟윈도나 icewm처럼 Windows+P 누르면, 다음 모니터연결 조합으로 전환되는게 부러웠다.\n매번 터미널 열고 xrandr 치거나, arandr 열어서 세팅하기 귀찮으니까. (물론 시스템 시작하면, 내가 좋아하는 설정이 적용되도록 해놓았지만)\n그래서 그냥 윈도의 Win+P 키처럼 동작하도록 스크립트를 짜봤다.\n🐫 https://github.com/ageldama/configs/blob/master/dotfiles/local_scripts/xrandr/combs.pl\nPerl으로 왠만하면 외부라이브러리 의존 않고 짜려고 노력.\n그리고 예전이랑 코딩스타일이 점점 변해가고 있다고 생각이 들었는데, 예전에는 기계공감에 더 비중을 뒀었다면, 이제는 내가 쓸때 더 편하고 별 생각없이 되는쪽에 더 비중을 두게 되는거 같다. 좋게 말하자면… 🤤\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-03mar/2025-03mar16--01-pagefind+hugo/","title": "🚙 Hugo + pagefind 붙여서 검색기능 추가했다",
     
     "tags": ["ping", "pagefind", "js", "css", "hugo", "jquery", "webdev", "javascript", "search", "fts"],
     
 "description": "",
 "contents": " https://pagefind.app/\n페이지 생성시에 인덱싱하고 그걸로 웹브라우저내에서 js으로 검색하는 pagefind을 붙여봤다.\n처음엔 좀 어색했는데, 커스터마이징을 별로 제공하지 않기는 했지만, 그래도 이것저것 뜯어서 CSS도 마음에 들게 좀 수정하고, JS/DOM 이벤트도 적당히 잡아서 마음에 들게 동작하게 고쳤다.\n별로라고 생각하던 부분들도 다 뜯어 고치고 하면서 더 블로그가 마음에 들어진다. 🤠\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-03mar/2025-03mar15--01-new-css/","title": "😹 css, design 새단장 + dark-mode",
     
     "tags": ["ping", "blog", "css", "design", "darkmode", "webdev"],
     
 "description": "",
 "contents": " css 더 단순하게 만들고, 디자인들도 그냥 내 마음에 들게 뜯어 고침. 다크모드도 작업해서 만들어 넣고.\ncss 애니메이션도 작업해 넣었다가, gpu 너무 쓰는거 같아서 그냥 끄고 정적효과로만 냅둠.\nhugo 같은 static site generator이 좋은 점, 그리고 그냥 단순한 css와 오래된 jquery으로 그냥 뚝딱거려서 작업.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2025-03mar/2025-03mar12--01-data-prog/","title": "💻 data-driven programming &amp; data-driven design &amp; data-oriented programming ???",
     
     "tags": ["programming", "data", "design", "architecture", "ecs", "cpu", "cache", "awk", "sed", "perl", "c++", "gamdev", "clojure", "datomic", "clojure.spec", "data-driven-programming", "data-driven-design", "data-oriented-programming", "book", "books"],
     
 "description": "",
 "contents": " 비슷한 용어들. 내가 이해한 정리들은 1:\ndata-driven programming 데이터처리를 중심으로 하는 프로그래밍언어나 도구, 스타일.\n예를 들어, awk, perl은 입력의 패턴에 따라 코드를 나누고 출력을 만들기 수월한 방식을 제공.\nhttps://en.wikipedia.org/wiki/Data-driven_programming a \u0026#34;replacement\u0026#34; for awk and sed (by Larry Wall) data-oriented design 현대 cpu의 아키텍처에 적절하도록, cpu cache, simd등을 잘 적용될 수 있도록 애플리케이션 데이터구조를 설계하는 방식.2\n그리고 단순히 게임개발에서 ecs만이 아니라 lmax disruptor등도 포함될 것 같다.\nhttps://en.wikipedia.org/wiki/Data-oriented_design dod의 예시: Entity component system lmax disruptor (by Martin Fowler) data-oriented programming 그리고 또 갑자기 위 2개의 정의처럼 완전 갑자기, dop은 다음과 같은 원칙들을 이용한 애플리케이션 개발방식:\n( https://blog.klipse.tech/dop/2022/06/22/principles-of-dop.html ) Principle #1: Separating code (behavior) from data. Principle #2: Representing data with generic data structures. Principle #3: Treating data as immutable. Principle #4: Separating data schema from data representation. 다음 책을 재밌게 읽음:\ndata-oriented programming (by Yehonathan Sharvit) 실은 이미 몇년전부터 clojure 커뮤니티, 코드에서는 일반화된 방식이었음.\n분명히 유연하고 복잡도를 확 낮출 수 있는 방식이지만, 제약이 있음. (책에서는 제대로 언급하거나 다루지 않아서 아쉬웠음)\n애플리케이션의 전체 데이터셋 크기가 메모리보다 크다면 적용이 어렵다.\n==\u0026gt; db을 쓰는 전통적인 방식의 애플리케이션을 기반으로 설명하지는 않음. db 연결하는 챕터가 있지만, 실은 일부를 저장/로딩하는 내용일 뿐. multiple-dispatch을 제대로 지원하는 언어라면 더 적절함. (clojure) 당연히 실행시간 분기가 더 많아지므로, 성능이 정말 중요한 경우엔 손해. 그리고 이런 특징들 때문인지, clojure community은 다음과 같은 것들을 만들어 갔으리라:\ndatomic\n링크의 예시에서 보듯이, clojure에서 in-memory자료에 접근하듯이 쿼리 및 데이터 표현. clojure.spec\n실행시간의 값의 내용에 따른 contracts, validations. Footnotes 1 별도의 정리는 하지 않음.\n2 이와 대조되는 방식으로는 전통적인 객체지향 등에서처럼 한 객체 인스턴스가 한 엔티티를 표현하고, 불연속적인 공간에 변수레퍼런스로서 참조/정리되어 있는 구조.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/","title": "🍴 xmake, compile_commands.json, flycheck",
     
     "tags": ["programming", "xmake", "c", "c++", "xmake", "compile_commands.json", "flycheck", "emacs", "clang", "gcc", "g++", "clang++", "cppcheck", "emacslisp", "elisp", "emacs-lisp", "python"],
     
 "description": "",
 "contents": " cmake/warp등을 써보면서 c/c++ 개발할 때에 빌드도구 갖고 놀다가, 이번에 마음을 열고 xmake을 익혀봄.\n마음에 든다. 가볍고 빠르고 좋다.\nccache등도 바로 지원하고, lua으로 스크립팅도 그럭저럭 할만해 보이고, [build.zig](https://ziglang.org/learn/build-system/)스러워서 당연하게도 좋은거 같아.\n계속 쓸거 같다.\nemacs / flycheck + c/c++ 개발할 때에 단점이, 자동적으로 외부 3rd-party 라이브러리의 include-path을 설정해주지 않아서, [dirs-local](https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html) 같은걸 세팅해주길 기대한다는 점.\n그래서 그냥 xmake project -vD -k compile_commands -m debug 같이 compile_commands.json 생성하고,\n이걸 파싱해서 표준출력으로 include-paths https://github.com/ageldama/configs/blob/master/compile_commands_json_incdirs.py 현재 소스코드 버퍼 기준으로 가장 가까운 compile_commands.json 파일 위치 찾는 elisp 함수 https://github.com/ageldama/configs/blob/master/emacs/elisp/compcmdsjson-tiny.el 위 (1)+(2)을 조합해서 flycheck을 위한 변수 1 들을 설정하는 elisp 함수 https://github.com/ageldama/configs/blob/master/emacs/elisp/flycheck-compcmdsjson.el 그리고 위 (3)을 c/c++-mode에 자동적으로 적용하고, 또 단축키도 만드는 elisp 코드 https://github.com/ageldama/configs/blob/master/emacs/feat/flycheck-compcmdsjson.el …요렇게 만들어서 세팅해서 쓰니 편안.\nFootnotes 1 예시 https://github.com/flycheck/flycheck/issues/659\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2024-03mar/2024-03mar23--01-ping/","title": "🧑‍🔬 공각기동대, 1995",
     
     "tags": ["ping", "kino", "anime", "cyberpunk"],
     
 "description": "",
 "contents": " 가끔 다시 본다. 그리고 마지막 장면을 보면서 덕력이 폭발하면서 종종 그런 생각에 빠짐.\n저런 시나리오를 쓴 사람은 어떤 기분이었을까 완전 쩐다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-11nov/2023-11nov05--freebsd-samba4-symlink/","title": "🌉 FreeBSD + Samba 4.16 + Symbolic Links 설정",
     
     "tags": ["freebsd", "symlink", "samba4", "samba", "smb", "fileserver", "mdns", "mdnsd", "avahi", "avahi-daemon"],
     
 "description": "",
 "contents": " freebsd에서 samba 파일서버 세팅은 프비핸드북 참고 https://docs.freebsd.org/en/books/handbook/network-servers/#network-samba\nsymlink을 samba에 노출하기 /usr/local/etc/smb4.conf 파일에 다음을 추가:\n[global] ... allow insecure wide links =\tyes [share] ... follow symlinks = yes wide links = yes unix extensions = no mdns으로 samba 파일서버를 네트웍에 광고하기 보통은 avahi을 써왔는데, mdnsresponder이 더 가볍다고 해서 이렇게 세팅해봄.\npkg install mDNSResponder /etc/rc.conf 에 추가:\nmdnsresponderposix_enable=\u0026#34;YES\u0026#34; mdnsresponderposix_flags=\u0026#34;-f /usr/local/etc/mdnsresponderposix.conf\u0026#34; 호스트이름은 freebsd-samsung 으로 smb서비스를 노출.\n/usr/local/etc/mdnsresponderposix.conf 작성:\nfreebsd-samsung _smb._tcp 445 service mdnsresponderposix start "},
 {
     "permalink": "https://ageldama.github.io/posts/2023-11nov/2023-11nov05--chromium-gtk4-wayland-ibus/","title": "🚖 Debian Bookworm(12.2), Chromium + Wayland에서 ibus 한글 입력 고치기",
     
     "tags": ["debian", "bookworm", "chromium", "wayland", "ibus", "gtk3", "gtk4", "linux"],
     
 "description": "",
 "contents": " 나도 x11에서 wayland 기반으로 옮겨가고 있는데, 다른 것들은 대부분 괜찮거나 포기.1\n가볍고 좋은데, debian chromium에서 ibus으로 한글 입력이 안되어서 알아봤다.\n1) 문제 원인 :: gtk3 backend으로 chromium이 동작해서, ibus연동이 안됨. 힌트 얻음: https://bugzilla.redhat.com/show_bug.cgi?id=2058976 2) 확인 :: 실행중인 chromium이 어떤 버젼의 gtk3/4와 연결되었는지? 1 2 3 4 for pid in $(pgrep chromium); do #echo $pid grep -i gtk /proc/\u0026#34;$pid\u0026#34;/maps done ==\u0026gt; 기본 bookworm/chromium 상태에서는 gtk3임을 확인. ~~\u0026gt; ibus 연동안됨.\n3) 실행커맨드/스크립트 확인 dpkg -L chromium-browser 으로 desktop launcher 확인 /usr/share/applications/chromium-browser.desktop 확인 /usr/bin/chromium-browser 스크립트 읽기\n$HOME/.chromium-browser.init 에서 읽어들인, CHROMIUM_FLAGS 플래그를 전달함을 확인. 그렇게, $HOME/.chromium-browser.init 작성:\n1 2 export GTK_IM_MODULE=ibus export CHROMIUM_FLAGS=--gtk-version=4 EDIT : [2023-11-26] GTK_IM_MODULE 추가 및 export 으로 수정. chromium 프로세스가 어떤 gtk3/4 연결되는지 확인 (다시) 성공! ㅎㅎㅎ 아직은 debian stable은 wayland이랑 붙이려면 약간은 hack이 필요. 그럼에도, 확장포인트가 있도록 packaging되어 있어서 debian 좋음. https://github.com/ageldama/configs/tree/master/dotfiles 에도 추가해서 계속 재사용 가능하도록 정리도 끝. Footnotes 1 포기도 좀 했음. x2x을 사용해서 네트웍으로 입력장치를 공유하거나 하는 것 정도.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-03mar/2023-03mar15--wired-desktop/","title": "🐀 내 책상에서 유선랜 환경",
     
     "tags": ["tip", "emacs", "ssh", "sftp", "tramp", "x2x", "wired", "ethernet", "wireless", "raspberry-pi", "power-consumption", "fanless", "xorg", "wayland", "xdotool", "warpd", "qjoypad", "gamepad", "ssh", "ssh-x11-forwarding", "x11", "rpi", "raspberry-pi", "raspberrypi", "conspy", "dhcpd", "dnsmasq", "mac", "ssh-add", "ssh-agent", "tramp"],
     
 "description": "",
 "contents": " 개인환경을 조금 특이하게 사용하는데, 그 이유와 방식.\nwhy: 유선랜? (무선랜 대신) 키보드/마우스 입력이 가장 부드럽게 전달되어서 유선으로 연결해서 사용한다.\nx2x으로 연결하거나, ssh-x11-forwarding으로 다른 컴퓨터에서 실행하는 프로그램을 디스플레이와 입력장치만 현재 자리에서 그대로 사용할 때에 네트웍 연결속도가 딜레이가 적어야 쾌적해서. 1\nwhy: x11? (wayland 대신) 요즘 리눅스/bsd 데스크탑 기본설치하면 wayland으로 세팅하는 경우도 많은데, 네트웍을 통해서 ssh-x11-forwarding 1 사용하거나 x2x 사용하기는 아직 부족한거 같아서, 나는 그냥 x11 사용함.\n거기에 xdotool 같은 gui-automation/scripting이나 warpd 같은 키보드를 마우스으로 편안하게 쓰도록 해주는 xtest이나, qjoypad 처럼 2 게임패드/조이스틱을 편안하게 마우스/키보드으로 매핑해서 쓰는게 나는 많은데 모두 x11만 지원하거나, 아직은 x11에서만 쓸만한 수준으로 동작해서.\nwhy: raspberry pi 3? (rpi4이나 더 사양이 높은 본체 대신에) 책상의 메인데스크탑, 메인모니터는 raspberry pi 3을 연결해 놓고 사용한다.\n훨씬 더 빠른 raspberry pi 4도 갖고 있고, 랩탑이나 사양 좋은 데스크탑 본체도 있는데, 다들 모니터를 연결해서 사용하지 않거나 옆자리에 추가모니터에 붙여 놓고 사용함.\n게임을 하거나 할 때엔 추가모니터에서 별도로 하면 되고, rpi4이나 pc본체의 쿨링팬 소리를 별로 좋아하지 않아서.\nraspberry pi 3 b+을 메인데스크탑처럼 사용하면 fanless으로 세팅이 가능하고, 전자책을 읽거나 글을 적거나 하는데에 오히려 더 쾌적하다.\n다양한, 그리고 잡다한 기능들이 모두 너무 rpi3이 느려서 제한되기 때문에, 오히려 더 편안하다.\n그리고 정말로 다른 기능들이 필요하다면, 네트웍을 통해서 다른 컴퓨터를 연결하고 제어해서 필요할 때에 편안하게 사용할 수 있으니까, 그때그때에.\nx2x, conspy =\u0026gt; 다른 포스팅 참고.\nip addresses, mdns/avahi 유선랜 환경 내에서, 각 host마다 mac address 정도에 따라서 고정된 ip주소를 할당해주도록 세팅했다. dhcpd이나 dnsmasq 같은걸 이용하면 가능함.\n=\u0026gt; 이것도 과거 포스팅 참고.\n또, avahi/mdns 세팅을 호스트마다 해놓아서 avahi-browse 이용해서 어떤 호스트가 어떤 ip주소인지 확인도 쉽게 해놓았음.\nmdns/nss 세팅하면, ping FOOBAR.local 같이 호스트이름 + .local 으로 바로 접근도 가능해서 편함. 3\nssh-keys, ssh-agent 네트웍으로 여러대의 컴퓨터들을 서로 연결하게 되는데, 당연히 서로 ssh-key을 ssh-copy-id 같은걸로 등록해주고, 또 키를 사용하는 호스트에서 ssh-add, ssh-agent, gnome-keyring 같은걸 사용해서 편리하게 비밀번호 입력 없이 활용하면 편안.\nemacs/tramp + sshx 이맥스에서 tramp을 이용해서 다른 컴퓨터의 파일을 편집하거나 하기 편안.\ndired이 파일관리를 하거나 하기에 편하기도 한데, tramp을 이용해서 /sshx:USER@HOST:/ 와 같이 접속해서 바로 사용을 지원해서 좋음.\n그리고 더 나아가서, dired이든 파일편집이든 tramp으로 접속한 상태에서 eshell 실행하면, 접속한 호스트의 쉘을 연결해서 별도로 ssh접속할 필요도 없음.\nFootnotes 1 참고 https://unix.stackexchange.com/questions/12755/how-to-forward-x-over-ssh-to-run-graphics-applications-remotely\n2 참고 qjoypad 관련\n3 참고 https://wiki.archlinux.org/title/Avahi "},
 {
     "permalink": "https://ageldama.github.io/posts/2023-03mar/2023-03mar08--02-ping--news/","title": "😣 News 08/03/2023 .02 : reactjs, rust, zig, hiring, nes",
     
     "tags": ["news", "ping", "react", "js", "frontend", "interview", "homebrew", "react-hooks", "js", "nes", "nintendo", "retro", "cpp", "rust", "zig", "stl", "reactjs", "javascript", "webdev"],
     
 "description": "",
 "contents": " \u0026#34;리액트가 날 인질으로 잡고 있어요\u0026#34; https://emnudge.dev/blog/react-hostage\n…말해 뭘할까 싶은데. :see_no_evil:\n포스팅 자체는 react, hooks 같은 것들의 complexity에 대한 이야기이지만.\n오히려 흥미롭게 생각하는 것은, 과거 한국에서 \u0026#39;퍼블리셔\u0026#39;라고 하던 사람들이 어떻게 되었는가 생각해보며, 함께 지금의 \u0026#39;프론트엔드 개발자\u0026#39;, 혹은 \u0026#39;앱 개발자\u0026#39;, \u0026#39;리액트 개발자\u0026#39;, \u0026#39;자바스크립트 개발자\u0026#39;들이 앞으로 어떻게 될지 상상해본다.\n대부분의 현재의 저런 테크/키워드들은 완전히 사라질거 같고, 그렇다면 다른 직종으로 우회하거나, 변화된 상황에 맞춰가겠지 싶다.\n\u0026#34;헛소리/bullshit 없이 엔지니어링 재능이 있는 사람을 고용하기\u0026#34; https://jes.al/2023/03/how-to-hire-engineering-talent-without-the-bs/\n…뭐 homebrew 만들었지만, binary tree inverse을 화이트보드 코딩하라고 던져 놓고 마음에 안든다고 거절한 인터뷰는 전설이지. ㅎㅎ\n사실 안티패턴스럽게, 어떻게 하면 더 나쁜 상황과 못된 사람들인지 자랑하려고 들기만 하는게 문제인거 같아. 그렇게 굴어야만 잘될거라고 전제하는게 보통이지만. (그리고 그 보통이 유익한지는 의심스럽다만)\n이 글에서 인터뷰 대상자의 어떤 특성들을 눈여겨 보고, 필요한 것이 무엇인지, true positive을 찾아내는게 중요하다고 잘 설명하는거 같아.\n최근 읽은 책은 1998년도에 쓴 책이었었는데, 글쓴이의 깊은 안목에 대해 많이 놀랐었다. 그저 별거 아닌 컴퓨터시스템 체험기 같은 것들을 소재로 삼았지만, 현재 전세계적인 테크, 스타트업, 글로벌화 같은 이슈들을 이미 그때에 그 원인이 무엇이었는지까지 분석해 설명해주고 있었다. …어쩌면 그런 안목을 보여줄 수 있었던 이유는, 이미 나보다 연륜이 당시에 많으셨을거고, 그리고 그보다는 테크기업/시장이 훨씬 오래 되었고, 주주자본주의에 기반하여 동작하는 미국사회였기 때문일거 같아. …물론 지금 시대의 한국도 그 연장이겠지만.\n…여하튼, 다시 돌아와서, 저 링크의 이야기처럼 시도라도 하려고 할만큼 성숙해질 수 있을까 싶기도 하다.\n\u0026#34;NESFab is a new programming language for creating NES games\u0026#34; https://pubby.games/nesfab.html\ngameboy이나 nes용 toolchain을 만들어서 공개하거나 하는 사람들이 종종 인터넷에 보인다.\n어차피 이제는 target system에 대해 빌드가 gcc/clang만으로도 쉽게 할 수 있기는 한 시대이지만.\n이게 이상한 괴벽이라고만 하기 어려운게, 게임을 만들기 위해서 필요한 도구들이 컴파일러나 어셈블러 이외에도 스프라이트 그리기 도구나 맵편집기 같은거 등등 많이 필요할테고, 효용면에서도 여전히 작고 창의적인 게임을 만들기에, 그래서 갖고 놀고 즐기기에 나쁘진 않은거 같아.\n\u0026#34;zig이 rust보다 빠르고 안전할 수 있는 경우\u0026#34; https://zackoverflow.dev/writing/unsafe-rust-vs-zig/\n사실 이미 c++은 최근의 표준에서 더 그만의 영역을 확고하게 해나가고 있다고 생각한다.\n개인적으론, cpp2, cppfront 같은 시도들이 의미있지만, c++ 표준에서 반영되듯이, c++은 자기가 정말로 어떤 특징이 있고, 다른 어떤 언어들과도 차별되는 비대칭적인 장점이 있는지 잘 이해하고 있는거 같아. (물론 그런걸 잘 이해하는 분들이 표준위원회에서 작업들을 하고 계시겠지)\n\u0026#39;modern c++\u0026#39; 표준부터, 최근의 c++ 표준스펙들의 추세들은, 사실 함수형프로그래밍 같은 유행(…그것도 한 20~30년 정도 늦어서야 유행을 타는) 트렌드를 어느 정도 반영해주는 척을 하지만, 그보다는 오히려 modern cpu architecture이나 simd 같은 영역, 혹은 caching/predictive-execution 같은 것들을 잘 지원하기 위해서 발전해 온 것 같아. …어차피 90년대부터 stl이 있었었고, 함수형프로그래밍이나 그런게 이제서야 그러는게 \u0026#39;아.. 그래요?\u0026#39; 같은 느낌이었으니.\n그리고 그런 기계에 더 적절한 방식으로 내 코드에 반영될 수 있는 기능들은 c언어 표준에서부터 세세하게 많고, 컴파일러가 더 똑똑하게 최적화를 해줄 수 있도록 발전해온거 같다.\n…여튼, rust은 그런 \u0026#39;함수형프로그래밍\u0026#39;의 트렌드와 그 의도와 기대를 잘 반영해준거 같아. 컴파일러가 알아서 잘, 안전하고 빠른 코드를 뽑아주도록 하자. 그러면서 사용자는 우아한 수준의 abstraction으로 코드를 작성하도록 해주자. rust특유의 메모리모델 때문에 우아하지 못하고 생각할수도 있겠지만, 충분히 깔끔하고 멋진 코드를 짤 수 있고, 또 그게 컴파일되면 확실히 zero-cost abstraction스러워 보인다.\n반면, zig은 명확하게 이해될 수 있는 코드, 그래서 조금은 작성할 때에 우아함에 신경쓰지 말라고 이야기 해준다. 컴파일러와 자기 코드를 읽는 사람(자기자신과 동료 모두)를 고려해서 언어를 만든거 같아: https://ziglang.org/documentation/0.1.1/#zen\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-03mar/2023-03mar08--01-ping/","title": "⁉️ Ping 08/03/2023 .01 : 전자책읽기",
     
     "tags": ["ping", "desktop", "laptop", "pc", "linux", "calibre", "epub", "ebook", "mobi", "ps4", "dualshock", "qjoypad", "reading", "book", "books"],
     
 "description": "",
 "contents": " linux에서 전자책 편안하게 읽는 방법들 간단하게 몇가지 팁들만 나열, 별로 내용은 길게 늘여 쓰지 않으려고:\nlinux, 그중에서도 가벼운 하드웨어와 단순하게 잘 동작하는 배포판.\n여러가지 불필요한 군더더기 없고, 패키지들이 조금 오래된 버젼이어도, 안정적으로만 동작하면 상관 없음. 그래서, debian stable -or- testing 쓰면 속이 편함. 하드웨어는 raspberry pi 3/4 둘 다 좋았다. 1 …특히 전력소모도 거의 없고, 딱 모니터 연결해 놓고 팬소음 거의 없이 쾌적하게 책을 읽기 좋다. calibre 책파일 관리, 읽기 모두 만족스러움\n터미널에서 책 읽을 수 있는 도구들도 좋지만, 가변폭 폰트 써서 읽는게 더 편하면 calibre. 터미널용은 epr 정도면 깔끔하고 잘 동작했다. xbox gamepad이든 playstation 4 dualshock이든, usb이나 bluetooth으로 연결 가능한 게임패드를 활용하면 편안하다.\n특히 ps4 dualshock은 아예 터치패드 부분이 마우스기능도 해주고, bluetooth연결/usb연결 모두 가능하고, 또 이어폰 꼽아서 사운드카드 역할으로도 해줄 수 있어서 여러모로 편리하다. 게임패드 연결했으면, qjoypad으로 세팅해서 마우스/키보드처럼 사용이 가능. 게임패드 쓰면서, 키보드/마우스 쓰려고 자세가 구부정해지지도 않고 편안하게 읽기가 가능해서.\nipad, kindle paperwhite 같은 전자종이/전자책 리더기기나 스마트폰보다 이렇게 그냥 책상에 앉아서 읽는게 더 편안해서.\nFootnotes 1 rpi3은 조금 느리다 싶으면, 돈 더 들여서 rpi4. 만족스럽다. 어차피 rpi4부터 버벅거리는건 micro-sd 입출력에서 버벅이는거라, 그것도 usb외장하드+usb허브(전원공급되는) 정도에 설치해서 (전력소모를 조금 더 늘리고) 더 빠르게 만들어서 사용한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-03mar/perl-cal3/","title": "🧧 `ncal -3` 직접 Perl으로 짜봤다",
     
     "tags": ["perl", "ncal", "cal", "unix", "commandline", "ansi", "term", "calendar", "linux", "script", "scripting", "programming"],
     
 "description": "",
 "contents": " ncal -3 이 뭐냐하면:\nhttps://man7.org/linux/man-pages/man1/cal.1.html\n…뭐 이런건데, 개인적으로 저전력 글쓰기 전용머신에서 사용하는 스크립트에서 배포판이 달라서 패키지를 못찾겠어서 1, …그냥 직접 짜서 대체했다.\nhttps://github.com/ageldama/configs/commit/66bd92b42ba5a5ee03b9336370c3a8f84293e488\n그래서 스크린샷은:\n재밌었던 부분은:\n어차피 Perl으로 전부 짜서 쓰는 스크립트였는데, 아예 외부 커맨드라인 도구 의존성을 더 없애서 뿌듯하다. 매달 달력을 문자열으로 뽑았는데, 3달치를 뽑아서, 이걸 한 row에 표시하고 싶었는데, Text::Table으로 적절히 간단히 완료. Term::ANSIColor와 perlre을 써서 깔끔하게 원하는 일자에 highlighting 해서 편안했다. …더 해킹을 해서, calendar(..) 결과문자열을 적당히 파싱해서, 작은 Text::Table으로 만들어서, 그것들으로 조합하고 했었어도 될거 같아.\n그리고 그렇게까지 했다면, 일자highlighting에 색상만이 아니라 추가 문자를 붙일수도 있겠지 (예: \u0026lt;\u0026lt;..\u0026gt;\u0026gt;), 지금은 레이아웃이 깨지니까 그냥 색만 칠했다. Footnotes 1 opensuse tumbleweed에서는 못찾겠어서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-03mar/cxx-defer/","title": "🍯 C++: Golang-ish `defer`-macro",
     
     "tags": ["c++", "golang", "defer", "raii", "setjmp", "longjmp", "macro", "try-catch-finally", "cxx", "programming", "java"],
     
 "description": "",
 "contents": " 별거 없는데, 문득 심심해서 툭닥거려봤다.\n원하는 것과 접근법 https://go.dev/blog/defer-panic-and-recover https://docs.rs/defer/latest/defer/fn.defer.html https://ziglang.org/documentation/master/#defer golang/zig에서처럼 defer 등록한 LIFO순서대로 호출되도록.\n검색해보면, 대부분 RAII을 사용하거나 하는 것들이 보인다:\nDDG: c++ golang defer https://stackoverflow.com/questions/33050620/golang-style-defer-in-c https://stackoverflow.com/questions/45617758/proper-way-to-release-resources-with-defer-in-a-loop https://codesire-deng.github.io/2022/02/06/One-Minute-to-C-defer/ …그냥 std::shared_ptr\u0026lt;void\u0026gt; 을 이용하는 방식이 마음에 들었다. 그리고 조금 더 간단하게 사용하려고 매크로로 만들어 봤다.\ndefer.inl : 1 2 3 4 5 6 7 8 9 10 11 12 13 /* -*- mode: c++; -*- */ #ifndef defer_INL #define defer_INL 1 #include \u0026lt;memory\u0026gt; #define _Defer_CONCAT_IMPL( x, y ) x##y #define _Defer_CONCAT( x, y ) _Defer_CONCAT_IMPL( x, y ) #define Defer(blk) std::shared_ptr\u0026lt;void\u0026gt; _Defer_CONCAT(Defer_, __COUNTER__ )(nullptr, blk) #endif /*defer_INL*/ __COUNTER__ 이용해서 매크로가 생성한 std::shared_ptr\u0026lt;..\u0026gt; 변수의 이름이 겹치지 않도록 해봤다. (…위에 검색한 링크들에도 사용하듯이)\n사용예 defer.cpp 정도로 저장하고, chmod +x defer.cpp \u0026amp;\u0026amp; ./defer.cpp :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #if 0 g++ -v -pedantic -Wall -Wextra -Wpedantic -Wconversion -std=c++11 -O0 -g -fsanitize=address \u0026#34;$0\u0026#34; -o \u0026#34;$0\u0026#34;.exe \u0026amp;\u0026amp; ./\u0026#34;$0\u0026#34;.exe ; exit #endif #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026#34;defer.inl\u0026#34; int main(void) { int* x = new int{42}; Defer([\u0026amp;](...){ printf(\u0026#34;defer: main #1: %d\\n\u0026#34;, *x); delete x; }); Defer([](...){ printf(\u0026#34;defer: main #2\\n\u0026#34;); }); return EXIT_SUCCESS; } asan 사용해서 간단하게 잘 동작하는지 확인해봤다. TIP: shell script처럼 그냥 cpp 소스파일 실행하면, 스스로 컴파일하고, 스스로 실행하도록 해봤다. 컴파일옵션 변경해서 써도 좋고, 아니면 직접 커맨드라인에서 옵션들 변경해서 컴파일해도 되겠지. 제약사항과 생각해볼꺼리 try/catch/finally 대신, 이렇게 처리하는 것도 간결하기는 한거 같아. C++은 원래 RAII이니까, 다른 try/catch/finally 같은 접근보다는 이게 더 \u0026#39;C++ idiomatic\u0026#39;하겠지 싶어,,라고 자기만족.1 그리고 당연히, setjmp/longjmp등과 섞어 쓰면 동작하지 못한다. ㅋㅋ 2 Footnotes 1 C++을 Java처럼 쓸 이유도 없고, C++은 그자체로 다른 특성과 장단점이 있으니까.. 그걸 꼭 자바처럼 되어야 한다고 할 필요는 없겠지.\n2 신비로운 SEH/libunwind등으로 어떻게 해킹해서 되게 해도 되겠지만… 생각해보면 어차피 C++ exception handling이 자연스럽게 destructor호출해주고 하니까.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb26--01-css/","title": "⛲ Ping 26/02/2023 .01 : 디자인 css 가볍게 수정",
     
     "tags": ["ping", "css", "theme", "webdev"],
     
 "description": "",
 "contents": " 아예 아무런 스타일도 주지 않고, 그냥 알아서 html/css만으로 잘 보이도록 고쳤다. 웹폰트니 그런것도 그냥 껐고.\n불필요한 스타일이나 폰트로딩을 줄여서 가볍고, 어차피 웹브라우져의 \u0026#39;reader mode\u0026#39; 지원 같은걸로 내가 스타일 주는 것보다 훨씬 읽기 편안하게 볼 수 있을테니까.\nlynx, w3m 같은 텍스트 웹브라우져에서 읽으나 그냥 무거운 웹브라우져으로 읽으나 사람마다 알아서 잘 읽히도록 하는데에만 집중해봤다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb19--02-ping/","title": "💤 Ping 19/02/2023 .02 : 이름에 대한 추측 (2) HAL, IBM, JCL",
     
     "tags": ["ping", "ibm", "hal", "jcl", "naming", "computing"],
     
 "description": "",
 "contents": " (…지난번 C/C++/D/Zig 이름에 대한 추측 에 이어서, 그냥 떠올라서)\nHAL 9000 –\u0026gt; IBM\nASCII방식, 혹은 그냥 알파벳에서 한글자씩 앞으로 땡기면, \u0026#34;IBM\u0026#34;이 된다. JCL\nIBM의 \u0026#34;Job Control Language\u0026#34;, 메인프레임 등에서 스크립팅을 위해 쓴다고 한다. \u0026#34;IBM\u0026#34;에서 다시 또 한글자씩 앞으로 땡기면, \u0026#34;JCL\u0026#34;. ㅎㅎ뭐 그냥 그렇다고.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb19--01-ping/","title": "🈲 Ping 19/02/2023 .01 : 어른이 되기",
     
     "tags": ["ping", "adult", "responsibility", "forever-boy"],
     
 "description": "",
 "contents": " (최근 며칠 우울하고 내가 어른이기는 한가 싶은 자괴감에 빠졌었다. 그래서인지 자기합리화를 위해 이런 글을 쓰고 있는거 같기도 하다.)\n나의 옛날 이야기 80년대의 기억에는, 참 자주도 불량식품 단속에 대한 이야기가 나오던 것 같아. 그리고 실제로도 만화, 애니메이션, 게임, 장난감 등등의 라이센스나 품질관리에 대한 관념이 희박했던거 같아.\n지금은 이것저것 검정이나 인증마크를 더 붙이기 바쁘게 되어서 너무 과도하지 않은가 싶을 정도니까, …그래도 없는 것 보다는 낫지 않을까.\n물론 80, 90년대는 일본문화개방도 되지 않았었고 엄밀하게 말하자면 불법은 아니었을테고, 더 나아가서 어린 국민들을 염려한 윗분들의 지시로 수많은, 한국산 고전애니메이션이 본의 아니게 붐을 일으켰었다는거 같다.\n그때에 윗분들은 사단장이나 그 이상의 분들이셨을테고, 군대에서 지시를 내리듯이, 병사들을 관리하듯이 그렇게 국민들 생각하시던 것은 아닐까 싶기도 하고, 문득 문득 관련자들이 어떤 이익을 얻었을까 상상도 해본다. 물론 그분들이 좋은 사람이었다 나쁜 사람이었다 내가 판단하고 말하고 싶은 생각은 없다. 이 글에서는.\n어른의 사정 문득 사회생활을 한지가 오래 된거 같은데, 나름대로 많은 \u0026#39;어른\u0026#39;들을 보아 온거 같은 생각이 들었다. 그리고 그런 어른들 틈에서 그다지 다르지도 않은 공통점이 조금 지겹다.\n그 공통점은, 당연한 이익을 위해서, 또는 당연한 손해를 방지하기 위해서 이런 저런 논리에 묶여서 판단하고 행동할 수 밖엔 없다는 점이다.\n흔하게 말하는 \u0026#39;어른의 사정\u0026#39;1\n그런데 어떤 어린이는 어른을 이해한다. 때로는 그때에 내가 사고 갖고 놀고, 실망케 하던 장난감들이 떠올랐다. 설명서를 따라서 조립을 하려고 해도 부품이 불량이거나 품질이 너무 떨어져서 마음대로 갖고 놀지도 못해서 어린 마음에 화가 나기도 하고 뭐가 문제인지 잘 이해하지 못했었던거 같다. 지금에 돌아서 보면, 어째서 그랬었고 뭐가 어떻게 문제였었던가 어느 정도 알것도 같은 그런 기분이 들지만.\n아마도, 당시의 한국의 경제상황, 사회구조상 생존을 위해서는, 아마 그게 경제적인 최선이었겠지 추측한다. 공산품의 품질을 올리기도 급급했을테고, 그런 장난감만이 아니라, 아마도 세상에 계속 있어 왔을 식빵 같은 상품의 브랜드도 (내가 기억하는 것만해도) 시대를 거듭하며 취향이 변해왔던 것이 기억이 난다.\n그런 사정을 이해하고 공감한다. 나 또한 생존하기 위해서, 그리고 또 성장해서 다음에 더 나은 기회를 얻으려면 당장에는 초라해질 수 밖엔 없었을 것을 너무나 진심으로 공감하고 그 마음이 정말로 오늘을 살고 있는 나는 정말로 고맙다. 그리고 어떤 이들은 정말로 그렇게 생존을 했기 때문에 꽃을 피워 냈을지도 모르니까.\nThe Overfitting 과거에 대한 생각에서, 현재로 다시 돌아와보자. 나는 아담스미스가 말했다고 전설 같이 전해지는 \u0026#39;이기적인 역할자들만 있다 해도 경제적으로 발전하고 결국 사회전체는 이익을 얻는다\u0026#39;고 누군가 자기합리화를 위해 말하거나 하면 뭔가 기분이 묘하다.2 그래서 스스로도 냉혹하고 자기 이익만을 위해야 한다고 믿고 또 그렇게만 행동하기 때문에 오히려 이 치열한 사회의 어른으로서 행동하지도 못한다는 생각이 들었다.\n무슨 말인가 하면, 나는 그런 생각을 자주하고 살았었다. 그 생각이란, 어떤 제품이나 서비스가 엉망이 되거나 품질이 떨어지거나, 그냥 어떻게든 더 사용자의 주머니에서 돈을 더 가져가는 것에만 고민하고 있는게 느껴질 때에 드는 바로 그 생각 말이다.\n사용자나 소비자로서만이 아니라, 그런 제품이나 서비스를 만드는 기업에서 일을 해본 경험이 있다면 다음과 같은 생각을 공감하기 쉬울거 같다:\n무한경쟁이나 이윤의 추구의 과정에서 사용자나 세상을 좋게 만드는 결과물을 만들어 낸다는 말은 허구적이다. 오히려, (당연하게도) 이윤추구이나 경쟁 그자체에 더 적합하게 적응할 뿐이다. 그 과정에서 말하는 사용자를 위해서라느니, 세상을 위해서라는 말들은 실제로는 목적점이 아닌, 그저 그런 과정의 일부로서, 경쟁도구의 일부로서, 대칭적으로 갖춰야만 하는 전력이라고 생각해서 갖다 붙여진 말일 뿐이란 것. 물론 다들 그렇게 말할거 같아. 그래야 누군가는 상대가 순박하게 어리석은 사람들이길 바라면서 더 생산적이길 기대하며 저런 것들으로 환상을 심어주고 올바른 궤도에 있다고 믿게 만들고 싶을 때에도 허울삼기 좋을거 같다. 3\n아마도 애시당초 기업이란 이윤추구와 경쟁이 없이 어떻게 생존하겠느냐고 반문하겠지만, 그걸 부정하고 싶은 것이 아니라, 그 캐치프레이즈나 슬로건의 공허함을 지적하고 싶을 뿐이다. 그런 캐치프레이즈나 광고문구, 슬로건을 내걸려면, 적어도 일말은 그런 것을 구현하는 것을 더 비중을 두기를 바란다는 말을 하고 싶은 것이다.\n아직은 어린 마음인, 그래야만 한다는 강박 소시오패스나 싸이코패스를 두려워 하는건지, 아니면 숭배하는 것인지 잘 가늠하게 어려운 뉴스, TV프로그램을 종종 접한다. 내 생각에는, 불편하고 경계는 해야겠지만 두려워 하거나 숭배해서는 안되는거 같은데 말이다.\n잔혹하고 끔찍한 뉴스를 접하면서, 싸이코패스이니 소시오패스이니 말하면서 무리를 지으며 여론을 만들고, 스스로는 정상인, 혹은 선하다고 인증을 받아서 무리에서 거절 당하지 않는 위치에 속하기를 바라는 것 같다. …그렇게 무리를 짓고, 돌팔매질을 하고 손가락질을 함으로써 무리 안에서의 소속을 확인하는게 본능일테니까.\n하지만 그런 한편으로는 또 픽션에서는 소시오패스나 싸이코패스들을 그리며, 냉혹하게 이익만을 추구하며 인간성이 없는 이들을 그리며 또 그들의 냉정하고 침착함, 그리고 성공적인 모습을 보여준다.\n내가 생각할 때엔, 그렇게 사회적으로도 성공적이지 못할거 같다. 그리고 스스로도 그렇게 행복하지 못할것 같다. 그래서 숭배할 이유도 없지 않나 싶다.\n그리고 혹여 남들이 내게 그런 프레임을 씌우려고 한다고 해도 유치하다고 느껴진다. 위에 말한대로 그 무리짓기 본능에 호소하고 싶을 뿐인, 그렇게 프레이밍하는 사람 스스로가 아마도 훨씬 더 인간보다는 짐승에 가깝다고 스스로 공표하고 있는 것을 모르고 있을 뿐이니까.\n어째서인지, 아담스미스에 대한 오해/곡해와 마찬가지로, 공공연하게 \u0026#39;경제적 인간\u0026#39;이란 그런 소시오패스/싸이코패스일거라 생각하며 모두 행동하는거 같다는 생각이 들었다.\n하지만 인간적인 공감이나 연민 없이, 그렇게 행동하는 것이 정말 경제적인 이익을 가져오지 못할거 같은데 말이다.\n이 세상은 아귀지옥과 같은 것이 사실인거 같다. 하지만 그렇다고 내가 꼭 짐승이나 아귀로서 생각하고 행동할 이유가 되지는 못한다. 어리고 약한 마음이라면, 세상 모두가 그렇기 때문에 나 또한 그렇게 할 수 밖엔 없지 않느냐고 하겠지만, 그러나 그보다는 더 성숙한 마음이라면, \u0026#34;그럼에도 나는.\u0026#34;이라고, 그런 것들에 휘둘리지 않고 스스로의 주인으로서 말할거 같다.\n짝사랑, 혹은 도착증과 그 반대로써인 쩌리의 자존심 난 돈이 많았으면 좋겠고, 사회적으로 성공했으면 좋겠다고 생각한다. 정말로.\n나 홀로 세상에 대해 짝사랑을 하고 있다는 생각이 든다. 세상은 내게 마음을 줄 생각이 별로 없는거 같다.\n종종 그런 슬픈 짝사랑에 빠진 것 이상으로 도착증 수준으로 성공에 대해 집착하는 사람이 많지 않을까 싶다.\n현실은 초라할지도 모르겠다. 아니면 그 초라한 현실을 인정하고 싶지 않아서 이것저것 사고 활동하면서, 그런 껍질이라도 뒤집어 쓰려 노력하는 것일지도 모른다.\n하지만, 내가 비록 세상의 눈부신 성공이나 결과를 이루지는 못했을지라도, 그래도 그런 \u0026#39;쩌리\u0026#39;이지만, 그 나름의 자존심이 있다고 생각하고 그걸 가끔 갖고 있었는지 까먹고는 하기도 하는거 같다. 그리고 종종은 당신도 그럴거라면 그런 쩌리의 자존심을 갖거나 찾아내 들춰 보는 것은 어떨지 권하고 싶기도 할 때가 있다.\n신화적인 닌텐도와 그 빠 요즘엔 예전보다 더 닌텐도 게임을 하면서 시간을 보낸다. 그리고 예전의 NES, SFC, GameBoy 시대의 슈퍼마리오, 별의 커비, 젤다 등을 하면서 시간을 보낸다.\n내가 가장 놀라는 점은, 게임 타이틀에 표시되는 연도와 그 게임의 정교함, 섬세함의 강렬한 대비.\n대부분은 80년대 말, 90년대 중후반에 발매된 게임들을 플레이하고는 하는데, 그때 당시에 저런 정도의 용량으로 이렇게 섬세하게 플레이 가능하고, 이런저런 게임내 세계에 저런 장치를 구현했다는 점에서 아직도 종종 놀란다.\n누군가는 당연하게 받아 들일 수도 있겠지만, 그냥 조금이나마 프로그래밍에 대해 이해하고 있는 나 스스로는 어떻게 했을지 상상과 추측을 해본다. 그리고 거의 대부분 도달하는 결론은, 이걸 만든 사람들이 얼마나 자기 자신의 일을 즐겁게 여겼을지 느껴진다. 그들에 대한 다큐멘터리나 서적도 많이 있겠지만 그걸 찾아보지 않아도, 단지 그들이 내놓은 결과물과 함께 시간을 보내는 것만으로도 그걸 느끼게 된다. 그리고 스스로 엄청나게 부끄러워지고는 한다.\n그때와 비교하면, 엄청나게 많은 메모리와 컴퓨팅파워가 갖추어진 현재에 내가 저렇게 애착을 갖고 즐겁게 그 세계를 경험할 수 있는 작품을 만들 수 있을까 생각해본다. 그래서 부끄러워진다. 그때에는 프로그래밍을 위한 지식을 접할 채널도 지금과는 비교도 할 수 없이 제한적이었을텐데 말이다. 4\n…그리고 글쎄다, 단순하게 돈을 벌기만을 위해서였다고, 그래서 싸구려 저질의 제품을 만들고 그걸 적당히 팔아서 이익을 내는데에만 치중했다면, 오히려 저렇게 닌텐도가 성공하고 오래토록 그 성공을 영위하고 있을지 잘 모르겠다.\n다른 말로 한다면, 흔히 말해지는, 그 어른의 사정에 따라서, 적당히 해서, 회사는 이윤추구가 목적이므로, 그렇게 한다고 실제로는 아무도 즐길 수 없고, 아무도 사용할 수 없을 제품이나 서비스를 허울만 만들어서 해나갔다면, 닌텐도는 닌텐도가 되지 못했을 것 같다.\n닌텐도는 어쩌면 그런 어른이랍시고 빠져야만 할 것 같은 진지함, 그래서 너무나도 진지해서 단기수익이니 수익위주경영이니 같은 \u0026#39;글자만 어른\u0026#39;이 되려는 놀이는 포기했기 때문에, 그리고 아마도 그러면서도 자존심을 버리지 않았기 때문에, 오히려 진짜 어른이 되었을지도 모른다.\n그 \u0026#39;진짜 어른\u0026#39;은 그걸 갖고 논 사용자들의 동심을 실망시키거나 아프게 하지 않았을테고, 또 어른으로서 당당하게 이익을 추구하는 회사가 되었을거다. 너무나 아이러니하게도 \u0026#39;글자만 어른\u0026#39;이라고 어른놀이를 하는 이들과는 달랐기 때문에 진짜로 어른이었던거겠지 싶다. 5\n\u0026#34;괜찮아\u0026#34; 글쎄다. 당장에 현실이라고 말하면서 실은 합리화나 자기입지, 주도권만을 위한 도구로써 갖다 붙이면서 어른놀이를 하면서, 실제로는 어른스럽지 못한 것보다는, 그런 놀이는 내려놓고, 스스로 어른이랍시고 하는 이들의 손가락질을 그렇게 신경쓰지도 않으면서 정말 어른이 되는 편이 더 낫겠구나 싶다.\n아마 이렇게 신화나 환상적인 이야기이나 하니까, 나는 이렇게 쩌리이겠지만. ㅎㅎ\nFootnotes 1 나무위키 \u0026#39;어른의 사정\u0026#39; 에서: \u0026#34;사회생활을 어느 정도 하다 보면 알게 되는 사회의 더러운 면이나 치사하지만 어쩔 수 없는, 어린이와 청소년들에게 말하기 힘든 사정을 의미한다.\u0026#34;\n2 실은 아담스미스를 오해했거나 곡해한 것이리라 생각한다. 저 단편만을 가져다가 인용하며, 스스로가 얼마나 냉철하고 지적으로 느끼고 싶은 기분도 충족시키고, 하지만 확실하게는 문제가 있는 생각들을 합리화해내고 싶은 사람이라면 그럴거 같다. 동아비즈니스리뷰: 애덤 스미스의 \u0026#39;도덕감정론\u0026#39;\n3 대부분의 \u0026#39;테크기업\u0026#39;들이 왜 매 계절마다, \u0026#39;트렌디\u0026#39;하다는 테크스텍으로, 실은 별로 이득도 없거나, 생산성도, 유지보수성도 나쁠 일을 할까 싶을 때가 많다. 물론 경영진이 테크리터러시가 낮아서 그런 일이 벌어지는게 대부분이겠지만, 투자자나 고객을 위한 전시용이기도 할거 같고, 또 스스로의 \u0026#39;개발커리어\u0026#39;를 위해서 그런 테크스텍을 쓰고 싶어하는 개발자들을 위해서일지도 모르겠다. …하지만 그런 테크스텍이 커리어에 유의미할지는 잘 모르겠다.\n4 물론, 그들 스스로가 하드웨어부터 만들었고, 또 오히려 지금처럼 distraction이 많지 않았을테니 더 생산적이었을지도 모르겠다. 하지만 그래도 그 결과물이 시대를 뛰어 넘는다는 점과 그걸 만든 이들의 깊은 애정이 느껴지는 것은 여전하다.\n5 난 별로 진짜 어른도 못되고, 글자만 어른이었던거 같아서 후회를 종종한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb07--01-ping/","title": "🧑‍🍼 Ping 07/02/2023 .01 : C++, D, Zig의 이름에 대한 추측",
     
     "tags": ["ping", "c++", "zig", "d-lang", "c-lang", "naming", "roman", "numeral", "german"],
     
 "description": "",
 "contents": " 문득 떠오른 생각이라서, 그냥 추측.\nC : 로마숫자(roman numeral) 으로 100.\n처음부터 의도한 숫자가 100이 아니었을거란건 나도 알거 같아. BCPL이나 그런 역사에 대해 나도 조금은 아니까. 그런데 그 이후에 따르는 언어들이 그런 패턴을 만든거 같아서 재미로 쓰는 글. C++ : 위의 로마숫자이란 생각과 C언어의 x++ 연산 으로 생각해보면,\n즉시 평가할 때에는 C == 100, 그냥 C와 같아 보임. 그런데 저장된 값은 +1, == 101. …어쨌든 그냥 볼 때엔, 씨언어와 거의 같아 보이지만, 그래도 좀 더 성장했다고. 그리고 겸손하게 오직 +1. (그냥 겸손하다고 될 문제인가 싶다… C++ 좋아하지만 ㅎㅎ) D : C에서 다음 단계으로 발전했으니, 이번엔 다섯배, 역시 로마숫자, 500.\n음, 막 가비지컬렉터 붙어 있고, 처음 나올 당시 (내 기억엔 2002년 전후?) 기준으로나 지금이나 정말 많은 기능을 지원했으니까. 요즘에도 Go, Rust 등과 비교되기도 하는 언어이긴 하니까. Zig : 갑자기 분위기 German\n(붙여서 쓰면) \u0026#34;x10\u0026#34; 의 의미/. (Zig은) C언어나 C++와 얼마든지 혼용해서 사용하는걸 고려해서 만들었으니까, 1,000 이거나 1,010. (각각 C언어, C++일 때) 아님, 혼자서 쓰면, (아마도) 20+ 이상의 큰 수, 그것도 아니면 정말 정말 많은 큰 수. 거기에, 지금까진 로마숫자였는데, 게르만족의 침략처럼… 갑자기 독일어… 침략하듯이 C/C++언어 생태계에 뛰어든거 같… 그냥 재미로 추측해봄.\n실제로 Zig은 그 자체가 C/C++ 컴파일러이면서, opt-in 방식으로 조금씩 부분부분씩 Zig언어으로 변경해 나가면서 프로젝트에 적용도 할 수 있고, 아예 새로운 애플리케이션이나 라이브러리를 만들면서 기존 C/C++ 코드/라이브러리와 문제 없이 연동되기 정말 좋게 고려되어 있어서.\n그리고 그러면서 표현력의 density이 엄청나게 좋도록 설계된 언어와 라이브러리임에도, 그렇게 설계할 경우에 코드의 명확함이 많이 떨어지고 복잡해지는걸 방지하려고 엄청나게 명확하게 만들려고 노력한 좋은 언어.\n…뭐 그냥 그렇다고, 끝으로:\n이건 March…\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb04--01-ping/","title": "🔋 Ping 04/02/2023 .01: 씨언어의 장자 zig, rust, golang, c++ ???",
     
     "tags": ["ping", "cpp", "cee", "zig", "comptime", "rustlang", "golang", "typescript", "commonlisp", "cppfront"],
     
 "description": "",
 "contents": " 최근에 재미로 zig 을 정말 재밌게 \u0026#39;읽었다\u0026#39;. 공부해보고 실제로 뭔가 코딩을 많이 해보거나 한 것은 아니고, 대체 어떻게 동작하는 프로그램을 이걸로 만들라고 하는건지 이해하고 싶었기 때문에 해봤다.\nzig으로 프로그램을 짜는게 궁금하던 부분은 haskell의 monad을 이용한 방식, 혹은 apl이나 prolog으로 실제프로그램을 어떻게 만들 수 있을지 패러다임부터 다른 언어를 공부하고 생각해보는 것과는 조금 다를수도 있겠다. 어쨌든 그냥 imperative언어이니까.\n오히려, zig을 어떻게 써먹어야 할지 궁금하던 지점은, c++의 스마트포인터와 move semantics등을 이해하는 것이나, rust의 borrowing checker, rc/arc등을 이해하는 것과 마찬가지인 것 같다. 둘 다 이해하고 익숙해지면 그렇게 부담스럽지 않을거 같긴 하다.\nzig의 경우에는, rust의 빌림체킹 모델을 이해하고 익숙해지는 것과 유사한 종류의 궁금증이었지만, 정반대로 하는, unlearning의 경험이었던거 같다.\n원한다면, 얼마든지 그런 comptime 라이브러리를 만들어서 shared_ptr, rc / arc 같은것들을 만들어 쓸수도 있을거 같다. 1\n하지만, zig community에서는 이런 메모리관리 방식이 별로 그렇게 열심히들 사용하는것도, 정말 없으면 안된다고 중요하게 생각하는 것도 아닌거 같아서 놀랐다. c++/rust 커뮤니티와는 정말 다른 분위기, 후자는 정말 병적으로 느껴질 정도로 컴파일시간에, 컴파일러가 체크할 수 있어야 하고, 뭐든 안전하게 만들어야만 한다는 강박이 느껴진다. c++은 메모리관리 중요하고 안전하게 해야 하지만, 뭐 안그러고 적당히 잘 굴러가게 문제 없이 할 수 있다면 그거야 뭐 작성한 사람의 책임이지, 자유롭게 내버려두지, 약간 이런 분위기인거 같고. (물론 중요하다고는 말하지만)\n오히려 그런 \u0026#34;smart pointer\u0026#34;보다는, 차라리 상황에 알맞게 더 적절한 allocator을 사용하는 것에 더 관심을 두는 것 같다는 인상을 받았다.\n그리고 요즘의 유행하던 대다수의 언어들, Java, TypeScript, 같은 Generics의 지원이 흥미로웠다.\ncomptime 을 이용해서, 실제로는 c++ template이 특정한 타입의 코드를 컴파일 시점에 생성해내는 방식을 직접 활용할 수 있도록 한 것이 재밌었다.\n그러면서도, c++ template보다는 더 단순해 보이고 해서 마음에 들기도 했다.\n최근에는 golang에도 generics이 추가 되어서 반가웠다. go을 사용할 때엔, for-loop으로 타입마다 매번 뭔가 알고리즘을 복붙하듯이 짜거나, go generate 에 의존해야 하는 것이 귀찮았었기 때문에.\n그리고 comptime이 흥미로웠던 이유는, common-lisp의 타입시스템과 유사한 방식이기도 해서였다. 커먼리습은 실행시간과 컴파일시간, 파싱시간을 분리해놓았는데, 그 시점들을 모두 내가 작성한 코드을 통해 제어가 가능한데, satisfies 등을 보면, 타입시스템 자체는 제네릭에 대한 고려가 별로 없지만, 그렇게 동작하도록 얼마든지 지정이 가능하게 되어 있기 때문이다. 그러면서도 딱히 그렇게 엄청나게 복잡하거나 hacky하게 해야만 하는 것도 아니어서 만족스러운 접근.\njava이나 typescript등의 제네릭은, 그리고 아마도 golang도, 모든 것을 컴파일러가 딱 정해진 범위의 타입시스템에 따라서만 동작하는데, 그걸 계속해서 더 편리해지도록 지원을 추가해 나가는 느낌이다.\n아마 java은 더 확장하지 않을 것 같고 (적어도 제네릭에 대해서는), golang도 그럴거 같지만, typescript은 확실히 매 버젼이 나올 때마다, 더 간략하게 타입시그니쳐를 명확하게 표기하거나 하는 지원을 추가해 나가는 것 같다.\nzig와 유사하게, lua의 문법인데, static type system을 붙이고, AOT compile방식으로 동작하는 nelua을 보면, 이런 컴파일시점을 이용하여 타입시스템을 확장할 수 있도록 해놓았다.\nnelua의 매크로는 노골적으로 Lisp/Scheme의 매크로시스템을 연상시키는 방식이다. (리습 매크로의 gensym 이나 AST을 조작도 아예 가능하게 해놓았다)\nnelua의 매크로와 비교하면, zig의 comptime은 오히려 ocaml의 functors와 유사한 방식으로 사용하게 될거 같다.\nzig의 comptime, 커먼리습의 타입시스템과 satisfies, nelua의 macro등은 모두 조금씩은 다르지만, 자바나 타입스크립트의 generics을 넘어서는 응용도 가능할거 같다: 예를 들면, https://en.wikipedia.org/wiki/Dependent_type 이런 타입시스템을 추가적으로 지원하도록 확장도 손 쉬울거 같다. 2\nmalloc/free 와 유사한 방식의 allocators 방식이거나, 한것도 그렇고 어떻게 생각하면 zig은 괜찮은 방식의 comptime을 지원하는 씨언어처럼 느껴지기도 한다.\n하지만, 가장 불만족스러웠던 부분은 컴파일속도인거 같다.\n어차피 rust처럼 복잡하게 컴파일시점 체크가 많거나, 최적화도 열심히 해주듯이, comptime 때문인지 llvm백엔드를 이용하기 때문인지, 그냥 씨언어만큼 가볍게 컴파일되는 느낌은 아니었어서.\n컴파일시간이 쾌적한건, 사실 그냥 씨언어나 golang까지만인거 같아. 그리고 두 언어의 killer-feature에 간과하기 쉬운 점이지만, 빠르고 상대적으로 쾌적한 컴파일속도를 꼽아야 한다고 나는 생각해서.\n단순하게만 생각하면 c++이 씨언어의 장자인 것 같지만, 실제로 컴파일속도, abi호환 등을 생각해보면 사실 완전히 다른 언어에 가까운거 같다. (물론 그럼에도 다른 어떤 언어들보다 씨언어와 통합해 쓰기 가장 편리하고 오버헤드도 없지만)\n개인적으로는 rust보다는 cppfront이 오히려 더 기대되기도 한다. 그냥 c++처럼 적당히 동작하길 바라고, 적당히 borrowing-checker이 붙거나 하는 자유도 기대할 수 있을거 같아서. (물론 현실은 rustlang을 무시할 수 있게 될거 같진 않다. 이미 가속과 질량이 엄청 붙어버렸으니까.)\nzig은 그 자체가 씨언어 컴파일러이기도 하지만, 컴파일속도면에선 쾌적하지 못한거 같아서 내겐 애매했다.\ngolang은 뜬금 없이, 가비지컬렉터도 붙어 있고, 생성된 바이너리가 씨언어와 호환도 없을거고, 심지어 씨언어 바이너리를 abi으로 호출할 때에 오버헤드까지 있다고 하는거 같아. …그런데 오히려 내게는 씨언어의 정신적인 장자가 맞지 않을까 싶다. 컴파일속도에 대한 고려와 언어의 단순함 등등을 제한한 점 등일거 같아. (..물론 씨언어가 그런 면들을 처음부터 추구했다고 할수는 없을거 같지만)\n딱히 결론을 낼 생각은 없지만, 어중간한 느낌이 드는건 어쩔 수 없는거 같다.\nFootnotes 1 실제로 comptime으로 https://github.com/yrashk/zig-rcsp 에서, c++의 std::shared_ptr 같은 reference-counted shared pointer을 구현.\n2 이미 커먼리습의 타입시스템은 얼마든지 어떤 값에 따라 타입이 결정되도록 하는 것이 기본이니까.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb03--01-ping/","title": "🈵 Ping 03/02/2023 .01: 블로그 디자인 수정",
     
     "tags": ["ping", "hugo", "css", "blog", "webdev"],
     
 "description": "",
 "contents": "블로그를 내려놓았다가, 다시 글을 쓰고 생각들을 어느 정도는 공개를 하고 지내고 싶어져서 다시 열었다.\n사용하던 테마를 수정해서 쓰기로 하고, CSS을 여기저기서 복붙해서 적용해보고, 갈무리 웹폰트도 적용해서, 오히려 원본 테마보다 더 가볍게 적당히 만들어봤다.\n색상도, 외양과 기능 디자인 모두 어느 정도 내 취향에 맞게 꾸며 봤다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2023-02feb/2023-02feb02--01-ping/","title": "🖖 Ping 02/02/2023 .01: xemacs, gemini, gemtext",
     
     "tags": ["ping", "gemini", "gemtext", "xemacs", "retro", "emacs"],
     
 "description": "",
 "contents": " 추억이 그리워지는 시대여서 그런거 같기도 하다. 그럼에도 어차피 그렇게 다시 사용하기엔 끔찍할텐데.\n1. \u0026ldquo;제미니 계획\u0026rdquo; gemini protocol 을 기반으로 뭔가 새로운 것을 상상하면 즐겁지만,\n정말 제한적이어서, 내 마음대로의 확장을 떠올리게 된다.\n실은, gemtext와 gemini protocol은 마음에 드는 부분이 바로 그런점이지만: 오히려 제한적이고, 그냥 무시해도 되는 것들을 굳이 지원해줘야 할 것 같은 기분에 져서 우겨넣으면서 complexity만 무한대으로 보낼바엔, 이렇게 무시할 것은 잘 무시하는게 더 좋은거 같아.\ngemtext은 아예 어떤 마크업에 대한 고려도 실은 없고, inline links 같은 것도 지원하지 않는다.\n그런데, 그런 점들이 오히려 HTML보다 더 나을수도 있겠다 생각했다. 당장 모든 장치마다 폭/폰트 등등 다 다른걸 제대로 렌더링 되도록 하겠다고 얼마나 많은 수고를 하면서도, 제대로 된 웹접근성/가독성은 떨어지는지 싶어서.\n그리고 언제까지나 우리가 스크린만으로 글을 읽게 될지도 불확실하다고 생각해서. 금새 음성을 통한 접근이 더 보편화될 가능성이 높을지도 모르지.1 \u0026hellip;그렇다고 한다면, 오히려 화면에 글자를 예쁘게, 잘 보이도록 하던 일들은 오히려 무의미하거나, 심지어 과거에 IE/ActiveX 환경이 그랬듯이, 무언가를 더 좋게 한다고 시도를 했지만, 오히려 HTML5/웹표준 환경으로 전환하기 위해 모두 버리고 더 가볍게 다시 만들어야 했었듯이, 거추장스러워서 버리게 될 가능성도 높은거 같아.\n한마디로, 지금 시점에서는 엄청나게 중요한거 같아도, 그보다 더 큰흐름에서 큰 변화가 생긴다면, 아무 생각도 할 필요 없이 내다버려야할 쓰레기일뿐일지도 모르지.\n그리고 제미니 클라이언트를 설치하고 여기저기 뒤젂거리고 다녀도, 딱히 재밌는 글타래도 보이지 않고, \u0026hellip;오히려 여긴 누가 와서 같이 글을 쓰고 글을 읽기 보다는, 아직은 그냥 다른 아무도 없는 곳이 필요해서 대피해온 곳이란 느낌의 공간이었다.\n2. just like the good ol\u0026rsquo; days 전기세도 걱정되고 하는 시대이고, 조용히 글을 두드리고 싶을 때, 조용하게 팬소음도 없이 (아예 팬이 달려 있지 않아도 굴러는가니까) raspberry pi 3b+ 정도만 켜고 emacs을 켜고 툭툭 두들기기도 하면서 지낸다.\n하지만, rpi3이 그렇게 사양이 좋은것도 아니고, 내 공통 emacs config이 그렇게 가벼운 편도 아니고, mini emacs config 만들어 놓은 것도 갱신하기 귀찮았다.\n실은 단지 emacs-mini-config 설정만 고쳐서 실행하면 만족스러울 일인데, \u0026hellip;그냥 설치하고 예전 감성을 느끼고 싶어서 xemacs 패키지를 설치해서 다시 실행해봤다.\ndebian stable (bullseye)에 신기하게도 xemacs 21 버젼이 패키지으로 당당히 살아있어서, 그냥 설치.\n뭐 이것저것 내가 글쓰는 루틴과 방식에 맞추느라 결국 설정을 조금은 했다: https://github.com/ageldama/configs/blob/master/emacs/xemacs-init.el\n\u0026hellip;그리고 xfonts 패키지를 더 설치해서 예전 비트맵폰트(bdf/pcf)를 더해서 폰트 설정까지 해주고 마무리.\n이렇게까지 조금 세팅을 하고 나니, 뭔가 느낌적으로 글을 쓰는데 더 집중이 되기는 되는 느낌이 들었다. 그리고 심지어 더 빠르게 화면이 움직이는 느낌\u0026hellip; 트루타입이 아니라 비트맵방식 폰트이니까 그럴꺼라는 혼자 생각도 하면서.\n심지어, org-read-date 같은게 필요해서, calendar을 해킹해서 가능하게 만들고 나서 엄청나게 뿌듯했다.2\n확실히 편안하기는 하다. org-mode이니 다 필요 없이, fundamental-mode에서 글을 쓰고 있는 일도 즐거웠다. 예전에 리눅스를 사용할 때에 (1997년대~2004년 정도?)에는, 실은 나는 xemacs을 종종 썼던거 같다. 화면구성과 기본색상이 gnu emacs은 흰색바탕이 기본이었었는데, 그보다 xemacs의 회색을 더 선호했었고, 오랬만에 그 색상을 보니 편안했다.3\n\u0026hellip;그런데, 종종 요즘에 다른 gnu emacs환경에서 작성한 UTF-8 텍스트를 종종 xemacs에서 깨먹는걸 보면서, \u0026hellip;접었다: https://www.emacswiki.org/emacs/MuleUCS \u0026hellip;이유는 이런거 같다.\n추억여행은 이만 접고, 그냥 원래의 gnu emacs을 열었다. 그냥 적당히 로딩이 느렸지만, 글을 쓰기에는 크게 무겁지 않았다. 그냥 xemacs이 가볍다는 것은 그냥 기분탓이었던거 같아. ..물론 실제로 가벼울 수 밖엔, 내가 gnu/emacs에 설치해놓고 사용하는 수 많은 확장들을 하나도 로딩하지 않고 그대로 사용하는거니까. 그리고 그렇다면, 그냥 \u0026ldquo;mini emacs config\u0026quot;을 갱신하면 어차피 처음부터 가벼운 환경을 그대로 쓸 수 있었을텐데 괜히 추억여행만 잘 다녀온 것.\n어쨌든, 복잡해지고 엄청나게 무거워졌지만, 그래도 내게 필요한 방향으로 유익해져 오기는 했구나 당연한걸 생각.4\nxemacs은 원래 시작부터 상용 C++ IDE을 만들려는 시도였었고, maintainer도 없고, Elisp도 너무나 달라지도록 발전해서, 앞으로 아무도 쓸일이 없을거 같기는 하다. 과거에 작성해놓은 Elisp코드 때문에 써야 하는 경우와 편안함을 느껴서 그런 경우가 아니라면.\n차라리 돈을 내고 글을 읽겠다\u0026hellip;만 공짜라고 딱히 좋은 컨텐츠인지는 잘 모르겠다. 광고이거나 선동(..그리고 선동으로 유인/조종해서 돈벌이를 위한거겠지만 결국)이거나, 그것도 아니면 방문자수 카운트 등으로 데이터장사나 DAU/MAU장사를 하려는게 의도일뿐이니까.\n착각할 필요가 없는게, 인터넷/모바일 서비스나 기업들이 어차피 하려는건 그중에 하나이지, 말하는 프로파간다 같은 \u0026ldquo;더 좋은 세상\u0026ldquo;을 만들거나, \u0026ldquo;당신을 위해\u0026rdquo; 무언가 더 좋은걸 주려는건 절대 아니지.. 혹여 그렇게 말한다고 하더라도, ㅎㅎ그건 어차피 그런 기분을 줘서 결국 누가 이익을 보고 싶어서 그 활동을 하는건지 착각해서는 안된다.\n그리고 그런 서비스나 기업을 하려고 착안을 하기 시작하면 결국 할 수 있겠다 싶은 내용은, 어떻게 해야 되겠다는 경로도 결국 사용자를 위해서라기 보다는, 그런 데이터생성기, 광고대상으로 보이게 될 뿐인거 같다. 더군다나 투자를 처음/더 받고 싶거나, (화난) 투자자를 안심시키거나, (매혹된) 투자자를 더 들뜨게 만들고 싶다면 더욱 그럴거 같다.\n공짜로 뭔가 얻으려고 해서 얻는 정보들은\u0026hellip; 글쎄, 결국 광고이거나 데이터생성의 역할을 해주도록 날 유도하는데 더 열을 올리려는게 당연할거 같아.\n구독방식으로 돈을 내고 접근하는 컨텐츠들이 차라리 더 나을지도 모르겠다, 당연히. 그런데, 그것도 또 딱히 안심이 되지 않는것은, 그 컨텐츠가 열려 있지 않으니, 그게 사실인지, 가치가 있는지는 확신이 서지 않는다는 점.\n내가 뭘 알겠냐만, 차라리 돈을 내고 뭔가를 사서 읽으면 더 나을까 싶기도 하다. 그렇게까지 해서 읽게 되는 것도 또한 광고와 충실한 정보가 의심스러운 정보라면, 이걸 정말 내가 내돈 내고 읽어야 맞는걸까 싶다면, 정말 그러면 어째야 할까 싶다.\n또는, 어떤 인터넷뉴스라고 하는 것들은, 읽어 보면, 통념적인 기분에 맞춰주기 적절할 뿐인 (실상은)헛소리인데, 그걸 지식이나 정보꺼리로 게재하는거 같기도.\n여튼, 뭘 딱히 열심히 읽지도 않는 주제에 투덜거리기만 해봤다.\n\u0026hellip;웹에 대해서만 생각해봐도, 불과 2010년 언저리만 해도, 대한민국의 인터넷환경은 너무나 특별해서, 영원히 Internet Explorer 환경에서 한국은 벗어나지 못할거 같았었지 않나. 그러다가 금새 스마트폰 환경이 PC접근보다 수월하니 HTML5전환이 많이 일어났었고. \u0026hellip;지금에는 (여전히 남아는 있지만) 정말 리거시를 제외하고는 많이 ActiveX등이 많이 사라진거 같다. 마찬가지로 웹브라우져이나 스마트폰 터치스크린을 이용하는 방식이 모든 사람에게 편리한 것도 아니고, GUI 메타포어를 모든 세대가 편안하게 여기는 것도 아니니까, 오히려 자연언어를 통해 접근하는 방식, 적당히 대화가 가능한 방식은 이미 일상에 어느 정도 구현되어 있고, 아주 짧은 기간내에 그 인식정확도와 편의성이 폭발적으로 증대될거 같아. 심지어 우리가 말소리를 아주 크게 내지 않더라도, 그걸 인식할 방법은 많을테니까. 대중교통에서 입을 다물고 무선이어폰을 꽂고 스마트폰에 시선을 고정한 것이 아니라, 그냥 시선은 자유롭게 하고 손으로 조작할 필요도 없이, 무선이어폰만을 꽂은채 아무 소리도 내지 않는거처럼 웅얼거리면서 스마트폰을 조작하는게 더 보편화되지 않을까. 기술적으로 구현도 이제 더 수월해질테고, 그게 손과 시선을 고정할 필요도 없어서 더 편리할테니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ncalendar elisp function이 있기는 있는데, 그걸로 날짜를 선택한 값을 기본적으로는 얻어낼 수 없어서\u0026hellip; calendar-mode-map이란 keymap에 enter키를 바인딩하고 \u0026ndash;\u0026gt; 그 선택결과를 다른 숨긴 이맥스버퍼에 복사하거나, 콜백lambda함수를 호출하거나 하도록 하는 방식으로, 원래는 의도하지 못한 방식으로 xemacs의 calendar함수를 원본 코드는 그대로 두고 그 주변에 추가만 하는 방식으로 재밌게 확장했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n리눅스를 예전 slackware a.out/coff일 때부터 사용해왔었다, 그때에 이맥스를 선호했던 이유는 Mule을 지원해서 한국어 입출력이 가장 편안했던 환경이어서 그랬었다. \u0026hellip;솔직히 지금도 내겐 이맥스가 가장 한국어 작성하기에 편안하다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n지금 글을 쓰는 이맥스의 system-configuration-features값은 \u0026quot;ACL CAIRO DBUS FREETYPE GIF GLIB GMP GNUTLS GSETTINGS HARFBUZZ JPEG JSON LCMS2 LIBOTF LIBSELINUX LIBSYSTEMD LIBXML2 M17N_FLT MODULES NATIVE_COMP NOTIFY INOTIFY PDUMPER PNG RSVG SECCOMP SOUND THREADS TIFF TOOLKIT_SCROLL_BARS X11 XDBE XIM XPM XWIDGETS GTK3 ZLIB\u0026quot; \u0026hellip;elisp에 이미지포맷, TLS, gsettings/dbus연동 같은것은 물론 멀티스레딩도 가능하고, 심지어 NATIVE_COMP으로 JIT컴파일까지 해주도록 발전해왔구나 싶었다. OpenSUSE Tumbleweed에서 이맥스 사용하니 기본패키지가 그렇게 빌드되어 있더라.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-11nov/2022-11nov13--01-ping/","title": "🏰 Ping 13/11/2022 .01",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "비가 많이 내렸다. 일년간 어떻게든 자라던 잎들이 낙엽이 되어 떨어졌다.\n그런데 딱히 걱정스러울게 없었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-07jul/2022-07jul07--01-ping/","title": "💶 Ping 07/07/2022 .01",
     
     "tags": ["ping", "swengr", "zk", "lurk", "rust", "bun", "zig", "swc", "typescript", "programming", "nodejs", "js", "luajit", "lua"],
     
 "description": "zk/lurk, bun, zig, swc, rust, 그리고 luajit",
 "contents": "벌써 7월. 2022년이 정말 빠르게 흘러간거 같기도 하고. 힘든 일들이 내게는 안팎으로 많은 해이기도 하다.\n몇년전부터 누군가 ㅇㅇㅇ을 dd야 하냐 말아야 하냐라는 질문에, 그저 뜬금 없는 이야기를 해줬었다. 이해를 했었는지, 아니면 그 나중에라도 그것들이 현실에 영향을 미치기 시작하면서 의미를 파악했었을런지는 잘 모르겠다. 어쩌면 아마 그런 이야기를 해줬던것도 잘 기억하지 못할것 같긴하다.\n\u0026hellip;그리고 그런 모든 생각들이, 당시에는 너무 현실과 동떨어진 이야기로만 들릴 생각들이 하나씩 너무 당장의 일들이 되어 버렸는데, \u0026hellip;내 생각이 맞아 떨어졌다는 기쁜 마음도 들지만, 한편으로는 너무 불안한 oo이기도 하다.\n소프트웨어 엔지니어링에 대한 생각들 zk, lurk, 그리고 모르겠다능 bun, zig, swc, rustlang 소프트웨어 엔지니어링에 대한 생각들 \u0026lsquo;16 Bell-Curve Opinions on Engineering\u0026rsquo;\n\u0026lsquo;Why DRY is the most over-rated programming principle\u0026rsquo;\n널리 퍼져 있는 빤한 생각들보다는 훨씬 재밌고 맞는 mantra이란 생각. 그리고 실은 나도 빠져 있던 함정들도 있었어서 그랬구나 생각도 들고.\n언제나 그렇지만, 당장의 한번 나아보일지 모르고, 또 뭐가 다른지 잘 이해가 어려울지 몰라도, 시간이 흐르고 반복, 사이클을 거치게 되는 일이란 것을 천천히 생각해보면 차이를 알수있다. 1\nzk, lurk, 그리고 모르겠다능 https://github.com/lurk-lang/lurk\nhttps://github.com/lurk-lang/lurk-lib/tree/059599c37ba140383e0e9b370ba4b17d3c7724f2/example\n1 2 3 4 5 6 7 8 9 10 ;; (FIB TARGET) computes the element of the Fibonacci sequence at TARGET (zero-indexed). (letrec ((next (lambda (a b n target) (if (eq n target) a (next b (+ a b) (+ 1 n) target)))) (fib (next 0 1 0))) (current-env)) bun, zig, swc, rustlang https://bun.sh/\nhttps://github.com/swc-project/swc\n\u0026hellip;점점 더 재밌어 지는거 같아.\n그리고 그럼에도 이런 애잔한 향수가 있기는 해:\nhttps://en.wikipedia.org/wiki/LuaJIT \u0026hellip;엄청난 한 사람의 작업과 그 이후에 그걸 누가 대체할 것인가에 대한 고민들도 생기고.2\n뭐 그래도 모르겠다면\u0026hellip; 그건 니가 뭔가 잘\u0026hellip; 쿨럭쿨럭\u0026hellip;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n물론 여전히 작업이 올라오기는 하지만.. 그리고 더 재밌는건 그럼에도 여전히 어이 없게도 shootout하면 최상위권 찍는 괴물.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun29--02-ping/","title": "☕ react.js, next.js, ssr, progressive hydration, 그리고 &#34;Islands Architecture&#34;와 fresh/deno",
     
     "tags": ["ping", "html", "hotwired", "web", "js", "javascript", "deno", "fresh", "ssr", "nextjs", "reactjs", "programming"],
     
 "description": "",
 "contents": "https://jasonformat.com/islands-architecture/\n\u0026hellip;이전에 몇번 언급한 hotwired 처럼. ㅎㅎ\n지금의 reactjs, vuejs등은 다음과 같은 방식이 기본:\nserver: rest/gql등으로 요청을 받아서, json으로 응답. browser(client): 응답으로 받은 json을 받아서, html을 생성하여 렌더링. \u0026hellip;이게 편하다고 생각해서 여기로 온거 같아. 나말고도 대부분의 사람들이 웹화면을 개발하던 시절에는 이렇게 만들고 싶었었던거 같아. 1 2\n그리고 당연히 ui개발이기 때문에 \u0026lsquo;컴포넌트모델\u0026rsquo;이나 값바인딩 같은 것들을 원했었고, 현재의 리액트와 같은 형태에 이르른 것 같아.\n물론, vdom이 복잡도를 많이 낮춰줬지만, 희안하게도 예상하지 못하던 문제를 몇가지 더 만들어낸 것 같아. 그래서 요즘엔 ssr이니 seo을 생각해서 다른 방식의 프레임웍들을 사용하려고 하고 있고, 더 나아가서 progressive hydration 같은 쪽으로 더 세밀해지는 양상 같아.2\n단순하게 생각하면, 그냥 필요에 따라서 그때 그때 필요한만큼만 js을 로딩하겠다는거겠지만, 생각보다 그렇게 쉽게 적용이 되는것은 아닌거 같아: Why Progressive Hydration is Harder than You Think \u0026hellip;발전해 나아가며, 점점 더 세밀하게 필요를 반영하는 것이겠지만, \u0026hellip;그래도 한번 정도는 진지하게 정말로 이게 맞는걸까 생각해보는 것도 중요할 것 같아.\n그리고, 지금의 next.js등을 중심으로 한 ssr쪽도 뭔가 이상한거 같다는 느낌. 굳이 저걸 react.js 컴포넌트으로 만들고, 꼭 그걸 서버측 렌더링을 해야만 했을까 싶기도 하고.\ndeno의 fresh framework 을 살펴봤다. 재밌었다. next.js ssr처럼 [name].tsx 같은 file system routing도 지원하고, preact component을 ssr도 기본적으로 지원. ㅎㅎ\n어차피 deno이 기본적으로 node.js와 달리, typescript기본 지원, npm같은 패키징/실행 등도 모두 지원, eslint/prettier등등도 모두 golang처럼 아예 deno자체에서 지원하려고 하기 때문에 깔끔하고 좋았다.\n하지만, 당분간은 여전히 그냥 다른 언어와 환경을 나는 더 개인적으로 선호할거 같아. deno이 가볍고 빠르고 좋겠지만 더 익숙하고 더 단순하고 더 가벼운 쪽이 나는 더 좋은거 같다.\n그리고 프론트엔드 프레임웍도 마찬가지로 더 가볍고 그냥 잘 동작하는 것들을 선호하려고 한다. 위의 저런 이슈들과 접근법들에 당장 엮이고 싶지는 않고, 그리고 그런 가벼운 접근법들을 선택한다면 오히려 단순하게 풀리는 이슈들 같아서.\n\u0026hellip;돌아보면, 그때 jquery정도만을 갖고 html templating을 만들고, ajax요청으로 서버와 연결하고 하면서 재밌었던거 같아. 그때 당시에도, 스스로 자아에 도취해서 자바로 서버에서만 멋지게 뭔가 대단한걸 아는양 코딩하던 것보다는ㅋㅋ, 그래도 그들이 \u0026lsquo;다이나믹언어\u0026rsquo;라고 낮게 보던 파이썬이든 js으로 재밌게 작업할 때에. \u0026hellip;지금 돌아보면, 이미 그때에 어느 정도 이렇게 js ecosystem이 발전할 가능성과 필요를 느낄 수 있었던거 같아.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n그리고 딱 봐도 뭔가 느낄 수 있지 않은가? JSON으로 서버에서 만들고, 그걸 또 클라이언트에서 또 deserialize해서 클라이언트에서 사용하는 타입으로 매핑하고\u0026hellip; \u0026hellip;그리고 더 나아가서, 대부분의 개발자들은 dynamic mapping으로 이걸 해결하려고 한다. 그게 더 편해 보이니까. \u0026hellip;하지만 현실은, \u0026hellip;거의 대부분의 코드가 무의미하게 이 작업을 하는걸로 보이는 경우도 많다. ㅋㅋㅋ\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun29--01-ping/","title": "🌹 linux/unix 팁 29/06/2022 .01",
     
     "tags": ["ping", "x2x", "conspy", "chdir", "ssh", "linux", "unix", "zoxide", "chdir"],
     
 "description": "",
 "contents": " 리눅스/유닉스/터미널/쉘은 아는만큼 편하게 쓰기 좋은거 같다.\n그리고 어떻게 연결해서 활용해 쓰는가에 따라서, 정말 편리해지기도 해서.\nzoxide 으로 chdir 간단하게 최근/디렉토리 이동한 히스토리에 따라서 (\u0026ldquo;frecent\u0026rdquo;) 이동하기:\nfzf+zsh의 Control-R도 좋고1,\noh-my-zsh 내장인 plugins=(z)도 좋지만2\n\u0026hellip;나는 가능하면 zoxide이 가장 가볍고 좋은거 같다.\n설치하고 나서, eval \u0026quot;$(zoxide init zsh)\u0026quot;\n그리고, z SOME-DIR, zi 같이 으로 사용하면 되고, fzf연동도 잘되고 해서. ㅎㅎ\nssh으로 키보드/마우스 안 붙이고 책상위에 여러대의 컴퓨터를 놓고 사용하는데, 용도에 따라서, 모두 마우스/키보드를 붙여 놓기 싫다. 뭐 kvm switch 같은거 사서 써도 되겠지만, 그보다는 어떤 컴퓨터는 모니터만 붙여 놓고 쓰고 등등 같이 사용해서 그런 방식은 잘 내 책상에서는 잘 맞지 않아서.\nvnc이나 rdp을 통해서 \u0026ldquo;원격데스크톱\u0026quot;으로 사용하는 방식도 아니고 (정말로 물리스크린 여러개를 컴퓨터별로 분리해 쓰는거니까), 그리고 그건 너무 반응성도 느려서 안 좋아함.\n또, 데스크탑의 키보드 마우스를 공유해주는 솔루션들이 있는거 같기는 한데, 다 내 취향은 아니었었음. 그리고, 어차피 x11이 네트웍을 통해서 얼마든지 그런걸 공유할 수 있는데 뭐하러 그런걸 더 깔아서 골치가 아파져야겠나.\nvconsole: conspy 아예, lightdm autlogin 해도 되겠지만, 그마저도 메모리가 아까워서, 그냥 linux vconsole에 연결해서 바로 로그인하고 싶을 때에 사용한다.\nssh으로 접속해서, sudo conspy 1 하면 tty1의 키보드/터미널을 그대로 ssh을 통해서 제어가 가능.\nhttp://conspy.sourceforge.net/\nx11: x2x으로 여러 머신/스크린에 걸쳐서 마우스/키보드 공유 https://github.com/dottedmag/x2x\nssh -CY ageldama@10.0.0.1 x2x -south -to :0 정도로 현재 데탑에서 남쪽에 저 머신의 스크린이 있다고 설정.\n마우스 이동하면, 한 머신인것처럼 포커스가 이동되어서, 조작 가능해짐. ㅎㅎ\nhttps://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/z/z.sh\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun24--01-grug/","title": "👨‍🦯‍➡️ The Grug Brained Developer",
     
     "tags": ["ping", "sw-engineering", "fold", "grug"],
     
 "description": "",
 "contents": "감동적인 글이다ㅋ:\nhttps://grugbrain.dev/\n문법도 완전 grug스럽게 작성해서 반가운 글이었다.\n완전히 모두 내 생각과 같지는 않아도, 이야기하는 \u0026ldquo;FOLD\u0026rdquo; 때문에 일어나는 일들과 조금은 그래도 grug답게 그냥 해내려는 생각들이 유용.\n그치, grug이 공룡과 구분되는 점은 그런거겠지. ㅎㅎ\u0026hellip;\nmsa, reactjs, ejb, osgi. 공감하는 생각들.\n\u0026hellip; black think juice 맛있다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun20--01-ping/","title": "🐚 Ping 20/06/2022 .01",
     
     "tags": ["ping", "life", "netflix", "kino", "movie", "film"],
     
 "description": "초여름 꽃향기를 맡고, 공각기동대를 보다가 생각",
 "contents": "금새 계절이 변해서 또 다른 꽃향기, 밤공기가 좋아.\n넷플릭스 한참을 고르다가 공각기동대 조금 보다가 생각.\n누군가 모르는 이를 새로 만나고 이야기를 하고, 내 소개를 해야 하고, 내 자랑을 해야 하는 상황들.\n정말 나는 잘 살아가고 있는걸까 싶을 때. 해야 하는 일이고, 맞는 일이지만, 문득 문득 내가 내 지적허영1이든, 그게 인정욕구든 한심하지 않은가 기분.\n반대로 물어 보면, 뭐 안 그러고 그런 자리와 시간을 미친놈처럼 자기 소개와 설명을 않을거면 뭐하러 시간낭비를 여러 사람시키는걸건데?\n어려운 일. 정도껏, 중도로 상황에 맞춰서. 남이든 나에게나 어느쪽에도 잡아 먹히지 않고 자유롭기.\n공각기동대나 계속 봐야겠다. 적어도 마지막엔 홀가분해지는 영화이니.\n실은 그렇게 전혀 지적일것도 없다는게 우습다 못해, 홀로 밤에 생각해보면 몸서리쳐지게 내가 싫다는 생각이 들기도 하는. ㅎㅎ\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun19--01-sw-disenchantment/","title": "🎪 &#34;Software disenchantment&#34;",
     
     "tags": ["ping", "sw"],
     
 "description": "",
 "contents": "https://tonsky.me/blog/disenchantment/\n재밌게 읽었다. 계속 생각해오던, 이전 포스팅에서도 이야기한 생각들.\n\u0026ldquo;\u0026hellip;의 진보도 항상 그때그때의 1보만이 진보이며 2보도 3보도 n+1보도 결코\u0026hellip;\u0026rdquo;1\n:winking_face:\n\u0026hellip;그치 ejb/xml을 쓰든, 뭔가 또 새로운 언어나 프레임웍으로 대단한것처럼, 진보한것처럼 쓰려고 해도, 현실적으로는 빌드도 오히려 apache ant 쓸때보다 더 엉망일지도. 성능이든 iteration의 가벼움이든.\n정말 진보는 커녕 오히려 더 ㅎㅎ\u0026hellip; 오히려, apache ant으로라면 명확하게 확실하게 동작하도록 만들기나 잘 하겠지만.\nWalter Benjamin의 \u0026ldquo;Arcades Project\u0026quot;의 인용, \u0026ldquo;매달린 절벽에서 손을 뗄 수 있는가?\u0026rdquo; 강신주 저. \u0026hellip;책에서는 그런 문맥이 아니었었지만, 내 생각엔 이런 문맥에도 맞지 않나 싶어서.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun18--01-ping/","title": "🕚 Ping 18/06/2022 .01",
     
     "tags": ["ping", "kino", "film", "movie", "life", "reincarnation", "family", "friends", "flower"],
     
 "description": "“다시 태어나도 우리”",
 "contents": "\u0026ldquo;다시 태어나도 우리\u0026rdquo; \u0026hellip;참 이상한 것이, 나는 누구의 환생인지도 알지도 못하는 사람들도, 내가 언젠가 훌륭한, 좋은 사람이 되어서 이 세상에 좋은 기여를 하기를 바라며 키워줬다. 다른 사람들도 아마 그럴 것이고, 그게 부모든 스승이든 아주 먼 과거의 누군가인지는 사람마다 다르겠지만.\n\u0026hellip;다들 당신이 린포체이고 위대한 이가 될 것이란 것을 의심한다 해도. 하지만 그딴게 대체 무슨 상관인가.\n그래서 나는 이 영화가 환생이든, 신앙이든, 특별한 그들의 문화든 다 관계가 없는 영화라고 생각한다.\n세상엔 이상한 바보들이 많아서, 굳이 헛소리를 하고 또 그것에 빠져 허우적거리지만 무슨 상관인가. 어차피 꽃은 피었고, 이내 또 질 것이고, 그럼에도 나는 그래도 꽃을 반가워할 것인데.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun17--01-ping/","title": "🔮 Ping 17/06/2022 .01",
     
     "tags": ["ping", "pacman", "archlinux", "linux", "rpi", "raspberrypi", "raspberry-pi", "lxpanel", "lxde", "openbox", "icewm", "tty-clock"],
     
 "description": "",
 "contents": "\u0026ldquo;Code bloat has become astronomical\u0026rdquo; https://www.positech.co.uk/cliffsblog/2022/06/05/code-bloat-has-become-astronomical/\n극공감. 그렇다고 의존성 포함하면 몇 기가나 되는 것들이, 하는 일을 보면 안습. \u0026hellip;그렇다고 그런 방법들만을 고르는 안목이 엄청나게 힙한것도, 스스로에게 이익이 되는것도 아니고.\n데스크탑에 작은 서브모니터 연결해놓은 rpi3b+이 rpi4보다 빠르지는 않을지 몰라도, micro-sd 버벅거림이랑 발열 때문에 버벅거리는건 훨씬 적다.\n\u0026ldquo;rpi4은 빠르니까!\u0026ldquo;이라면서 나름대로 데탑/랩탑에서 쓰는 설정 그대로, openbox+lxpanel 정도 올려서 쓰고 있고, rpi3b+은 icewm 세팅하고 추가로 뭔가를 더 해놓지 않은 탓이 있을까 싶기도 하지만. \u0026hellip;어차피 둘 다 엄청 가벼울거 같은데도.\n그냥 tty-clock, cmus, pamix, vis 정도 띄워놓고, pulseaudio audio server 정도로 사용하고, 주로 tmux, ssh 터미널 정도로 활용하는데도, 종종 버벅거림이 짜증.\n\u0026hellip;가볍고 딱 목적에 맞는 것들을 하는게 더 중요하겠지. \u0026hellip;만 얼마나 상업적인 이유로 kool-aid을 들이켰는가에 따라 결과가 달라지는거 같아.\n그래서인지 https://justine.lol/redbean2/ 이나 https://www2.fossil-scm.org/home/doc/trunk/www/index.wiki 같은 프로젝트들 보면 뭔가 반갑기도 하고.\n메인데탑 pacman -Syu 시도 (모든 archlinux 사용자들처럼, \u0026ldquo;i use archlinux, btw\u0026rdquo;)\n\u0026hellip;설치해놓고, 몇 년째 그대로 사용했었는데, 오랬만에 업데이트 ㄱㄱ. \u0026hellip;아마 무선랜 드라이버나 그런거 깨질거 같은데 ㅎㅎㅎ\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun15--01-ping/","title": "🔮 Ping 15/06/2022 .01",
     
     "tags": ["ping", "cache", "jinja2", "gulp", "api", "postgresql", "gql", "webpack", "template", "templating", "jinja", "webdev", "rest"],
     
 "description": "",
 "contents": "비 내리는 화요일. \u0026#x2614;\njinja2 template include + cache? + file-time 재밌는걸 찾았다.\njinja2을 사용하면서, 하위 include으로 내려갈수록, file을 생성해줘도, 그냥 touch을 해줘서 파일시간을 갱신해줘야 template cache을 무시하는거 같아.\n그래서,\n1 2 3 4 5 6 7 8 9 10 11 // gulpfile.js: const buildTask = series(cleanTask, esbuildTask, injectTask, touchInjectedTask); function watchTask() { watch(\u0026#34;./js/**/*.js\u0026#34;, buildTask); } exports.watch = watchTask; exports.build = buildTask; exports.clean = cleanTask; \u0026hellip;대략 잘 동작하고, webpack보다 엄청나게 빠르다 ㅎㅎ.\npostgresql, as an api server? 요런것들 올라오는거 보는 재미:\nhttps://github.com/graphile/postgraphile\nhttps://github.com/supabase/pg_graphql\nhttps://postgrest.org/en/stable/\nhttps://github.com/prest/prest\n검증/형상관리만 잘 한다면, 실은 가장 중심을 잘 잡은 구조일지도. ㅎㅎㅎ\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/algebraic-effects-for-everyone/","title": "🥯 &#34;모두를 위한 algebraic effects!&#34; ...정말루?",
     
     "tags": ["lisp", "conditions", "algebraic-effects", "programming", "commolisp", "common-lisp", "condition", "restart", "continuation", "effects", "ocaml", "monad"],
     
 "description": "",
 "contents": "뭐 대충 다음과 같은 글들:\nhttps://www.eff-lang.org/handlers-tutorial.pdf\nhttps://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/algeff-tr-2016-v2.pdf\n\u0026hellip;그리고 몇 개의 구현체, 포스팅들: (아직은 별루인거 같은데)\nhttps://hackage.haskell.org/package/fused-effects\nhttps://github.com/dry-rb/dry-effects\nhttps://github.com/digital-fabric/affect\nhttps://github.com/macabeus/js-proposal-algebraic-effects\nhttps://github.com/nythrox/effects.js\nhttps://www.janestreet.com/tech-talks/effective-programming/\nhttps://github.com/ocaml-multicore/effects-examples\nhttps://overreacted.io/algebraic-effects-for-the-rest-of-us/\n\u0026hellip;음\u0026hellip; 분명히 한국말으로 번역도 해놓았고, 심지어 js버젼으로 설명/예시도 있는데 나는 전혀 모르겠다 싶었음.\n오히려 dry-rb, affect이 더 명확하기는 한거 같아.\n가장 실용적으로 접근한 예는, ocaml-multicore에서 활용한 것들 같아 보인다.\n분명히 장점을 볼 수 있을거 같은 개념 같다.\n왜냐하면,\n지금의 monad을 이용한 효과와 사용처의 분리 방식을 생각해보면, 하나의 monad context에서는, 한가지 타입의 monad만을 표현가능. 그래서 여러개의 monad context을 위해 monad transformer 같은것들으로 stacking하여 사용. (\u0026hellip;그때 그때 Haskell do-notation등에 따라 분리해서 표현) 좋은점이라면 좋은점일수도 있겠지만. 그런데, aeffects을 이용한다면, 굳이 그렇게 복잡하게 나누지 않아도 괜찮고, monad처럼 사용처에서 그 효과의 내용을 분리하기도 좋아 보여. 당연히 그렇기 때문에, 원래의 모나드에서 같는 장점을 그대로 잃지 않으면서, 더 평범하게 적어나가기 좋을거 같다. (\u0026hellip;일반적인 imperative programming language에서 I/O/async/await, Maybe등이 동시에 나오거나, \u0026hellip;처럼)\n그래서, 언어적으로 추가된다면 더 기대할 수 있을 것들이:\nMonad이 함수의 타입에 드러나듯이, AEffects도? 그렇게 된다면, 어떤 함수가 어떤 의존성을 갖는지 이해하기 좋으니까. 아마, 앞으로 그럴거 같은데? 그리고, effect handlers들의 composition이 가능할것도 같아. (페이퍼들에서 내가 제대로 읽지 못한거 같은데,) 물론, 굳이 그렇게 하지 않아도, 어차피 사용처에서 복합해 사용한다면, 그렇게 복합된 것을 적용해줘야 돌아갈거고, 또 그렇게 복합된 타입을 지정한것을 타입composition으로 표현만 해도 되겠지만. \u0026hellip;ㅎㅎ그런데 어디까지나 이거 정적타입을 위해서, formal하게 정리한것이고, 현실적으로는:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 (define-condition progress () ((amount :initarg :amount :reader amount))) (defun process-partial-data (data) \u0026#34;NOOP placeholder\u0026#34; (declare (ignore data))) (defun process-data (data) (restart-case (loop initially (signal \u0026#39;progress :amount 0) with total = (length data) for datum in data for i below total do (process-partial-data datum) (signal \u0026#39;progress :amount (/ i total)) ;; Report progress finally (signal \u0026#39;progress :amount 1) (return :done)) (abort-work () (format *trace-output* \u0026#34;Aborting work!\u0026#34;) :failed))) CL-USER\u0026gt; (handler-bind ((progress (lambda (p) (format *trace-output* \u0026#34;~\u0026amp;Progress: ~F~%\u0026#34; (amount p))))) (process-data \u0026#39;(1 2 3 4 5 6))) Progress: 0.0 Progress: 0.0 Progress: 0.16666667 Progress: 0.33333334 Progress: 0.5 Progress: 0.6666667 Progress: 0.8333333 Progress: 1.0 -\u0026gt; :DONE \u0026hellip;생각해보면, 정말 그냥 커먼리습의 conditions/restarts이지 않은가 싶다.\nhttps://news.ycombinator.com/item?id=20496043 , 리습덕후들 말고도 다른 언어에서도 이렇게 된다고 성토하는 분위기. (\u0026hellip;vb은 뭐야 대체, 왜 튀어나온거야\u0026hellip;)\n\u0026hellip;음, 뭐든지 정도가 있어서, 적당히 해야 하는데, 내게 acceptable한 정도는 실은 그냥 커먼리습의 컨디션/리스타트 정도면 acceptable하다.\n그리고 CS논문쟁이 아저씨들의 마수에서 조금은 풀려나서, 꿈과 희망으로 가득찰거 같은 미래세계의 환상에서 깨어나 현실을 돌아보니, 그냥 굳이 그러면 모나드 없어도, 어느 정도 cl으로 나는 만족하고 살수있겠구나 싶기도 한, 예상치 못한 훈훈한 교훈과 파랑새를 찾아버린 느낌까지.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun13--01-ping/","title": "🧑‍🦯 Ping 13/06/2022 .01",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "기운 없는 날\u0026hellip; 쉬어야겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/06jun12sun--02-jq-as-vm/","title": "📱 jq manpage와 code",
     
     "tags": ["json", "jq", "code", "programming", "shell", "vm", "awk", "perl", "m4", "unix", "redis", "lisp"],
     
 "description": "",
 "contents": "https://stedolan.github.io/jq/\njq이 뭐하는 도구인지 소개는 한국어로 많은데, 그걸 갖고 조금 복잡한 패턴을 처리하는 자료는, 머리 나쁜 내가 이해하기에 적합한 자료는 찾지 못해서, 그냥 manpage을 읽고 시도.\n이미 알고 있는 도구, 혹은 이미 대부분의 unix-like, linux 시스템에 깔려있는 도구들이 있는데, 막상 그 도구의 manpage을 차분히 읽어 보면, 내가 너무 게을렀었고 알려고 하지 않았기에 내 삶을 더 도움을 받을 수 있었을텐데, 그렇지 못했었던 도구들이 많은것 같아.\ngnu coreutils, m4, awk, perl 만 해도 그랬었고, 조금이라도 알아가고 응용을 할수록 매일매일이 더 재밌고 강력해졌었던거 같아.\njq도 마찬가지일것 같아. 이 글을 쓰는 시점은 사실 몇주가 지났고, 어떻게 사용할지를, 기술적인 내용을, 어떻게 정리할지는 잘 모르겠다.\n다만, 그래도 받았었던 인상은, 단순하게 보기에는 충분히 정밀하고 재밌는 도구라는 생각. 그 자체의 쿼리, 실행스크립팅, 함수 정의 등이 가능함을 보면서 흥미롭고 재밌었다.\n그래서 저장소의 소스코드를 조금은 읽어보았다. 다른 인터프리터, vm의 코드들과 비슷한 기반을 갖고 나름대로 흥미롭게 구성한거 같았다. (난 잘모르니까ㅋ)\nunix pipes, awk, perl, jq정도면 그래도 꽤 재밌는것들을 만들기에 충분하지 않을까 싶기도 해.\n혹은, 이걸 이해하고, vm까지 이해한 다음에, 이와 유사한것을 내게 필요할때마다 만들어 쓰는것도 가능할거 같다.\n과거 redis을 처음 접했을때, 이걸 이렇게 바라보고, 이렇게 설계해서 사용할수도 있구나 하는 감탄.\n\u0026hellip;문득 재밌게 읽었던 내용 인용: http://www.paulgraham.com/vwfaq.html\nWhat database did you use?\nWe didn\u0026rsquo;t use one. We just stored everything in files. The Unix file system is pretty good at not losing your data, especially if you put the files on a Netapp.\nIt is a common mistake to think of Web-based apps as interfaces to databases. Desktop apps aren\u0026rsquo;t just interfaces to databases; why should Web-based apps be any different? The hard part is not where you store the data, but what the software does.\nWhile we were doing Viaweb, we took a good deal of heat from pseudo-technical people like VCs and industry analysts for not using a database\u0026ndash; and for using cheap Intel boxes running FreeBSD as servers. But when we were getting bought by Yahoo, we found that they also just stored everything in files\u0026ndash; and all their servers were also cheap Intel boxes running FreeBSD.\n(During the Bubble, Oracle used to run ads saying that Yahoo ran on Oracle software. I found this hard to believe, so I asked around. It turned out the Yahoo accounting department used Oracle.)\n\u0026hellip;사실 요즘의 웹앱은 너무 obtrusive하고 over-engineered되어 있는 모습인데, 특정한 부분만 기형적으로 그렇고, 정작 제대로 엔지니어링되어야 할 부분은 전무하거나, 거부하려고 하지.\n마치, \u0026lsquo;프로젝트에서 특정한 xyz방법/활동은 시간낭비-or-너무 할일이 늘어나지 않나요?\u0026rsquo;..같은 질문과 같은거 같아. \u0026hellip;다시 생각해보면, 어차피 조금이라도 제대로 의도를 살려서 해내려면, 그걸 걱정하기 이전에 그냥 해야 하는데\u0026hellip;싶은 생각이 드는 발언처럼.\n마찬가지로, 내가 볼때엔, 정말 재능있는, 그대로 해내는 이를 찾는 방법은 간단하지 않을까. \u0026hellip;그냥 단순히 트렌디한 키워드가 이력서에 있거나, 당장 기술키워드가 매칭되는 경우는 오히려 쉬울지도 모른다.1 \u0026hellip;그냥 매칭되기 위해서 그걸 익히고 썼을테니, 그 이상은 ㅎㅎㅎ\u0026hellip;그렇잖은가.\n그리고 이런 쿼리언어 같아 보이는 것, 혹은 특정목적에 특화된 작은 functional language, logic language이 앞으로 더 가치가 커질 가능성이 높다고 생각. 직접 이걸 사용하지 않더라도 말이다. 위의 \u0026lsquo;너무 많은 웹/앱서비스들이 오버이지 않나\u0026rsquo;이란 생각은, 실은 대부분은 진지하게 코드를 짜고, 그 엔지니어링의 난이도가 엄청 높다기 보다는 착실함, 검증가능하고, 명세적으로 잘 정리하는지, 꾸준히/명확한 방식으로, 자기 ego을 좀 내려놓고 bs 않고, 그냥 해나가면 좋은 결과가 나온다고 생각한다. \u0026hellip;솔직히 말해서. \u0026hellip;그런데 그런 \u0026lsquo;대부분\u0026rsquo;은 역으로 말하자면, 굳이 복잡한 코드를 직접 짜는거 자체가 불필요한 일이고, 지금 과도기적으로 어쩔수없이 해야 하는것뿐이고, 심지어 소모적인데\u0026hellip; 그렇다면 요즘 이야기가 대두되는 코드를 만들어주는 도구들이나 그런것들로 대체가 되어갈것이 당연한거 같아. \u0026hellip;그렇다면, 그렇게 된 시점이라면, 당연히 데이터를 어떻게 잘 조작하고, 다루는것에 집중하게 될테니까.\n음\u0026hellip; 조금 더 상상을 더 발전시켜 보면, 흔히 팔아먹는 기획자와 개발자의 스테레오타입과 그 대립 같은거 별로 좋아하지 않는데,2 어쨌든 그런것들이 되면, 과연 지금의 code literacy 조금 있다고 그럴 필요도, 그게 먹히지도 않을거 같고, 반대로 그때에는 그냥 해내는, 그대로 하려는 이들이 더 좋을 시점이 될거 같아서. 단지 code literacy 조금이 장벽으로서 무너지게만 된다고 해도 말이다.\n“Programming in Basic causes brain damage.” — Edsger W. Dijkstra\nhttps://quotefancy.com/quote/1164258/Edsger-W-Dijkstra-Programming-in-Basic-causes-brain-damage\n\u0026hellip;지금의 \u0026ldquo;code literacy\u0026quot;은 단지, imperative한 사고구조는 그다지 어려울게 없지만, 거기에 익숙해져서 과도기적인 코드를 읽고 따라가는것뿐인데, 실제로 현실의 문제들은 logic language, functional language으로 더 효과적으로 표현될테고, 그건 오히려 역설적이게도 그런 imperative한 mental model에 굳은 이들에게는 더 불편하고, 그렇지 못한 이들이 더 효과적이고 명확하게 표현하기 적합할거 같아.\n\u0026hellip;어느쪽이 됐든, 어떻게 되든 상관없이. 주변인들에게 감사할줄 알고, 미안해할줄 알고, 겸손하고 염치와 양심을 잃지 않고 살아야 하는거 같다. 그렇다면 그때에도 별 상관이 없을테니까.\n흥미롭게도 PG은 이런 hiring에 대해서도 비슷한 관점으로 이야기를 했던거 같은데, 단지 Lisp이 아니라도, 지금도 유효하리라 생각한다. 그 언어가 중요하지는 않지만, 어떤 관점에서는 언어가 실은 중요한거ㅋㅋ 그 기준이 살짝 달라서 자기 편한 이야기일 뿐이라면 골치아픈 이야기가 되지만. ㅎㅎㅎ\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n말그대로 스테레오타입이고, 그거에 빠져서 허우적거리게 진흙탕 싸움을 거는 사람이나 거기에 걸맞게 bs만 늘어놓는 사람이나 어느쪽이든 되고 싶지도, 끼기도 별로이니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/06jun12sun--01-some-engr-tough-sells/","title": "↪️ &#34;Some Engineering Tough Sells&#34;",
     
     "tags": ["engineering", "software"],
     
 "description": "",
 "contents": "https://posco.dev/blog/2022-04-23_draft_some-engineering-tough-sells/\n\u0026hellip;공감이 가는 부분들은:\ndynamic serialization isn’t worth it, use statically defined serialization untested code is virtually always somewhat wrong doing things right pays off sooner than we usually imagine an ounce of design is worth a pound of implementation in data engineering, the data very often violates your beliefs about the shape thinking about, and minimizing edges in your code’s dependency graph is a win a good (i.e. programmable, fast, reliable, reproducible) build system solves a lot of practical software engineering problems \u0026hellip;많은것들을 경험하되, 숙고와 자기객관화는 중요. 아니라면, 경험과 시간은 그저 흘러가게 되니.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-06jun/2022-06jun11-ping/","title": "👊 Ping 11/06/2022",
     
     "tags": ["ping", "blog", "blogging", "jekyll", "hugo"],
     
 "description": "",
 "contents": " Jekyll \u0026ndash;\u0026gt; Hugo \u0026hellip;Jekyll에서, 결국 다시 가볍고 그냥 잘 동작하는 Hugo으로 블로그 변경.1\n생각 남들이 뭐래도 별 관심 없이. 실은 그냥 포장지와 리본장식만 변해가는거고,\n반면. 그 포장지, 리본장식과 그 의미와 가치를 제대로 분간해내지 못하니까.\n도구를 도구로 보면 안되고, 도구가 나를 쓴다는것을 이해해야 하는데. 그래서 도구를 이용해 자유로워질거라 착각하면, 도구에 얽메여 끌려만 가면\u0026hellip;, 그런데 도구에 이용당해 복종할수록 자유로워진다면 \u0026hellip;이겠지.\n끌려가며, 내가 생각치 않은곳에 끌려와 진짜 성장을 얻기도 하는 이도 있고, 끌려가며 원치 않는 방향으로 가며 그게 성장이라고 허울로 하기도 하는 이도 있고.\n그 시각이 별볼일 없이 보며 어떻게든 지켜내고 싶어 안간힘을 내지만 그보다는 버려서 얻어야 할 이도 있고, 그냥 그런것들을 내버려두고 굳이 군불을 지펴 거기에 끼고 싶지는 않지만, 말을 굳이 않고 받을 필요도, 그런것을 받아야할만한 유치한 사람도 아니지만, 오히려 유치한 것을 받아주고 그냥 마음 없이 어쩌다 받은 광고전단지처럼 버리는 이도 있고.\n그래도 내가 뭘 안다고 이야기 하고 싶은 기분도 이제 아니고, 그런다고 좋을것도 없고, 그냥 기다려가면 괜찮을거 같아.\n과거 컨텐츠들은 아카이빙만 해놓고 날렸다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/myself/","title": "🦒 Contact: ageldama?",
     
     "tags": [],
     
 "description": "",
 "contents": "📨 email ageldama@gmail.com\n👾 github https://github.com/ageldama\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-jekyll/2022-06-08--02-pytest-fixtures-and-complexity-mgmt/","title": "🧍‍♂️ pytest fixtures와 의존성관리, 그리고 복잡도관리",
     
     "tags": ["pytest", "fixtures", "dependency-injection", "complexity", "software"],
     
 "description": "",
 "contents": " 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # ...tests/conftest.py import pytest @pytest.fixture def name(): return \u0026#39;Pokemon\u0026#39; @pytest.fixture(scope=\u0026#39;function\u0026#39;) def monster(name): ... # ...tests/foo_test.py : def test_beast(monster): ... # \u0026lt;--- `def monster(..)`의 결과를 주입 받음. https://docs.pytest.org/en/6.2.x/fixture.html\n\u0026hellip;파이썬에 다른 의존성주입 컨테이너들도 있지만, 흥미롭고 실용적이어서 자주 쓰게됨. 내가 소프트웨어 프로젝트에서 가장 중요하다고 생각하는 부분을 잘 캐치해주고, 편안하게 해주는 방식 같아.\n\u0026lsquo;거창함\u0026rsquo;이나 뭔가 남들이 좋다고 쓴다니까, 별 생각 없이 시도하는것들을 보면\u0026hellip; 글쎄. ㅎㅎ\u0026hellip;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-jekyll/2022-06-08--01-asshole-test/","title": "🛴 (HN) &#34;asshole test&#34;",
     
     "tags": [],
     
 "description": "",
 "contents": " Some years back I applied to join IBM\u0026rsquo;s grad scheme, there was a peculiar stage to the process I\u0026rsquo;ve not seen elsewhere. It was during the onsite day, where a batch of 20 or so applicants were put through various tests in an IBM office. They called it the \u0026ldquo;group test\u0026rdquo;; around 8 of us were led to a room and asked to solve a puzzle together. Each of us was given an information pack, there was a white board, and a timer ticking down from 60 minutes. At first there was silence as we looked at our packs, then the first voice: \u0026ldquo;Let\u0026rsquo;s pool our information\u0026rdquo;, someone stands up by the whiteboard, grasping a marker. Silence, it\u0026rsquo;s not clear how this information should be parsed. One person starts reading theirs out word for word. This is not going to scale. Someone interrupts. Before long the whiteboard leader has been deposed and another is wielding the marker. Then another fights for control. The 60 minutes has run out, the puzzle is unsolved. Confused and drained we head off to the next test.\nAt the end of the day the group is split into two rooms, my room is given the good news and I go on to join the grad scheme. Six months later I am shadowing a colleague who is running the \u0026ldquo;group test\u0026rdquo;. I asked him if he\u0026rsquo;d ever seen a group complete the test? \u0026ldquo;Oh, it\u0026rsquo;s not about that, this is an asshole test. You see who turns into an asshole under pressure and they don\u0026rsquo;t make it to the next round\u0026rdquo;.\nhttps://johnpublic.mataroa.blog/blog/the-asshole-test/\nhttps://news.ycombinator.com/item?id=31265554\n예전에 읽었던 글이었다. reddit인가에서도 많이 댓글을 받으며 논란이었고. 개인적으로는 사실상 interviewing process에서 \u0026lsquo;manipulation해서 사람의 본성을 끌어내어 본다\u0026rsquo; 같은거 별로라고 생각. 하지만 글에서 말하고 싶은 내용은 그게 아닌거 같아.\n흔하게 어떤 상황에서 너무 극단적으로 유독해지는걸 보고는 하는데, 글쎄\u0026hellip; 그게 그렇게 용인될만한거 같지는 않다고 생각.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2022-jekyll/2022-06-06--01-hotwired-fun/","title": "🔒 Hotwired 재밌다.",
     
     "tags": ["update", "blogging", "hotwired", "stimulus", "turbo", "webdev", "js", "html", "javascript"],
     
 "description": "",
 "contents": "Hotwired 재밌다.\nStimulus, Turbo + Rails 7 갖고 이것저것 패턴별로 생각해보고 만드는게 즐겁네.\n딱, 이렇게 문제 그자체를 이해하고 설계해놓은 것들은 익히고 사용하는게 너무 즐겁다. rails도 그랬었고, \u0026hellip;처음 볼때에는 뭐 이렇게 단순해? 싶을 정도로.\n너무 거창하거나, 실제로는 그 문제를 깊이 생각해서 푼게 아니라, 너무 범용적이고 범우주적인 해법(예: 상태관리, 컴포넌트 모델)만으로 퉁치려는것보다는. \u0026hellip;이제 그런것들에 혹하거나 끌리지 않게 되었다.\n그리고 또 한편으로는, 모든 해법은 단순하고 우아해야만 한다고 믿고 싶어서 믿는 fanboy가 되고 싶지도 않고.\n(EDIT) [2025-12-25 Thu] Hotwired =\u0026gt; Hotwire \u0026hellip;이후에도 계속 Hotwired이라고 써왔는데, Hotwire이 맞음. ㅎㅎ\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2021-06jun/ping-19sat/","title": "🐱 Ping 19/Jun/2021",
     
     "tags": ["ping", "rust", "emacs", "vim", "c++", "cxx", "python", "golang", "nodejs", "unittest.mock", "pytest", "asyncio", "kafka", "tcp", "server", "context-manager", "multiprocessing", "threading", "typescript", "tokio", "goroutine", "channel", "boost", "asio", "void-linux", "rpi", "raspberrypi", "raspberry-pi", "btrfs", "opensuse", "freebsd", "programming"],
     
 "description": "",
 "contents": " 그간은 여러 수고를 줄이고 싶어서 블로그도 문을 닫아 놓고, github repositories도 대부분은 private으로 변경해놓고 지냈었다.\n하지만 그래도 coding과 글쓰기는 계속 하고 있었었고, 글을 조금씩이라도 공개할까 싶어 다시 문을 연다.\n그간 변한 것이 있다면, 적어도 공부와 코딩 그리고 컴퓨팅에 대해서만,\nRust을 하고 지낸다는 점, 그리고 새로운 네트웍 프로토콜에 관심을 갖고 살고 있는 것, 또 라즈베리파이4와 좋아하는 배포판들이 더 생겼다는 것 같다.\n그리고 여전히 emacs을 즐겁게 잘 사용하고 있고, 오히려 더 vim을 간간히 쓰는 것은 덜 쓰게 된 것 같아. 이제는 너무 이맥스 + evil 설정 등에 익숙해져서 vim을 오히려 더 설정해서 쓰고 싶은 생각도 들지 않는다. ..하지만 다른 이들에게 이맥스를 쓰라고 권하기는 머뭇거려진다. 어릴 때부터 이맥스를 사용했고 그렇게 습관으로 하나씩 하나씩 이맥스 컨벤션과 모드들에 익숙해져서 시간이 오래 걸렸었던 것 같으니까.\nC++, Python 3, Go, Node.js, Rust Python 3, Async I/O은, 작년 한 해 동안은 개인적으로 열심히 사용하며 지냈다.\n파이썬에서 좋아하게 되었던 라이브러리는, Pytest였었는데, 적당히 Pytest + unittest.mock와도 묶어서 테스트를 짜기도 즐거웠고, 파이썬답게 많은 Kafka, SQL 연결 라이브러리들이 이미 잘 Async I/O용으로 갖추어져 있었어서 좋았다.\n직접 만들어 쓰는 TCP서버를 위해, 백그라운드에서 동작해야 하는 작업, clockwork등의 기능을 모두 파이썬 multiprocessing/threading을 쓰지 않고, 그냥 event I/O loop에 등록해서 구현했다. 성능에도 만족스러웠고, async/await/generator와 파이썬의 context manager을 직접 적용할 수 있어서 여러 부분 재밌게, 수월하게 작성할 수 있었었다.\n그리고 그 이후 최근에는 Node.js, TypeScript은 실용적으로 사용하고 지냈었다. 일터에서 쓸 일도 조금 있었었고, 개인적으로 만들어 쓰는 것에도 재밌게 잘 썼었다. 파이썬과는 또 다른 형태로 재밌고 실용적인 것이 node.js인 것 같은데, 거기에 타입스크립트도 재밌게 공부하고 쓸만한 것 같았다.\n(C++11 이전) C++을 사용한 제품을 만들고 관리를 했었는데, 즐거운 경험이었었다. 다들 C++을 싫어하지만.\nRust을 익히고 공부하면서, 재밌는 점은, 오히려 Modern C++을 더 친숙하게 이해하게 된 점일 것 같아. Modern C++의 메모리 관리를 위한 패턴 등이 그대로 러스트에서 컴파일러와 표준 모듈을 사용하며 익힐 수 밖엔 없으니까.\n또, Tokio을 사용하면서, Async/Await을 편안하게 구현해줘서 좋다. 과거의 Go언어를 사용하며, Goroutine, Channel을 사용하고, \u0026#34;sync\u0026#34; 모듈을 사용하여 동시성 패턴을 구현할 때만큼, 혹은 더 편안한 것 같다. Go언어의 그것들이 kit에 가까웠고, 동시성패턴들을 구현하기 적합하고 단순하게 잘 해낼 수 있게 도와줬었다면, Tokio, std::sync::*의 Rust의 것들은 잘 이해하고 있다면 강력하게 사용하기 좋은 것에 가깝기 때문.\nC++의 Boost.Asio을 사용하면, Boost.Context, Boost.Coroutine을 이용해 의외로 경량스레딩, async/await을 나름대로 사용할 수 있게 되었을 때 즐거웠던 것과 비슷한다.1\nRaspberry Pi 4, Void Linux, OpenSUSE USB-HDD, Btrfs 메인데스크탑과 랩탑, 사이드킥 본체 모두 Btrfs으로 ext4에서 convert. 만족스러운 성능인 것 같아.\n사이드킥은 FreeBSD을 오래 설치해놓고 사용해왔었는데, 랩탑과 함께 void linux으로 재설치. 만족스럽다. 가볍고 원하는 방식으로 동작하는 것이 마음에 든다.\n메인데스크탑은 몇 년째 archlinux 설치해 놓은 것이 문제 없이 잘 굴러간다. 가끔 너무 패키지 릴리즈 속도가 빠라서, 새로운 패키지 설치를 위해서 먼저 pacman -Syu을 해줘야 하는 것 빼고는 만족스럽다.\narchlinux, void linux 모두 가벼운 것, 롤링 패키징 방식 등 서로 비슷한 점이 많아서 내가 좋아하는 것 같다.\n하지만, 완전히 다른 안정적인 방식으로 동작해서 마음에 드는 배포판이 더 생겼다. 사이드킥 이외에 raspberry pi 4을 메모리가 조금 큰 버젼으로 구매해서 세팅하며 놀았다.\n책상 한 켠에 저소음 보조 컴퓨터로 쓰려고. void linux, archlinux 모두 뭔가 설치하고 설정하기는 좋은데, 뭔가 아쉬웠다. rpi4용 드라이버 패키징이나 그런 것들이, 가장 괜찮은 배포판은 opensuse이란 점을 알게 되었다. 그리고 가장 설치하기도 편안했고.\n특히 비디오 드라이버는 opensuse은 신경 쓸 점이 없이 바로 잘 동작해서 태어나서 처음 opensuse 계열을 잘 쓰고 있다. 그리고 앞으로도 정착해서 계속 쓸 것 같아.\ndebian은 testing만 이미지를 지원하고 있었고, ubuntu은 설치도 잘 되고 드라이버 지원도 좋은데, 우분투라서 너무 끔찍하게 무거워서 지웠다. 그리고 fedora도 시도를 해봤는데 패키징도 좋고 잘 설정되었지만, 역시 rpi4에서 돌리기에는 이상하게도 opensuse에 비해서 많이 느려서 포기.\n그리고 micro sd에 설치해서 사용하는 방식이 아니라, rpi eeprom firmware을 업데이트하고, 설정을 변경해서 usb hdd에 설치하고, 아예 부팅부터 모두 usb hdd에서 동작하도록 설정해놓아서, rpi4 + micro sd 특유의 툭툭 멈췄다가 계속되는 성능 답답함을 없앴다. 그리고 역시 btrfs으로 세팅했는데 괜찮은 성능.\n하지만 rpi4 aarch64에 메모리도 충분해도, 더 낮은 사양의 인텔, amd cpu보다는 아직은 느린 것 같아. 그냥 저냥 보조용으로만 쓰기에는 좋은 정도. 그렇게 엄청나게 버벅거리지는 않고.\nFootnotes 1 Boost.Asio은 정말 다양한 방식으로 동시성 패턴을 조성할 수 있는데, (Boost.Asio자체적으로 제공하는 방식만으로도), 여기서 언급한 것은 spawn/yield방식. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-29sun/","title": "👝 Ping 29/Nov/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 2020년이 지나간다. 금새 또 봄이 올텐데 기대된다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-23tue/","title": "🙋‍♀️ Ping 23/Nov/2020",
     
     "tags": ["ping", "keyboard", "bluetooth", "logitech", "k480", "membrane"],
     
 "description": "",
 "contents": " logitech k480 bluetooth keyboard https://www.logitech.com/ko-kr/product/multi-device-keyboard-k480\n받아서 묵혀두던 키보드. 팬터그래프 방식을 쓰던 것과는 또 다르지만 그럭저럭 마음에 든다.\n가장 마음에 드는 부분은, 키들끼리의 간격이 적당하고, 키보드 레이아웃에서 마우스 이동이 없도록 키패드 부분이 없는 방식인 점, 그리고 장난감스러운 키보드지만 그렇다고 오타가 넘치도록 너무 대충 만들어진 것은 아닌 것 같아서 그럭저럭 짜증을 유발하지 않으면서 적당히 쓸 수 있는 것 같아서.\n책상에 공간을 너무 잡아먹지도 않아서 그럭저럭 괜찮다.\n다만 블루투스 방식이어서, 건전지를 써서 내게는 조금은 감점.\n당분간은 내 방에서도 기계식 대신에 그냥 조금 조용한 것을 쓰고 싶어져서 시도해봤다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-13fri/","title": "🥜 Ping 13/Nov/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 금새 겨울이 오고 있구나. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/","title": "🎫 Python + Generator / LeetCode &#34;1614. max nesting depth of the parentheses&#34;",
     
     "tags": ["leet-code", "python", "generator", "lazy", "stream", "programming"],
     
 "description": "",
 "contents": " 지난 번 작성한 Common Lisp / LOOP매크로을 이용한 구현 을 다른 언어에서였다면, 비슷한 조건으로 메모리 복잡도 O(1)으로 풀어보고 싶었다.\n1 2 3 4 5 6 7 8 from itertools import accumulate def find_paren_count(s): gen_only_parens = (ch == \u0026#39;(\u0026#39; and 1 or -1 for ch in s if ch in (\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;,)) return max(accumulate(gen_only_parens)) 다른 언어에서도 lazy stream을 지원한다면 비슷하게 풀 수 있을 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-10tue/","title": "💷 Ping 10/Nov/2020",
     
     "tags": ["ping", "vuejs", "reactjs", "vuex", "redux", "jsx", "as3", "flex3", "mxml", "bindable", "webdev", "ria"],
     
 "description": "",
 "contents": " 올해 초에는 Vue.js을 많이 쓸일이 있었었다.\n아주 오래 전에, Adobe Flex에서 MXML, ActionScript3 같은 것을 써서 화면 컴포넌트를 만들던 이후로 거의 10여년 만에 화면에 필요한 컴포넌트를 만들고 개발을 해봤다.\n그 중간 중간 jQuery을 이용해서 웹화면을 만들거나 하는 경험도 있기는 했었는데, 재밌게도 그 이전에 사용하던 MXML, AS3의 컴포넌트 중심 개발방식이 훨씬 앞선 것이었다는 생각을 했다.\n실제로 2008년 정도에도, 현재의 ES6 같은 느낌의 AS3으로, Class based OO을 하고 코딩을 하고, 화면 컴포넌트들을 JSX와 유사한 모양의 MXML으로 조직하고, 또 바인딩을 이용해서 지금의 Vue, React에서 State을 이용하여 데이터를 이용하여 컴포넌트를 어떻게 그릴지 결정해서 개발을 했었었다.\nVue을 하면서 솔직히 그렇게 자연스러운 부분이 적다고 생각했다. 예전 Flex3을 할 때 보다는. 하지만 리액트도 마찬가지고, 어쩌면 더 Flex3보다 구조화와 원칙의 정리가 되어서 그렇다고 이제는 생각한다.\n반대로, 그때 당시에 Flex3을 하는 커뮤니티는 지금의 자바스크립트, 리액트 커뮤니티보다 훨씬 작았었고, Redux, MobX 등의 상태관리 시스템은 물론이고 그 이외에 수 많은 진지한 라이브러리들이 AS3으로 만들어지고 공유되지 않았었던 것 같다.\n지금의 JS커뮤니티는 프론트엔드 개발만이 아니라 Node.js을 중심으로 정말 고품질의 라이브러리들도 많이 만들어지고 공유되는 것이 놀라울 정도다.\n지난 포스팅에서도 조금 이야기를 했지만, 그때의 기술적 한계, 제약 때문에 그런 것들이 세상에 없었던 것이 아니라, 어떤 기술을 바라보는 시점과 그 시각들에서 기대하고 있는 가능성이 아주 하찮았기 때문에 사람들이 그런 개발과 공유를 하지 않았었지 않은가 생각한다. 그리고 그랬었기 때문에 그런 커뮤니티와 생태계가 생겨날 필요도 없었을테고.\n하지만 사람들이 하찮게 생각하고 그냥 대충 넘기려는데에만 급급하던 것에서 다음 단계, 더 나은 방법을 찾던 것들이 한 계단씩 쌓아올려온 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-05thu/","title": "🚉 Ping 05/Nov/2020",
     
     "tags": ["ping", "reading", "books", "book"],
     
 "description": "",
 "contents": " 책을 몇 권 주문했다. 관심이 생긴 새로운 분야에 대한 책들이었는데 흥미롭게도 그 중 두 권이 서로 완전히 다른 분야인데 역저자가 같았다. 아마도 역자 소개에 나온 자신의 업무, 맡은 영역에서 필요하거나 관심이 깊어서 번역한 것 같다. 재밌었다.\n그리고 갖고 있는 한국어로는 아직 나오지 않은 책을 세 권 정도 읽고 싶어서 다시 펼쳤다. 예전에도 조금 읽었었던 책들인데 마음에 들었던 구절들, 생각들이 다시 읽혀져 즐거웠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/org-more-1st-rel/","title": "📣 &#34;org-more.el&#34; released!",
     
     "tags": ["elisp", "emacs", "orgmode", "opensource"],
     
 "description": "",
 "contents": " org-more.el: search .org files have certain tags (#+tags[]: or #+tags[]:)\n개인 위키, KB처럼 org 파일 모음을 사용하고 있는데, 디렉토리 계층과 직접 링크 관계만이 아니라 같은 태그들으로 묶어서 각 파일들을 검색하고 리스팅 할 수 있도록 만들었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-11nov/ping-02mon/","title": "⏫ Ping 02/Nov/2020",
     
     "tags": ["ping", "webdev", "js", "rxjs", "reactive", "frp", "monad", "baconjs", "programming", "javascript"],
     
 "description": "",
 "contents": " (functional) reactive 관련들을 다시 찾아 보고 있다.\n예전에 webdev은 아니고 백엔드를 위해서 rxjs 을 쓸 일이 있었었고 꽤 재밌었다. node.js에서 async/await 이전에 동시성 처리를 하기에 유용하게 쓸 수 있었었고, 실은 그냥 monad이어서 조금만 이해를 하고 사용하면 여러모로 편리했었다.\nhttps://github.com/stoeffel/awesome-frp-js 여기에 보면 rxjs이외에도 다른 js을 위한 FRP라이브러리들이 많이 생겼었다.\n그 중에 흥미가 있어서 bacon.js 을 읽고 rxjs에서 만들어 본 작은 예제 프로젝트를 다시 작성해봤다. 깔끔했다.\nrxjs으로 작성했었던 작은 예제는 다음과 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { fromEvent, Subject } from \u0026#39;rxjs\u0026#39;; // eslint-disable-next-line object-curly-newline import { debounceTime, mapTo, scan, map } from \u0026#39;rxjs/operators\u0026#39;; import jquery from \u0026#39;jquery\u0026#39;; const counter$ = new Subject(); counter$ .pipe( scan((n, acc) =\u0026gt; n + acc, 0), debounceTime(100), ) .subscribe((count) =\u0026gt; jquery(\u0026#39;#count\u0026#39;).text(count)); const counter2$ = new Subject(); counter2$ .pipe(scan((n, acc) =\u0026gt; n + acc, 0)) .subscribe((count) =\u0026gt; jquery(\u0026#39;#count2\u0026#39;).text(count)); const increase$ = fromEvent(jquery(\u0026#39;#increase\u0026#39;), \u0026#39;click\u0026#39;).pipe(mapTo(1)); const decrease$ = fromEvent(jquery(\u0026#39;#decrease\u0026#39;), \u0026#39;click\u0026#39;).pipe(mapTo(-1)); increase$.subscribe(counter$); increase$.pipe(map((n) =\u0026gt; n * 10)).subscribe(counter2$); decrease$.subscribe(counter$); decrease$.pipe(map((n) =\u0026gt; n * 10)).subscribe(counter2$); (package.json, webpack.config.js, 관련 html 파일 등은 생략했다.)\nObservable을 input/output으로 사용하고 서로 연결하는 여러 가지 패턴들을 잘 수용할 수 있을지 테스트 해보았다.\n하지만 어차피 rxjs을 어느 정도 이해하고 있어서 굳이 전환할 생각은 들지 않는다.\n여러 가지로 js으로 재밌게 쓸만한 것이 많아진 시대인 것 같다.\n더 흥미로운 생각은, 이런 거의 대부분의 것들이 실은 예전에도 가능한 것들이었다. 예를 들어, FRP라이브러리를 만들거나 대부분의 shims 같은 것들이 실은 js이 유연함으로 인해서 예전에도 충분히 구현이 가능했었으리라 생각했다.1\n하지만 당시에(2007~2010년 정도?) js으로 이런 것들을 조금 만들고 있으면, 어떤 이들은 그 자신이 \u0026#34;진지한\u0026#34; 언어라고 생각하는 그런 언어에 비해 다른 루비나 리습, js같은 언어는 열등하다고 생각하고, 또 그런 것들에 내가 열심인 이유는 단지 내가 fanboy이어서 그런 것들으로 코딩을 한다고 믿던 이는 우습게 생각했었던 것 같다. 하지만 내가 지금에 와서 생각해 보면 그런 이가 믿던 \u0026#39;진지한 언어\u0026#39;에 대해서 그런 이가 가장 fanboy였었던 것은 아닌가 싶다.\nFootnotes 1 물론 html5, es5에 들어서 추가된 api들이 많아서 그런 것들을 모두 수용하지는 못했겠지만. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/asdf-subdir-finder-1st/","title": "📥 &#34;asdf-subdir-finder&#34; released!",
     
     "tags": ["lisp", "commonlisp", "asdf", "asdf-subdir-finder", "opensource", "common-lisp", "programming"],
     
 "description": "",
 "contents": " 지난번 포스팅한 \u0026#34;asdf 정의를 내 코드베이스의 하위디렉토리에서 자동으로 로딩하기\u0026#34;를 프로젝트으로 만들었다.\nhttps://github.com/ageldama/asdf-subdir-finder\n사람마다 커먼리습으로 작업하는 스타일에 따라 많이 다를 수 있어서 안 써도 되기도 하지만, 그냥 정리해서 공개는 해봤다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/","title": "🔝 &#34;커먼리습 ASDF 불러오기 편하게 하기&#34; 대모험",
     
     "tags": ["lisp", "commonlisp", "asdf", "mop", "common-lisp"],
     
 "description": "",
 "contents": " ASDF와 system definition file 검색의 정석 이전에 ASDF을 이용하여 커먼리습 프로젝트의 의존성, 시스템을 로딩하기 에 대해서 설명한 적이 있었다.\n이전에 다룬 내용은 정석적으로 $HOME/common-lisp 디렉토리에 .asd 파일을 심볼릭링크를 걸고, (asdf:load-system ..) 을 시도하는 내용이었었다.\nPrototyping등 더 편안하게 혼자 코딩을 할 때는… 혼자 커먼리습 코딩을 하면서, 나는 더 간단하게 프로젝트를 시작하는 방법을 선호한다.\n커먼리습이 파일 이름이나 경로에 대해서 의존하는 것이 아니고, 컴파일시점, 로딩시점에 순서에 따라 로딩해서 최종적으로 컴파일하여 적재한 결과 이미지를 더 중요하게 여기기 때문에, 그리고 그런 컴파일, 빌드, 로딩과 같은 모든 단계들 자체도 커먼리습 표현식 그자체로 동작하기 때문에 그냥 하나의 소스파일을 섹션별로 나눠서 작업하면 편리하다.\n큰 흐름은 대충 다음과 같다.1\n그냥 foo.lisp 와 같이 소스 파일 하나를 만든다. 소스 파일 하나에 여러 개의 섹션으로,\nASDF 시스템 선언 (asdf:defsystem ...) 패키지별 패키지 선언 (defpackage ...) 패키지마다 구현 내용 (in-package ...) 패키지에 대한 테스트 (in-package ...) (in-suite ...) …이렇게 한 파일에 전부 넣어서 그냥 주욱 코딩해 나간다. 나중에 규모가 커지고 어느 정도 완성이 되었을 때,\n시스템 선언 -\u0026gt; /*.asd 파일으로 분리. 패키지 선언 -\u0026gt; /src/packages.lisp 파일으로 분리. 패키지의 구현 -\u0026gt; /src/*.lisp 파일들으로 분리. 테스트 -\u0026gt; /test/*.lisp 파일들으로 분리. 그런데, ASDF 의존성을 그런 프로토타이핑 흐름을 위해 적용하려면 일단 커먼리습에서 내 작업 흐름은 아주 간단하다. 그리고 소스파일 1개으로 작업을 하는 것에도 적합하다.\n소스를 작성하다가, 이맥스 Sly/SLIME에서 C-c C-k 눌러서 바로 컴파일, 로드. 그리고 C-c C-z 으로 REPL으로 이동해서, 혹은 REPL의 current package을 소스파일의 특정 영역에서 C-c ~ 을 누르면, 해당 패키지로 전환해서 쉽게 테스트. 테스트 코드가 있다면 그냥 REPL에서 바로 함수로서 실행. 에러가 있다면, 디버거가 실행될 수도 있고, 아니면, 디버거를 통하지 않고서도 C-c I 으로 특정한 값의 구조를 sly-inspector으로 이맥스 안에서 편안하게 디렉토리 오가듯이 오가며 파악하고 변경이 가능. (1)부터 반복. 원래 정석대로 파일을 나눴다면 ASDF을 처음부터 다시 로딩하도록 REPL에서 시도했을 것이다.\n물론 ASDF 파일을 작성해놓았었야 했겠지. 그리고 가끔 ASDF이나 패키지 선언과 달라진 부분이 너무 크다면,\n완전히 다시 REPL을 시작하고 재로딩을 시도했을 것이다. 그런데 asdf 파일을 작성하기도 귀찮고, 심볼릭링크도 귀찮을 때 의존하는 .asdf 파일을 심볼릭링크를 걸어줬어야겠지만, 그냥 새로 만들고 있는 프로토타이핑 프로젝트의 하위 디렉토리로, git submodule add 해놓거나 했을때, 그냥 (ql:quickload ...) 이나 (asdf:load-system ...) 을 프로토타이핑 소스파일의 처음에 로딩하도록 지정해놓으면 자동으로 로딩하도록 만들고 싶다.\n절대경로를 쓰거나, git-submodule들의 디렉토리를 일일이 $HOME/common-lisp 등의 레지스트리로 링크를 걸지 않더라도. 그래서 다음과 같이 \u0026#34;조금\u0026#34; 작성해봤다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 (eval-when (:compile-toplevel :load-toplevel :execute) ;; 필요한 라이브러리들 로드. (ql:quickload :cl-fad) ; 하위 디렉토리에서 파일 검색 \u0026amp; pathname 조작. (ql:quickload :cl-ppcre) ; regex. (ql:quickload :closer-mop) ; funcall-able metaclass. (ql:quickload :equals) ; CLOS객체의 값 비교 protocol. ;; 로딩 하는 소스파일의 디렉토리. (defvar *my-dir* nil)) (unless *my-dir* ;; 처음 소스파일을 컴파일, 로딩 할 때 세팅됨. (let* ((pn *load-pathname*) (dir (cl-fad:pathname-directory-pathname pn))) (setf *my-dir* dir))) ;;; cl-fad:walk-directory 으로 파일 검색 시 조기 중단을 위해 condition 정의. (define-condition cl-fad-matching-found (condition) ((found :initarg :found))) (defun find-asdf-in-subdir (dir asdf-name) \u0026#34;(find-asdf-in-subdir #p\\\u0026#34;/home/my/project\\\u0026#34; :cl-state-machine) ;; =\u0026gt; #P\\\u0026#34;.../cl-state-machine.asd\\\u0026#34; or NIL\u0026#34; (flet ((signal-found (found) ; 검색에 성공해서 매칭 결과를 전달. (signal \u0026#39;cl-fad-matching-found :found found))) (handler-bind ((cl-fad-matching-found ; 검색 성공, 매칭 결과를 되돌리며 조기 종료. #\u0026#39;(lambda (c) (with-slots (found) c (return-from find-asdf-in-subdir found))))) ;; `scanner\u0026#39; 으로 regex 매칭을 준비. (let ((scanner (cl-ppcre:create-scanner (format nil \u0026#34;~a\\.asd(f)?\u0026#34; (string asdf-name)) ;; keyword-\u0026gt;string하면 기본 설정이 대문자이므로. :case-insensitive-mode t))) (cl-fad:walk-directory dir (lambda (name) (let ((base-name (path:basename name))) (when (cl-ppcre:scan scanner (namestring base-name)) ;; 매칭 성공. (signal-found name)))) ;; 디렉토리 항목은 매칭 시도 안하도록. :directories nil) ;; not-found nil)))) ;;; `funcallable-standard-class\u0026#39;을 metaclass으로 지정하여, closure으로 ;;; finder함수를 감싸서 `asdf:*system-definition-search-functions*\u0026#39; ;;; 넣지 않도록 했다. ;;; ;;; closure이 아니라 그냥 CLOS object이므로 `equals:equals\u0026#39;을 구현하기 ;;; 쉽도록. (또 common-lisp 구현에 따라서도 portable하기도 하고) ;;; ;;; http://www.metamodulaire.net/CLOS-MOP/funcallable-instances.html (defclass asdf-finder () ((base-dir :initarg :base-dir)) (:metaclass closer-mop:funcallable-standard-class)) ;;; 반복적으로 `pushnew\u0026#39;해도 동일한 디렉토리에 대한, `asdf-finder\u0026#39;을 ;;; 중복해서 넣지 않도록, `equals\u0026#39;-protocol을 구현. ;;; ;;; `pushnew\u0026#39;을 반복적으로 하게 되는 이유는, 같은 live image에 ;;; 소스코드를 수정하며 컴파일을 반복적으로 하며 점진적으로 개발하는 ;;; 사이클이 커먼리습에서는 편하니까, 그런 개발 사이클에 적합할 수 ;;; 있도록 고려해서. (defmethod equals:equals ((lhs asdf-finder) (rhs asdf-finder) \u0026amp;rest args) (declare (ignore args)) (equals:equals (slot-value lhs \u0026#39;base-dir) (slot-value rhs \u0026#39;base-dir))) ;;; 초기화가 끝난 다음에, funcallable한 객체로 만든다. (defmethod initialize-instance :after ((an-asdf-finder asdf-finder) \u0026amp;key) (with-slots (base-dir) an-asdf-finder ;;; `funcall\u0026#39; 이 이 인스턴스에 대해 적용될 때, 어떻게 동작할지. (closer-mop:set-funcallable-instance-function an-asdf-finder #\u0026#39;(lambda (asdf-name) (find-asdf-in-subdir base-dir asdf-name))))) ;;; ASDF3에 연결. ;;; ;;; 현재 소스파일이 있는 디렉토리 이하에 있는 `*.asdf\u0026#39;, `*.asdf\u0026#39; asdf ;;; system definition file을 자동으로 로딩한다. ;;; ;;; 예를 들어, `(asdf:load-system :cl-state-machine)\u0026#39; 을 시도하면, ;;; `cl-state-machine.asd\u0026#39; 이나 `cl-state-machine.asdf\u0026#39; 을 하위 ;;; 디렉토리에서 검색해 로딩할 것이다. (pushnew (make-instance \u0026#39;asdf-finder :base-dir *my-dir*) asdf:*system-definition-search-functions* :test #\u0026#39;equals:equals) ;; EX: (ql:quickload :cl-state-machine) ;; EX: (asdf:load-system :cl-state-machine) 감상 closer-mop와 funcallable-standard-class 메타클래스를 이용하여 재밌었다.\nclosure function을 ASDF 검색 함수 리스트에 넣으면 간단하겠지만, 그럴 경우에 동일한 base directory에 대해서 검색하는 동일한 함수가 이미 들어가 있을 때 중복해서 넣지 않도록 방지하기는 쉽지 않을 것 같아서, CLOS 객체를 만들고, funcall 가능하도록 만들었다.\n물론 closure일 때도 방법이 없는 것은 아니지만…2 어쨌든 funcall으로 호출해서 검색하고, 또 반대로 CLOS객체이므로 어떤 base directory을 갖는지 다시 알아내기도 편하니까. pushnew을 할 때, :test #\u0026#39;equals:equals 으로 지정하였고, equals을 위해 defmethod equals:equals 을 내가 정의한 asdf-finder 클래스에 대해서 프로토콜 구현을 해줬다. cl-fad:walk-directory 은 기본적으로 하위 디렉토리의 모든 파일에 대해서 실행되는데, 첫 번째 매칭되는 내용을 만날 때 조기종료를 하도록 바꾸고 싶었다.\n커먼리습의 Condition System을 이용하여 아주 간단하게 구현할 수 있었다. 물론 다른 언어의 try-throw-catch 등으로 동일하게 구현이 가능하다. CLOS와 initializer-instance :after 등을 이용해서 AOP처럼 구현하기 용이했다.\n다른 언어였다면, \u0026#34;constructor\u0026#34;등을 override하고 다시 super의 구현을 호출하고 하는 방식이 보통인데… 그렇게 편리한 방법이 아니다. super constructor이 그대로 동작하도록 파라미터를 전달하거나 하는 식으로 신경을 조금 더 쓰게 된다.\n물론 그 방법을 CLOS에서도 쓸 수 있기는 하다. call-next-method 빌드시스템, 컴파일러, 커먼리습 그 자체 등등이 모두 \u0026#34;거기에 있고\u0026#34;, 또 확장이 가능해서 이런 방식으로 쓸 수도 있는 것 같다.\n커먼리습은 다른 언어는 물론, 다른 리습보다도 훨씬 그냥 내가 가장 편안한 형태로 작업하도록 만들 수 있는 것 같다. 컴파일러, 이미지 빌드 자체가 커먼리습 프로그램일 뿐이고, 심지어 컴파일 시점, 매크로 확장 시점, 등등의 시점을 분리해 놓고, 또 그 시점별로도 커먼리습 그 자체로 확장해갈 때마다 재밌다. 첫 인상은 누군가에게는 어쩌면 불친절해보이는 리습이지만, 조금만 이해를 해나가면, 아주 오래전에 설계한 HyperSpec을 정하는 당시에 이렇게 얼마든지 자유롭게 쓸 수 있도록 설계를 해놓았다는 것을 느낄 때마다 놀랍다. 코드를 작성하고, 빌드하고, 테스트를 실행하고, 디버거를 쓰고, inspector을 읽는 매 사이클을 가장 최적으로 쓸 수 있어서 좋다.\n이맥스에서 Sly, SLIME 같은 커먼리습 개발 환경에서 그냥 다 연동되어 있고, 그냥 C-c C-k 누르면 바로 전체 컴파일이 되고, C-c I 으로 특정한 식의 결과를 평가해서 inspector으로 구조를 그냥 이맥스 안에서 계층적으로 살펴보고 바꿔볼 수 있고,\n디버거도 마찬가지이고, …요즘의 자바스크립트를 위한 웹브라우져에 내장되어 있는 developer tools 정도가 그냥 개발환경, 개발 이미지에 바로 직접되어 있고, 그게 정말 빨라서 컴파일이 몇 초나 걸리지도 않는다. 그냥 생각을 하는대로 작성하고 테스트해볼 수 있다. 그리고 무엇보다 그런 사이클에 맞춰서 확장, 변경이 용이하니까. Footnotes 1 처음 Clojure의 프로토타입을 개발할 때도, 커먼리습 파일 하나로 시작했다고 알고 있다. 그리고 Tcl을 사용했지만, Redis의 경우에도 tcl 파일 하나로 프로토타이핑을 시작했다고 한다. https://gist.github.com/antirez/6ca04dd191bdb82aad9fb241013e88a8 처음 프로토타이핑을 할 때 집중도 쉽고 간략히 내가 원하는 내용을 굳이 파일이름을 정하거나 디렉토리 구조를 고민하지 않아도 되는 언어들, 이미지 기반의 언어들이거나, 커먼리습, 스몰톡, 펄, Tcl 같은 경우 더 이렇게 작성하기 편하다.\n2 finder 함수에 대해서 심볼을 설정하고, 그 심볼에 (setf (get …)) 하는, property list을 이용하면 된다. 하지만 어디까지나 심볼을 할당해야 하고, 그 심볼이 정말로 매 컴파일 사이클마다 유지될지, 그렇게 되도록 해야할지는 잘 모르겠다. 그다지 예쁜 방법은 아니다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/leet-code-1614-2nd/","title": "🐖 CommonLisp (w/o LOOP-macro) / LeetCode &#34;1614. max nesting depth of the parentheses&#34;",
     
     "tags": ["leet-code", "lisp", "programming", "commonlisp", "common-lisp", "disassemble", "assembly", "disassembly", "reversing"],
     
 "description": "",
 "contents": " 어제 작성한 LOOP매크로을 이용한 구현 을 풀어서, 만약 LOOP매크로가 없었더라면 어떻게 짰을지 작성해봤다.\n1 2 3 4 5 6 7 8 9 10 11 12 (defun max-nested-parentheses-raw (s) (declare (optimize (speed 3) (safety 0)) (type simple-string s)) (let ((n 0) (result 0)) (declare (type fixnum n result)) (dotimes (s--cur-idx (length s)) (let ((ch (elt s s--cur-idx))) (when (member ch \u0026#39;(#\\( #\\))) (incf n (if (eql #\\( ch) 1 -1)) (setf result (max n result))))) result)) 여전히 타입을 지정해서 자동으로 타입추론, 최적화 하도록 했다.\n그런데 여전히 dotimes, when, incf, max 같은 커먼리습 HyperSpec에서 표준에 포함시킨 매크로 등을 사용했다. 물론 이런 것들도 다 풀어서 작성해도 되겠지만 별 의미는 없을 것 같아서.\n어제 작성한 내용이 얼마나 표현력이 좋았는지, 그리고 그 표현력을 희생하지 않고, 또 반대로 표현력을 그대로 유지하면서도 얼마나 간결하고 효율적인 코드를 생성하는 매크로인지 LOOP-macro에 대해서 생각해볼만하다.\n참고로, SBCL 컴파일러에서 disassemble을 해서 보면, LOOP-macro 버젼이 어셈블리 코드가 더 짧다. (90바이트 정도. Linux/x86_64 플랫폼에서)\n흥미로웠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/leet-code-1614/","title": "🫛 CommonLisp / LeetCode &#34;1614. max nesting depth of the parentheses&#34;",
     
     "tags": ["leet-code", "lisp", "programming", "commonlisp", "common-lisp", "assembly", "disassemble", "disassembly", "reversing"],
     
 "description": "",
 "contents": " 문제 https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/\n작성한 코드 1 2 3 4 5 6 7 8 (defun max-nested-parentheses (s) (declare (optimize (speed 3) (safety 0)) (type simple-string s)) (loop with n fixnum = 0 for ch across s when (member ch \u0026#39;(#\\( #\\))) do (incf n (if (eql #\\( ch) 1 -1)) maximizing n)) 코드 의도 우아한 코드보다는 공간복잡도가 O(1) 이고 싶었다. Edit SBCL에 맞춰 코드에 타입을 지정해줘봤다.\n결과 어셈블리 코드가 조금 짧아졌다. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-19mon/","title": "🔀 Ping 19/Oct/2020",
     
     "tags": ["ping", "dortmund", "coffee", "pink-floyd", "music", "song", "album", "the-dark-side-of-the-moon"],
     
 "description": "",
 "contents": " 가을 도르트문트 집은 꽤 평화로웠다. 날씨가 좋은 날도 많고 공기도 맑았다. 한가한 주말이 되면 창문을 열고 잔디가 깔린 정원을 보며 담배를 태우고 커피를 내려 마셨다.\n그리고 지하세탁장에 빨래를 돌려놓고 핑크플로이드의 다크사이드 오브 더 문 앨범을 좋은 스피커로 틀어놓았다. 잘 어울렸다.\n서울의 변두리에서 맞는 이번 가을은 그런 기분이다. 조용하고 가을 햇살과 공기가 맑아졌다.\n그리고 핑크플로이드를 그렇게 여유롭게 들을 수 있었다.\n오늘 읽으려는 글 http://www.mcs.vuw.ac.nz/comp/Publications/CS-TR-02-9.abs.html\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-17sat-2nd/","title": "🍃 Ping (2nd) 17/Oct/2020",
     
     "tags": ["ping", "lisp", "common-lisp", "commonlisp", "opensource", "hyperspec", "programming", "reactjs", "webdev", "parenscript", "guile", "scheme", "racket", "clojure", "vuejs", "clojurescript", "reasonml", "typescript", "ecmascript", "elm", "transpiler", "php", "macro", "vdom"],
     
 "description": "",
 "contents": " 올해 초 cl-state-machine 라이브러리를 만들어 공개한 이후로 커먼리습을 쓰지는 않았다.\n다른 직업상 쓰는 언어들만을 쓰고 오픈소스와 개인적으로 만들고 싶은 프로젝트를 위해서 쓰는 언어인 커먼리습은 미뤄두었었다.\n다시 커먼리습을 해야겠다고 생각이 들었다. 개인적으로 만들고 싶은 프로젝트도 있고, 그 프로젝트를 위해서 프론트엔드를 만드는데 React와 Vue을 써보고 이해하고 있어도 쓰고 싶지는 않기 때문이다.\n사실 커먼리습은 그렇게 문법이 예쁘지도, 멋진 React와 같은 멋진 프레임웍이나 최신의 유행하는 라이브러리들을 모두 갖고 있지도 않다.\nHyperSpec을 읽다 보면 아주 쉽게 정의되어 있는 키워드들이 일관성이 있지도, 지금 시대의 관점에서 보기에 익숙한 현대적인 용어들을 사용해서 이름을 지어놓지도 않았다.\n더군다가 그를 사용해서 무언가를 작성하다 보면 금새 hairy한 언어라는 것을 깨닫는다.\n심지어 Clojure이나 Racket, Scheme 같은 언어들처럼 정돈되고 간결한 문법, 내장 함수 이름도 아니고, 심지어 많은 부분 하이퍼스펙에서 정의한 함수들을 재조합해서 흔한 유틸리티 함수 등을 다시 만들어내야 하는 경우도 많다.1\nClojure, Racket, Guile Scheme 혹은 심지어 프론트엔드 개발을 하는 데에, 심지어 ClojureScript, ReasonML을 쓰고 싶지는 않다. 거기에 TypeScript, ECMAScript등을 직접 사용하는 것도 괴롭다는 것을 일 관계로 했었던 과거 프로젝트를 떠올려 봐도 그렇게 생산적이지도, 안전하지도 않다는 것을 잘 알게 되었다.\n심지어 커먼리습으로 프론트엔드 개발을 하는 데에는 parenscript 같은 커먼리습-\u0026gt;자바스크립트 생성 라이브러리가 이미 존재한다.\n그냥 자바스크립트를 생성해내는 부분부터 다시 만들고 있다. 원하는 것을 가장 잘 반영할 수 있기 때문일 것이다.\nparenscript, ClojureScript, ReasonML, 심지어 Elm이나 TypeScript 같은 transpiler 접근이 너무 무겁고 결국 webdev을 하기 위해서 이해해야 하는 지식을 어쨌든 요구하기 때문에 별다른 매력이 없다고 생각한다.\n그리고 Racket의 경우에도 ClojureScript와 같은 것이나 parenscript 같은 접근이 이미 있다.\n그런데 내가 생각할 때, 그런 프로젝트들은 오히려 (나는 너무 멍청해서) 자연스럽게 쓰기 어려웠다. 왜냐하면, 원하는 결과 자바스크립트는 단순한데, 그를 위해서 조금만 그렇게 조립된, 마치 Clojure, Racket이나 커먼리습을 짜듯이 작성하면 자동으로 자바스크립트으로 변환해주는 것이 오히려 더 혼란스럽기 때문이다.\n내가 바라는 것은 커먼리습 코드로 컴파일 시점에 만들어지기를 바라는 자바스크립트를 생성해내는 코드를 짜고, 어떤 부분이 컴파일 시점에 어떻게 동작하고, 그 결과로 자바스크립트로 emit할 부분이 무엇인지 명확하게 이해하고 확인할 수 있는 것이 더 생산적일 것 같다.\n실제로 ClojureScript이나 Racket의 그것은 아예 기존의 Clojure, Racket의 문법과 어휘(let 같은 리습 특유의) 그대로 작성하면 그걸 JS으로 transpile해주는데, 이런 접근법이 내겐 가장 안 좋아 보인다.\n프론트엔드 개발을 하는데 커먼리습을 쓰는 이유는 JS을 직접 작성하는 것은 내겐 너무 재미 없고 또 그런 것들을 편안하게 만들어주는 \u0026#39;JS프로그램을 생성하는 프로그램\u0026#39;을 만들 수 있기 때문이다.\n프론트엔드 JS을 직접 작성하는 것이 사람이 실수를 하건 말건, 마치 예전 가장 바닥의 어셈블리어로 DOS애플리케이션을 작성하던 시절과 비슷해 보이기 때문이다.2 …혹은 현재의 사람들이 그렇게도 쉽게 비웃는 PHP와 같아 보인다.3\nReasonML4, Elm도 마찬가지다. 흥미롭고 많은 부분 간결해졌고 JS을 직접 쓰며 빠질 함정들을 메워놓았고, 심지어 내가 원하는 매크로 기능도 지원을 하지만 커먼리습의 defmacro만큼 내겐 직관적이지 않다. 하지만 ReasonML, Elm에서 보이는 데이터타입의 정리나 패턴매칭 등은 탐난다.\n결국 Scheme을 쓰면서도 내게 아쉬웠던 부분은 \u0026#39;그냥 커먼리습이 아니어서\u0026#39;였었던 것 같다. 그냥 적당히 잘 동작하는 컴파일러와 컴파일 시점, 매크로 확장 시점, 실행시점 모두 내가 정의한대로 확장이 가능하고 그렇기 위해서 live image안에서 코딩을 하면서 가장 편안하다.\nScheme의 우아한 define-syntax-rule 같은 것들이 좋지만, 그래도 그냥 defmacro의 단순함과 라이브 이미지에서 개발하는 점은 커먼리습이 더 편안하기 때문이다. 그리고 스킴이나 라켓을 지양하는 이유는, 전형적으로 \u0026#39;표준위원회\u0026#39;의 pitfall에 빠져서5, 오히려 커뮤니티가 너무 작고 많게 fragmented되어 있고, 그래서 라켓이나 GNU Guile 정도를 제외하고 뭘 쓸 수 있을지 고민되는데다가, 후자는 심지어 제대로 된 빌드시스템, 패키지관리자도 기대하기 어렵다.6\n더 나아가서 타입스크립트 정도를 보면 나는 더 정신이 아득해진다. 타입체킹이 컴파일 시점에 있기는 하지만 적당한 정도로 한계를 갖는 타입시스템, 흔히 현재 대부분의 개발자들이 납득할 정도인 타입시스템이어서 그렇게 유효한 체크가 일어나는지는 모르겠다.7 그리고 그 정도로 타입체킹이 중요하다면 차라리 다른 언어, ReasonML 같은 경우가 더 안전하고 나은 접근일 것 같다. 실은 이미 JS에 익숙한 이들은 TS으로 transition이 쉬우리라 생각하는 것을 이용해서 마케팅에 성공한 예일 뿐인 것 같다. 그리고 그런 쉬운만큼 JS의 pitfall들도 대부분 그대로 이어 받을 것이라고 생각한다.\nClojureScript와 같은 리습을 그대로 JS으로 매핑해 컴파일 하는 방식은 물론, JS 프론트엔드 프레임웍들도 그런 JS의 이상한 점을 그대로 확장해가며 괴로운 모습이다. 내가 볼 때는 인간승리에 가까운 방식으로 프레임웍들을 구현하고 있는 것 같다.\n다시 잘 생각해보자. JS이 어셈블리어와 같은 수준인 상황인데, 그 어셈블리어를 그대로 쓰거나 조금 확장한 문법(ES20xy은 물론 JSX, Vue등의)의 Transpiler을 쓰는 것은 괜찮은 접근일지 말이다. 내 생각엔 그렇지는 않을 것 같다. 여전히 그 어셈블리어의 이상한 점을 가져와 그대로 표현이 일어날거고 다시 그런 oddities은 그 패턴을 더 큰 파장으로, 그리고 아주 유사한 형태를 가진채 번져나갈 것이다.\n실제로 React의 Redux을 보고 있으면 정신이 아득해진다. Mobx으로 조금은 나아진 것 같다. 그리고 Vue의 모든 부분들도 어쨌든 자바스크립트의 문법을 그대로 사용하고 있고, 그 디자인에 영향을 그대로 갖기 때문이다.\n상태관리 패턴을 만들기 위해서, 혹은 값과 바인딩되어 자동으로 DOM객체를 변형하게 만들기 위해서 곡예에 가까운 테크닉을 동원하여 JS프레임웍들을 구현된다. 상태관리 패턴을 배울 때에 x = 42 와 같은 너무도 당연한 JS문장 대신에 setState(...) 을 쓰거나, Proxy 등등과 같은 것은 물론 Transpiler을 통해 신비롭게 동작하는 바인딩을 보고 있으면 무언가 이상한 느낌이다. 하지만 JS의 문법을 확장할 수도, 문법이 리습처럼 균일하지도, 확장 가능하지도 않기 때문임을 생각해본다.\n더욱이 발전해서, VDOM 같은 것을 보면, VDOM으로 인해서 생기는 추가적인 문제들, force re-render이나 VDOM diffing이 제대로 이뤄지지 않아서 너무 무거워지는 화면 등등을 더 고려해야 되게 된다.\n이렇게 말을 하고 보니 세상 혼자 잘난 것 같아 보일 것 같아 걱정이다. 하지만 나도 React이나 Vue이 가장 현실적으로 웹프론트엔드 개발을 하는데 가장 좋은 대안이고 생산적이고 멋지다고 생각하고, 나도 사용을 하며 고마웠었고, 그리고 아마 앞으로도 계속 쓰게 될 것이다.\n나는 지금 내가 어떻게 프론트엔드 개발을 하고 싶은지, 기존의 접근법들에서 이상하다고 느끼고 다르게 해보고 싶은 이유가 무엇인지를 따져보고 있는 중일 뿐이다. 그것도 상업적인 프로젝트으로 팀활동으로서 프로젝트를 한다면 더욱이 리액트나 뷰, 타입스크립트 같은 평범한 기술 스택을 쓰는 것을 선호할 것이다.\n그냥 내가 쓰고 싶은 방법, 개인적인 무언가를 만들 때 쓰고 싶은 것으로서 만들고 있는 것은, 그냥 결국 JS VM, DOM이 어떻게 동작하는지 잘 이해하고 있고, 그를 잘 조절할 수 있고, 그를 위해서 별다른 VDOM이나 추가적인 문법이나 패턴을 너무 많이 익히지 않고 표현할 방법을 원하는 것 같다. 적어도 내게 가장 추가적인 추상화-학습 비용을 요구하지 않고 마치 바닐라JS을 코딩한 것 같은 가벼운 결과물을 원한다. 거기에 표현력은 리습과 매크로를 이용해 조절할 수 있을테니까.\n예전에는 나이가 조금 있는 엔지니어가 말했었다. \u0026#34;프로그래밍언어는 다 똑같다\u0026#34; 그리고 그에 대해 새로운 테크스택을 선호하는 엔지니어는 말했다. \u0026#34;프로그래밍언어별로 생산성과 특성이 다르다는 것을 무시할 수 없다\u0026#34;.\n둘 다 맞기도 하지만, 실제로는 그 말들이 담아내야 할 내용을 잘 포착하지 못한 상태로 말해진 것 같다.\n프로그래밍언어가 다 똑같기 때문에 비주얼베이직6을 쓰며 연상배열도 없어서 끔찍하게 코딩을 하는 사람을 보기도 했고, 그리고 현재에는 끝없이 쏟아지는 새로운 언어와 추가적인 스펙들을 사람들이 열심히 공부해가는데 그 내용은 어딘가 저걸 공부해서 얻기 보다 다른 것을 공부해서 저걸 결정한 사람이 무슨 생각이었는지 이해하면 쉬울텐데 싶은 것들이 너무 많다.8 …그렇게 따라잡기 어려운 경주를 해간다.\n결국 대상하는 실행기계가 어떻게 동작하는지 잘 이해하고 그를 위한 입력 프로그램을 만드는 것을 만들고 싶은 것 뿐이다. 그리고 그 생성기는 간단하고 당연한 결과를 뱉어냈으면 한다. 그 어셈블리 위에 지어진 또 다른 무언가, 더 이해하기 어려워진 무언가를 그냥 익히고 그것과 씨름하는 것은 개인의 재미를 위해 하고 있는 내 프로젝트에서는 사양하는 것이다.\nFootnotes 1 물론 직접 모든 함수들을 작성하지 않고 alexandria, uiop, trivial-* 같은 그런 부족한 부분을 채워주는 라이브러리들이 있다.\n2 https://github.com/denysdovhan/wtfjs …모아 놓으면 이렇게나 가득이라서.\n3 역시 https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ 이렇게 친절하게 정리되어 있다.\n4 현재는 아마 BuckleScript으로 리브랜딩 중인 것 같다. 5 그런 방법, 특히 권위를 가진 위원회가 모든 것을 \u0026#39;민주적인\u0026#39; 방법으로 결정해주면 모든 문제가 사라질거라 믿기는 어렵다. 이슈의 복잡함을 이해하지 못하거나 그런 사유를 하고 싶지 않아서 단순하게 권위에 생각을 포기하고 맡겨버린 것 같은. 하지만 실제로는 그 표준이 제정되기까지 시간이 너무 걸리거나 구현체가 제각각 표준을 다른 수준으로 구현해버린 경우가 스킴 컴파일러인 것 같다. 그나마 JS의 경우에는 그런 위원회의 스펙을 Babel 같은 트랜스파일러를 통해서 성공적으로 반영하고 있는 경우지만.\n6 빌드에 GNU AutoTools을 쓴다.. GNU 프로젝트니까? ㅎㅎ 거기에 guildhall 같은 패키지관리자가 있지만… 차라리 Guix이 더 현실적인 대안으로 보일 정도로 정체되어 있다. 7 https://github.com/clojure/core.typed / https://docs.racket-lang.org/reference/contracts.html 같은 정도로 타입 정보에 정말로 코드가 안전하게 동작하기 위해서 필요한 property을 지정이 가능하지 않은 것 같다. 8 예를 들어, Brendan Eich은 뼛속까지 lisper인 것 같다. 다른 네이밍을 보면 JS개발자들은 \u0026#39;JS스러움\u0026#39;이 따로 있다고 말하고 싶은 것 같지만, 실제로 추가되는 키워드나 그 기능을 보면 리습의 그것이랑 뭐가 다른지, 차라리 리습을 잘 알고 있다면 너무 당연한 것들이었었다. 예를 들어, function* 같은 네이밍을 보면 리습 커뮤니티에서 너무 자주 쓰이는 표기법이다( https://stackoverflow.com/questions/5082850/whats-the-convention-for-using-an-asterisk-at-the-end-of-a-function-name-in-clo ) 그리고 Symbol 같은 최근 JS에 추가된 내용을 봐도 그냥 리습에서 심볼에 대해 이해하고 있다면, interning 같은 것들을 이해한다면 너무 당연해 보인다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-16fri/","title": "🤲 Ping 17/Oct/2020",
     
     "tags": ["ping", "parcel", "webpack", "javascript", "webdev", "programming", "webpack", "elm", "bucklescript", "wasm", "js", ".net"],
     
 "description": "",
 "contents": " 웹프론트엔드 개발을 조금씩 해보고 있다. 처음에는 예전 방식으로만 하려고 하다가 조금씩 겨우 써보던 webpack을 다시 가이드를 차근차근 공부하고 동작하는 방식을 이해하도록 뜯어보고 돌려봤다.\n생각보다 단순하게, 그리고 확장성 있게 쓸만한 빌드도구였다.\n다만 문제는 설정이 복잡하고 이해하기 힘든 점보다는 빌드 시간이 너무 느린 점이었다. (내게는)\n그래서 parcel bundler을 시도 했는데, 설정도 거의 필요 없이 바로 동작하고 하는 점은 좋고, 성능도 정말 빨랐다.\n다만 Vim/Emacs으로 파일을 편집하고 저장할 때, parcel watch 대상인 파일들을 종종 아예 dev-server을 재시작해야만 제대로 동작하는 상태로 빠지는게 조금 짜증났다. 기본으로 webpack보다는 이런 자잘한 부분이 좀 덜 다듬어진걸까 싶다.1\nElm, BuckleScript, WASM, GLSL등 이미 웹개발을 하면서 필요한 부분들을 통합하고 있어서 꾸준히 계속 써가는 것도 재밌을 것 같다.\n그리고 사람들이 JS, ECMAScript, TypeScript을 너무 진지하게 공부하고 하는 것들을 보면 조금은 무섭다. 내 생각엔 새로 나온 문법을 너무 열심히 외우고 뭐가 맞는지 language lawyer이 될 의미가 엄청난 언어는 아닌 것 같다. 차라리 그걸 생성해내고 sanely 작성할 수 있는 도구를 이해하고 익히는 수준이 더 좋을 것 같은데.\nJavaScript is an assembly language. The JavaScript + HTML generate is like a .NET assembly. The browser can execute it, but no human should really care what’s there. - Erik Meijer2\nFootnotes 1 GH이슈 https://github.com/parcel-bundler/parcel/issues/2749#issuecomment-472299242\n2 https://www.hanselman.com/blog/javascript-is-assembly-language-for-the-web-sematic-markup-is-dead-clean-vs-machinecoded-html 재밌는 것은 Brendan Eich 같은 분들도 그렇게 JS을 직접 쓰는 현재가 괴상하다는 생각을 해서… 인 것 같다. 이 말을 한 당사자도 https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist) …이고. 흥미로운 것은 \u0026#39;현실\u0026#39;이라고 말하는 이유들으로 그렇게 하는 것이 최선인 것처럼 하고 등을 떠미는 것 같다. 이 주제만으로 글을 더 쓸 수 있을 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-17sat/","title": "🚏 Ping 16/Oct/2020",
     
     "tags": ["ping", "lisp", "programming", "commonlisp", "common-lisp", "clos", "defmacro", "defclass", "record", "dataclass"],
     
 "description": "",
 "contents": " ADT1만큼 만들어 쓰는 것은 아니지만, 그냥 Kotlin, Python의 dataclass 정도는 쓰고 싶어서 CommonLisp 매크로를 만들어봤다.2\nequals 라이브러리를 써서 동치 비교와 CLOS의 print-object generic function을 구현해서 to-string 정도만 되도록 만들어 봤다.\nmacro body 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 (defmacro define-data-class (class-name parent-classes slot-names \u0026amp;key (no-print-slot-names nil) (no-equals-slot-names nil)) (flet ((accessor-symbol (slot-name) (alexandria:format-symbol *package* \u0026#34;~a-~a\u0026#34; class-name slot-name))) (list \u0026#39;progn ;; defclass (let ((slot-defs (loop for slot-name in slot-names collecting `(,slot-name :initarg ,(alexandria:make-keyword slot-name) :accessor ,(accessor-symbol slot-name))))) `(defclass ,class-name ,parent-classes ,slot-defs)) ;; defmethod print-object (let* ((print-slot-names (set-difference slot-names no-print-slot-names)) (fmt-ctrl (format nil \u0026#34;~{~a=~~a~^, ~}\u0026#34; print-slot-names))) `(defmethod print-object ((obj ,class-name) stream) (print-unreadable-object (obj stream :type t) (with-slots ,print-slot-names obj (format stream ,fmt-ctrl ,@print-slot-names))))) ;; defmethod equals:equals (let* ((equals-slot-names (set-difference slot-names no-equals-slot-names)) (equals-exprs (loop for equals-slot-name in equals-slot-names collecting `(equals:equals (slot-value lhs (quote ,equals-slot-name)) (slot-value rhs (quote ,equals-slot-name)))))) `(defmethod equals:equals ((lhs ,class-name) (rhs ,class-name) \u0026amp;rest args) (declare (ignore args)) (and t ,@equals-exprs))) ))) synopsis / usage 1 2 3 4 5 6 (define-data-class animal () (name age)) (define-data-class bird (animal) ()) (equals:equals (make-instance \u0026#39;animal :name \u0026#34;foo\u0026#34; :age 18) (make-instance \u0026#39;animal :name \u0026#34;foo\u0026#34; :age 18)) 오랬만에 재밌었다.\nFootnotes 1 https://en.wikipedia.org/wiki/Algebraic_data_type 2 사실 ADT을 정의하는 매크로 라이브러리와 이를 위한 패턴매칭 라이브러리가 커먼리습에 이미 있지만. 더 간단하게만 쓰고 싶어서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-15thu-2nd/","title": "🐶 Ping (2nd) 15/Oct/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " … \u0026#39;田大\u0026#39;이라고 적혀 있었다.\n다른 한문으로 쓰여 있어 읽지 못하는 각각의 수 많은 바램들과 이름들 사이로 삐뚤빼뚤한 어색한 글씨로 그렇게 적혀 있었었다.\n너무 단순한 이름, 그리고 설명이 붙어 있었듯이, 다른 사람들처럼 많은 이야기를 적고 싶었지만, 아이여서 그랬는지, 아니면 글을 몰라 그랬는지, 이름만이라도 적어놓은 그 못그린 그림 같은 두 글자를 읽었다.\n누군가 아주 오래 전에 그 사람도 아마도 나와 별로 다를 것도 없는 고민들을 하며 매일을 살았었던 것을 느꼈다.\n아주 오랜 세월이 흐른 후에야 그렇게 만났었던 모르는 어떤 사람이 떠올랐다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-11sun/","title": "👨‍🦱 Ping 11/Oct/2020",
     
     "tags": ["ping", "programming", "framework", "mastery", "hla", "assembly", "assembler", "asm"],
     
 "description": "",
 "contents": " 어째서 더 잘 그럴 수 있을까 무엇인가를 만드는 일은 사실 두 가지 단계로 발전하는 것 같다.\n단지 목적한 그것만을 만드는 일과, 또는 그것을 반복적으로 생산하고 또 더 나은 방법으로 추상화하여 내는 도구를 만들어내는 일으로 구분할 수 있는 것 같다.\n직관적으로 생각했을 때에는, 목적이 명확하다면 당연히 그것 자체를 만드는 일을 이미 존재하는 도구들을 통해서 표현하고 만들면 그만인 것 같다.\n그리고 더 나아가서 결과물을 그냥 직접 만드는 것이 아니라, 그 결과물을 만들기 위한 도구까지 같이 만들거나, 그 결과물이 그를 만들기 위해 고안된 도구를 통해서 만드는 경우가 비교할 수 없이 생산적이고 그 결과물 또한 훨씬 매끄럽고 완성도가 높은 경우가 오히려 보통인 것 같다.\n예를 들어, 훌륭한 웹프레임웍이나 프론트엔드 프레임웍을 자신이, 자신의 회사에서 만드는 제품에 쓰기 위해 만든 경우들을 종종 본다. 그리고 그런 경우에는 그 결과 제품도 훌륭하고 그를 위해 만들어낸 프레임웍도 수 많은 사람들에 의해서 사용되는 경우를 자주 본다.1\n왜 그럴까.\n프레임웍, 프로그래밍언어… 그리고 모델링 \u0026#39;프레임웍\u0026#39;의 예를 언급하는 순간에 납득할 수 있을만한 이유를 떠올렸을지도 모르겠다. 당연한 이야기이다. 그렇게 해야할 일들과 목적을 이루는 방법을 정제하고 일반화하여 도구로 만들어 낼 수 있고, 그럴 노력을 떠올리고 해낼 수 있는 이라면, 이미 뭘해도 잘 해낼 수 있지 않았을까. 당연하다.\n그렇다면 다시 말해 본다면, 그렇게 생각과 방법을 정리하고 일반화 하는 사고를 할 수 있다면, 굳이 도구를 만드는 과정이 없다고 하더라도, 그런 생각을 그대로 좋은 결과물 그 자체를 만드는데에만 투사하면 좋은 결과물이 나올까? …내 생각엔 아마도 그럴 것 같다.\n내 생각엔 좋은 프로그램, 코드, 아키텍쳐는 내 생각엔 사용하는 언어, 라이브러리, 프레임웍이 제공하는 어휘와 idioms만이 아니라 자신이 만드는 주제를 잘 이해하고 그에 맞춰서 적절하게, 사용하는 도구들에 따라 idiomatic한 방법으로 그 자체를 어느 정도 확장하여 그런 생각들을 담아낸다.\n이러한 \u0026#39;확장\u0026#39;은 많은 연습이 필요하고, 잘못 행하기도 쉽다. 과도하거나 idiomatic하지 않은 방법으로 자신의 생각에 맞추려고 사용해 말도 안되는 번잡한 추상화를 해서 아무도 이해하지 못하고, 이해하더라도 사용하는 DB의 기본적인 성능 최적화 기법을 전혀 활용하지 못하고 아주 간단한 쿼리를 작성하는데에 수십줄의 특별한 ORM을 통해서만 가능하다거나2, 굳이 그럴 필요가 없는 언어를 쓰고 있는 데에도 익숙한 모양 그대로를 위해 클래스를 기반한 구조 같은 것을 꼭 짜려고 하거나 하는 것3, 혹은 더 나쁘게 적절하지 않은 추상화를, 그것도 그 추상화 자체가 모든 케이스를 반영하기 위해서 계속해서 예외케이스를 추가해가며 더 이상은 확장이 가능한 것일지 의심스러울 정도로 모두 정리가 되지 않은 경우 등등이다.\n그런 구조와 코드를 짜려고 들 때에, 자신이 뭘 하고 싶은지 고집을 내려놓고 틀렸음을 인정하지 못할 때에, idiomatic하게 맞춰서 다시 배우고 생각해야 함을 인정하기 싫을 때에, 그런 이들은 자신이 들고 있는 도구를 탓한다. 혹은 그러면서도 온갖 비난을 하면서 그런 프랑켄슈타인 같은 결과를 짜고 그게 그 도구의 한계라고 이야기한다. …하지만 실제로는 그 도구를 그 사람은 쓴적도 없는 것이다. 다만 그 자신만이 고안한, 그 자신의 부족한 이해에 맞춰서 제3의 또 다른 무언가를 만들어내 썼었던 것이었을 뿐이다.\n그리고 그 반대도 존재한다. 그 반대는 어떤 프로그램을 읽고 이해한다는 일이, 혹은 작성한다는 일이, 단지 그 프로그래밍언어, 혹은 어떤 프레임웍을 이해하는 일이 전부라고 한정지어 생각하고 있는 이들이 일으킨다.\n무엇을 하려는, 어떤 분야에 적용된 프로그램인지, 그 프로그램에서 어떻게 어휘와 생각들을 패턴화 해놓았는지는 고민하지 않는다. 단지 추가적인 추상화 단계가 있으니, 자신이 알고 있는 프로그래밍언어, 프레임웍보다 많은 도메인과 관련한 이해의 노력과 지식을 필요로 하게 되니 그것이 잘못되었다고 주장하는 경우이다.\n하지만 실제로 그렇게 그 프로그래밍언어와 프레임웍의 것들을 그대로 사용하여 작성된 코드는 실제로는 기계어로 작성된 프로그램과 읽는 사람의 입장에서는 사실상 다를 것이 없다. 어떠한 개념화, 추상화도 없이 그저 기능하도록 주욱 나열된 명령어와 데이터 표현의 나열일 뿐일테니까. 그리고 GUI이나 앱을 만드는 경우에 그런 프로그램을 짜는 경우를 많이 본다. 어쨌든 화면은 출력되고 사용자가 쓸 수는 있겠지만… 글쎄… Visual Basic 6을 쓸 때에, 그런 도무지 이해할 수 없게 작성된, 모든 버튼이 Button_001 … Button_049 같은 이름으로 되어 있는 코드으로 이루어진 프로젝트들이 그 좋은 예일 것 같다.\n추상화와 개념의 정리 같은 것들이 이루어지지 않은 프로그램은 그렇게 보이고, 자신이 하는 일이 그런 것들만을 이용해서 단지 기계부호화 하는 것이라고 착각하는 이들은 특정한 단계의 이들에게서, 그 단계에서 더 성장하지 못하고 있는 이들에게서 유독 많이 보인다.\n그리고 오히려 이미 언급했듯이, 이런 이들은 어떤 제대로 된 프로젝트의 코드를 보여줘도 이해하지 못하고 오히려 역성을 낼 것이다. 자신이 생각하는 수준으로 그 프로그래밍언어 그대로와 프레임웍 그대로 만을 사용해서 Button_019 등으로 가득찬 코드를 자신이 바란다는 듯이 말을 하고 있다는 것을 이해하지도 못한채 불평을 해댄다. 왜냐하면 그는 프로그램의 코드가 그 프로그램이 만들려는 생각을 모델링한 것이라는 것을 부정하고 그 모델을 이해하고 싶어하지 않고 있기 때문이다. 그런 모델이 코드에 반영되지 않은 코드란 말 그대로 기계 부호화하여 저런 Button_019 등으로 가득한 코드를 그 자신이 말하는 바에 따르면 바라는 것이라는 것도 이해하지 못하기 때문에 그런 불평을 해대는 것이다.\n모든 프로그램은 그 프로그램이 목적하는 바에 따라서, 어느 정도 수준으로 모델링되어 코드로 변환된다. 예로 든 VB6 코드는 그것을 작성한 사람이 그 모델이 무엇인지 명확하게 정리하고 이해하지 못했음에도, 어떤 버튼을 누르면 어떤 일이 일어날지만 계속해서 덕지덕지 붙여갔을 것이다. 어쨌든 그것들이 모이면 전체적으로, 결과적으로 무언가 일이 일어나기는 할테니까 암묵적인 모델이 존재한다고 할 수 있다. …다만 만든 사람의 머릿속에서는 그런게 명확하지 못했을 뿐이다.\n어떤 프로그래밍언어, 프레임웍을 쓰건 그 목적하는 만들고 싶은 모델을 사용하는 매개를 적절히 활용하여 가능한한 그대로 표현한다면 가장 좋을지도 모르겠다.4 그리고 그런 모델과 실제 프로그램의 impedance이 작을 수록 예상하지 못한 버그나 코드가 시간이 지남에 따라서 괴상해지는 방향으로만 변경/확장되어 가는 추상화 구조도 적어질 것이다.\n그렇다. 사람들은 코딩을 할 때 단순히 기계부호를 입력하는 것이 아니라, 기계부호를 통해서 자신이 생각하는, 머릿 속에 있는, 혹은 그 머릿 속에 팀원들과 공유한 생각 속의 모델을 그린 설계 문서에 그려진 모델을 코드로 표현해나가는 것이다.\n모델링과 이해, 그리고 반복 어떤 이들은 자신이 특정한 GUI프로그램(앱이든 데스크탑 애플리케이션이든)이나 게시판이나 회원가입, 로그인 같은 애플리케이션을 작성하는데 그런 과정이 필요하지 않다고 주장할지도 모르겠다. 어떠한 사전설계나 정리 없이 그냥 프레임웍에서 제공하는 기능들을 그대로 사용하면 그것으로 결과물이 나온다고 말이다. 하지만 실제로는 그런 주장을 할 때 자신이 어떻게 해내는지 자신을 잘 관찰하고 이해하지 못한 것일 것이다. 왜냐하면 그런 애플리케이션의 모델에 대해서 익숙하고 무의식적으로 고정된 구조를 갖고 그를 만들어내고 있을 뿐인 것이다. 그렇기 때문에 추상화 단계를 고려하지 않고 그냥 재료들을 그대로 노출하며 표현이 가능한 것일 뿐이다.\n그 모델은 결국 그를 생각해내는 사람의 이해의 정도, 깊이에 따라 얼마나 세밀하거나 매끄럽게 적용 가능한 형태로 추상화 되는지가 달라질 것이다.\n그리고 그러한 이해의 깊이는 단순히 첫 번째에 \u0026#39;알았다\u0026#39;라는 것이 아니라, 실제로는 시간을 갖고 반복적으로 실험, 관찰하고 생각하면서 더 깊은 단계로 발전해나간다. 그 첫 번째에 \u0026#39;알았다\u0026#39;의 순간은 실은 잘 몰랐었던 것들을 더 명확하게 이해해 나가고 왜 그랬었는지, 왜 그래야 하는지 등등을 납득해나간다.\n그렇다면, 그 모델을 정리해 만들어내는 것은 자신이 만들 것에 대한 이해의 깊이에 달려 있는 것이라면 어떻게 하는 것이 좋을까. …아마 반복적으로 그것을 다시 만들거나, 혹은 점진적으로 처음 만든 것을 계속해서 개선하며 고쳐나가야 하면서 상호작용을 일으켜야 할 것이다.\n그 말은, 다시 말하면, 생각 속에 있는 모델이 실제로 만들어낸 프로그램에 영향을 주고, 다시 그 프로그램을 살펴보고 생각하면서 그 모델에 다시 반영이 일어나고, 그 반영에 따라 발전한 모델을 다시금 프로그램에 녹여내야 한다는 의미이다. 그런 반복적인 행위를 통해서 개선하는 것이 가장 납득할만한 접근일 것 같다.\n그렇다면 어떻게 반복적인 일을 해내야 할까. 그 반복적인 행위를 얼마나 쉽고 납득할만하게 경제적으로, 시간적으로나 노력의 측면에서나, 해내는지가 그 반복을 생산적인 결과로 바꾸는데에 중요할 것 같다.5\n원래의 질문으로 돌아가서, 프레임웍을 만드는 이들은 한 단계 더 자신이 무슨 일을 하는지를 추상화하기 위해서 생각을 해야 했을 것이다. 그래야만 재사용이 용이한 형태로 프레임웍으로 정리를 해낼 수 있었을테니까 말이다. 물론 그런 정도의 작업을 해내는 이라면 경험과 이해가 더 깊을 것이었을 것이다. 이미 시작하는 시점에.\n하지만 그런 프레임웍을 만드는 것만이 전부는 아닌 것 같다.\n흔히 프레임웍을 말하면 떠올리는 것은 기술적 영역에서 프레임웍을 연상한다. 예를 들어, 웹프레임웍이나 프론트엔드 프레임웍. …그러한 프레임웍들은 그런 일들, 웹API 엔드포인트를 노출해내거나 화면을 그리고 사용자와 반응할 수 있게 만들고 재사용 가능하게 만들거나 하는 영역을 일반화/추상화를 해낸 것이다.\n하지만 자신이 만들고 있는 프로그램은 그것만이 필요한 것이 아닐 때가 많다. 그 프로그램이 특정한 도메인의 지식을 필요로하고 그에 맞춰서 동작해야 한다거나, 특정하게 정리된 컴퓨터과학의 유한상태기계나 범용문제풀이기6이나 기호 공간에서 back-tracking을 이용하여 추론을 해내거나 하는 등등의 기법과 구조를 사용해야 한다면 그에 맞는 프레임웍을 고안해 사용해야 할 것이다.\n그리고 그런 프로그램마다 다를 프레임웍은 정말로 웹프레임웍처럼 오픈소스 등을 그대로 가져다 쓸 수 있는 경우도 있고, 혹은 도메인 모델로 정리하여 객체구조로 정리해 써야 하는 경우도 있고 다양한 방식으로 프로그램에 녹아 들어간다.\n결국 자신의 프로그램을 얼마나 높은 이해의 수준에서 바라볼 수 있게 되는가에 따라서 표현이 정교하고 완성도가 결정되는 것 같다.\n그럼에도 내가 설명한 방법에도 한계를 느끼게 되는 경우가 종종 있다. 사용하는 프로그래밍언어이나 프레임웍의 표현의 한계나 제한으로 인해서 모델에는 명확하게 존재하지만 프로그램 코드와 그 구조에는 묵시적으로만 나타나는 경우들이 생기게 된다. 그리고 이들은 그 코드를 컴파일하여 최종 프로그램으로 만드는 컴파일러와 프레임웍은 이해하지 못하는 것으로 암묵적으로 숨겨져 존재하므로 더 세밀하게 검증되어야 하고, 적절하게 그렇지 못한 경우에는 버그의 가능성이 되기도 한다.\n예를 들어서, 슬프게도 프로그래머들만이 납득할만한 예겠지만, C/C++ 코드를 작성할 때에, 작성자는 어느샌가 메모리 관리 모델을 머릿 속에 갖게 되고 그에 따라서 코드를 작성한다. 하지만 C/C++의 표현의 한계는 그 메모리 관리 모델에 대해서 이해하지 못하는 컴파일러이고, 그렇기 때문에 컴파일 하는 시점에 그 메모리 관리 모델에 어긋나게 작성된 코드를 그냥 통과시켜주고 결국 실행시점에 메모리에러나 보안문제를 일으킬 수 있는 코드를 만들 수 있도록, 버그를 체크해주지 못하고 허용해준다.\n물론 최근의 Rust와 같은 프로그래밍언어는 그러한 메모리 관리 모델을 명시적으로 코드에 표현할 수 있게 하였고, 그런 체크를 컴파일러가 해준다. 그래서 그런 메모리 버그가 가능하지 않게 되었다.7\n결국, 코드에 명백하게 그대로 드러나지는 않았지만, 코드 부분의 서로의 관계 등을 이해한 다음에 그런 메모리 관리 모델이 적절한지 이해할 수 있을 것이다. 그리고 그런 코드를 제대로 잘 동작하도록 작성하려면 그런 모델을 머릿 속에 갖고 이해한 상태에서 작성이 가능할 것이다.\n다른 프로그래밍언어들도 마찬가지다. 메모리 관리 모델 같은 것만이 아니라 프로그래밍언어별로 이해를 필요로 하는 색다른 Paradigm과 같은 것들을 머릿속에 모델으로 정리하여 갖고 있지 못하다면 제대로 그 언어에 어울리는 코드를, 효율적인 방법으로 작성하지 못한다.\n내가 만약 마이크로소프트 엑셀과 같은 스프레드시트를 작성하고 있다고 하더라도, 화면에 나타나는 각 셀Cell와 같은 요소들이 모두 그대로 코드에 대응하여 드러날지는 의문이다. 물론 그렇게 추상화를 해놓았다면 명백하게 드러나겠지만 실제로는 그 코드들의 뭉치가 잘 작성되어 조합되고 실행되었을 때에야 비로서 실체를 갖춘 엑셀과 비슷한 화면을 접하게 될 것이다.\n머릿속에 있는 모델을 코드로 옮기는 일은, 그 코드에 명백하게 드러날 수 있지만, 더 복잡한 대상을 모델링한 경우일수록 코드만을 액면적으로 보았을 때 잘 드러나지 않거나, 아예 시간의 흐름을 갖고 실행시켜 보았을 때에야 비로서 확인이 가능해지기도 한다.\n바로 그렇기 때문에 내가 생각한 모델을 거의 그대로 표현하고 그것을 다시 코드로 전환해주는 도구가 필요해진다. 왜냐하면 말했듯이 이미 존재하는 프로그래밍언어, 프레임웍은 대부분 일반적인, 그리고 그래서 너무나 일반적인 모든 상황을 포괄하고 싶어했기 때문에 특정한 상황의 모델을 표현하기 너무 번거롭거나 그렇기 때문에 잘 드러내지 못할 정도로 일반화되어 있기 때문이다.\n웹프레임웍은 웹API, 엔드포인트를 만드는데에 초점을 맞췄기 때문에 그 비즈니스로직을 표현 하는데에는 잘 드러내지 못한다. C/C++은 일반적인 프로그래밍언어이기 때문에 메모리 관리 모델을 명백하게 드러내지 못한다.8\n그래서 오히려 자신의 도구를 직접 고안하고 만들 수 있는 단계는 그 자신이 무엇을 하고 있는지 잘 이해하고 있을 것이고, 또 반대로 그 이해를 가속하고 깊이를 더할 반복을 잘 해낼 수 있도록 돕기도 할 것이기 때문일 것이다.\n반대 시작점으로부터의 관점에서의 모델 글의 이전 부분에서는 큰 단계에서, 상위 수준에서의 단계에서 모델을 이야기했다. 프로그램의 목적에 따른 모델을 이야기했다.\n짧게 그 반대의 방향으로 동작하는 모델에 대해서도 이야기를 하고 싶다. (사실은 이전의 이야기에서 예로 든 웹프레임웍이나 C/C++의 메모리 관리 모델도 이에 해당하기도 한다.)\n이전의 이야기는 마치 이미 존재하는 부품들을 잘 묶어서 더 큰 부품을 만들어 추상화하는 방향의 모델링에 대해서 이야기한 것 같다.\n하지만 그 반대로 그 부품을 쪼개어서 다시 이해한 경험과 그로 얻은 생각도 이야기를 하고 싶다.\n아주 예전에 HLA 이란 어셈블리언어를 사용했었던 적이 있다. 그때에 나는 C/C++와 펄/파이썬, 혹은 델파이를 이용하여 프로그램을 작성하던 때였었다. (2000년도 전후)\n그런데 HLA을 익히고 간단한 MS윈도용 데스크탑 애플리케이션을 작성하기 시작하면서 많은 생각이 변했었다.\n어셈블리언어이기 때문에 많은 부분 CPU구조에 깊이 연관되어 있고 다른 플랫폼에서 절대 다시 빌드하여 재사용할 수 없는 코드이기는 했다. 하지만 그럼에도 매크로 엔진과 적당한 제어구조 매크로, 라이브러리 등이 갖추어져 있어서 아주 간단하게, 심지어 때로는 C/C++으로 직접 Windows API을 이용하여 코딩한 애플리케이션만큼 간결하고 그 구조를 파악하기 명료하게 코드를 작성할 수 있었었다.\n당연한 이야기이지만 C/C++, Delphi을 컴파일한다면 얻을 코드를 직접 뜯어서 해석하거나 하는 방법으로 이해한듯이 명확하게 이해할 수 있었었다. 내가 작성한 코드가 실제로는 어떻게 기계에게 전달될 것인지를.\n그간 Delphi이나 C/C++을 통해서 잘 감추어진 MFC와 같은 프레임웍을 쓰고 또 C/C++에서 제공하는 class 와 같은 언어-construct들이 어떻게 무엇을 감추고 추상화 주었는지를 다시 생각해보는 계기가 되었었다.\n그리고 그런 이해를 기반으로 다시 해체의 방향이 아니라, 역으로 조합의 방향으로 어떻게 생각해야 할지를 깨달았었던 것 같다. 해체하여 원하는 것을 어떻게 얻는지를 알게 되었으니, 반대로 어떤 수준의 원자들 모으고 그들을 조합하여 어떻게 결과물을 도출할 수 있을지를 생각하기 시작했다.\n이전에 이야기한 프레임웍 제작자들도 마찬가지일 것이다. 그들은 어떤 원자들을 이용하여 원하는 방법으로 표현하고 그들을 어떻게 조합해 쓸지를 고민하고 알게 된 것이다. 당연히 강력하게 자신의 생각을 잘 표현할 수 있을 수 밖에 없다.\n그런 해체와 조합의 과정이 어떤 자유를 줄 수 있는지를 느끼고 그때 정말 큰 상쾌함을 느낄 수 있었었다.\n그렇다고 오늘날 어울리지 않을 HLA을 공부하지는 않았으면 좋겠다.\nFootnotes 1 물론 현실적인 제약, 시간과 예산의 한계로 그렇게까지 해낼 수 없는게 대부분의 프로젝트들임을 잘 알고 있다. 그런 경우를 제외하고 생각했으면 좋겠다. 하지만 그럼에도 정말로 당장 내 앞에 놓여 있는 과제가 그렇게 수행해야만 하는지는 매순간 다시 잘 판단해볼만하다고 여전히 여지는 남겨두고 싶다.\n2 RDBMS을 쓸 때에 적용이 가능한 아주 기초적인 인덱스와 JOIN 같은 것들을 제대로 활용하지 못할 정도로 너무나 normalization이 심하게 되어 있어서였었다. 사실 이렇게 데이터구조를 설계한 사람은 자신이 하는 일이 RDBMS에 적절하지 않고 다른 GraphDB이나 Embedding이 가능한 Document DB을 써야 했을거란 것을 이해하려고 들지 않았었던 것 같다. 그리고 그런 데이터모델은 사실 그 자신도 인지하지 못했겠지만 \u0026#39;그린스펀의 열번째 규칙\u0026#39;에 따라 그만의 커먼리습을 만들고 있었던 것 같다.\n3 예를 들어, Prototype based OO 을 이용하고, Functional하게 짜는게 기본인 언어를 쓰고 있음에도, 익숙한 클래스 기반과 xUnit 같은 테스트케이스를 클래스별로 나누고 싶다는 생각에 굳이 괴상하게, 그리고 산만하고 잘 동작하지도 않는 Java-alike하게 짜는 경우, 또 거기에 익숙한 Dependency Injection 구조를 functional한 방법으로 해결할 수 있는 상황임에도 자바의 그것들과 유사하게 만들려고 애를 쓰는 경우를 본 적이 있다. 그랬을 때의 그 결과는 이 글의 본문에서 계속 이야기 할 것이다.\n4 그 모델이 납득 가능하고, 설명을 해주는 추가적인 설명이나 자료들이 있다면 그를 이해한 다음에 코드를 보기만 한다면 이해할 수 있을테니까.\n5 그런 반복은 이미 많은 이들이 쉽게 간과하는, 그렇게 exciting해보이지는 않는 주제들을 얼마나 잘 이해하고 활용하는지에 따라 달렸다. 새로운 프로그래밍언어나 화려한 이름의 프레임웍이 아니라, 그런 이들이 보기에 무시가 가능하고 아주 지루해보이는 키워드들일 것이다. 하지만 이 \u0026#39;모델\u0026#39;에 대한 생각을 이해하지 못했기 때문일 것이고, 이해를 했다면 어떤 것을 더 하고 싶어질지가 달라질 것 같다.\n6 실은 GPS(general problem solver)은 쓸 일이 없겠지만.\n7 그리고 더 최근에는 C++ 컴파일러들도 그런 메모리 관리 모델을 체크하여 컴파일러가 알려주기 시작했다. 하지만 Rust에 비하면 한정적인 상황에 대해서이고, 그들도 STL와 같은 \u0026#39;패턴화된\u0026#39; 표현을 따를 때에, 즉 그 명시적으로 메모리 관리 모델을 표현하는 경우에 잘 체크를 해주는 것에 한정적이다. 다시 말해서, 그런 모델을 명시적으로 표현할 방법이 중요했던 것이다.\n8 거짓말이다. 실은 그 프로그래밍언어 설계 자체가 알아서 자유롭게 하도록 열어놓았기 때문일 것이다. 단지 위에서 예로 들었기 때문에 그냥 언급했다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-10sat/","title": "🔀 Ping 10/Oct/2020",
     
     "tags": ["ping", "macbook", "macbook-air", "wifi", "linux", "macos", "network-manager", "nmcli", "rpi", "raspberrypi", "raspberry-pi", "battery", "archlinux"],
     
 "description": "",
 "contents": " 오래 써오던 맥북에어의 WIFI이 성능이 계속 안 좋아졌었던 것 같다.\n모델명을 알아보니, 2012년 형이었다. 정말 오래 썼구나. 1\n어차피 MacOS을 여러 가지 이유로 좋아하지 않아서 그냥 아치리눅스2를 설치하고 그대로 쓰고 있다.\n최근에는 아예 WIFI을 USB-LAN으로 연결해주는 RPi을 만들어 쓰고 있었다. 물론 내장WIFI은 너무 느려서 nmcli r wifi off 을 기본으로 아예 S/W Disable시켜놓고 살았다.\n어쩌다 계기가 있어서, USB-LAN연결용 RPi을 챙기지 못한 외부에서 어쩔 수 없이 쓰려고 시도해보니, 아예 조금 내장WIFI을 쓰면 조금 동작하다가 시스템이 뻗어버린다. …아예 맛이 갔나보다.\n아마 뜯어보면 먼지나 그런 것이 문제가 아닐까 싶은데, 뜯고 청소할 생각은 들지 않는다.\n배터리도 2시간 30분 정도만 full충전해도 버틸 수 있는거 같다. …나중에 배터리 효율이 더 나빠져서 교체할 때 뜯어서 청소를 해볼까 싶다.\n성능면에서는 데스크탑이나 다른 성능이 좋은 랩탑을 구매해야겠지만 당분간은 그냥 글을 쓰고 웹브라우징을 하는데에는 만족스럽다.\nFootnotes 1 sudo dmidecode --type 1 으로 \u0026#34;Product Name: MacBookAir5,2\u0026#34; 나와서, https://support.apple.com/ko-kr/HT201862 에서 찾아보니.\n2 \u0026#34;i use arch btw\u0026#34; …2014년부터 계속 써오고 있다. 다시 젠투나 그런 것을 그 이후로는 사용할 생각이 없어졌다. 우분투를 쓰는 것은 도대체 어떻게 그렇게 무겁고 윈도 같은 느낌인데 리눅스으로 쓰는지도 이해가 안되기 시작하고.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-08thu/","title": "🫳 Ping 08/Oct/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 벌써 겨울 날씨에 매일 다가가는 것 같다. 시간이 흘러가는 것을 며칠 눈치 채지 못하다가 다시 눈치 챌 수 있게 되었다. 다행이다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-04sun-2nd/","title": "⛔ Ping (2nd) 04/Oct/2020",
     
     "tags": ["ping", "earphone", "earbud", "dac"],
     
 "description": "",
 "contents": " 막귀의 이어폰 선호 정말 이어폰을 여러 개를 아작을 내면서 살아온 것 같다. 헤드폰은 겨울에만 편안한거 같고.\n일을 하며 소음에서 분리되고 싶을 때, 집중하면서 또 집중 상태에 들기 위해서 시간을 버리며 고생하고 싶지 않을 때도 많이 쓴다. 덕분에 청력은 조금 나빠지는 거 같다.1\n과거에는 정말 싸구려 이어폰, KTX에서 나눠주는 일회용 이어폰을 꽤 오래 쓴적도 있다. 특유의 딱딱하고 AM라디오스럽게 소리를 만들어 버려서 이상한 소리가 나지만 막 쓰기 좋아서였다.\n그리고 그 이후로는 나도 모르게 어쩌다가 DAC칩이 좋은 것이 붙어 있다는 스마트폰과 거기에 번들로 줬었던 쿼드비트 이어폰을 재밌게 썼었다.\n아쉬운 것은 그 이어폰을 잃어버린 줄 알고 있다가 다시 겨울 코트를 꺼냈을 때 주머니 안에서 발견했을 때의 당혹감이었다. 그리고 그 이어폰을 쓰지 못하게 되었을 때 그래도 그게 소리가 매력적이어서 내가 계속 찾고 있었었다는 것을 깨달았다.\n그 이후에 어쩌다보니 지금은 집에 쿼드비트 시리즈 이어폰만 몇 개가 쌓여있다.\n소니 플스4에서 번들 이어폰이랑 노이즈 캔슬링 이어폰도 좋았던 것 같다. 그리고 심지어 편의점에서 그냥 사서 써본 만원 정도 하는 이어폰도 소니 이어폰은 만족스러웠다. 그냥 가격에 비해서 그냥저냥 좋다.\n요즘은 좋아하는 싸게 샀었던 젠하이저 이어폰을 집에서 데스크탑에 연결해서 게임을 하거나 음악을 들을 때 사용한다. 만족스럽다. 또 사거나 같은 브랜드의 조금 더 하이엔드의 헤드폰이나 이어폰으로 시도해볼까 생각이 드는 만족감이다.\n\u0026#34;양심을 팝니다\u0026#34; 동네에 지나치다가 본 간판이 정말 충격적이었다.\n양심적으로, 정직하게, 우직하게 등등등의 표현을 쓰고 맨 마지막 문장에 다음과 같이 써 있었다. \u0026#34;우리 가게는 (상품이 아닌) 양심을 팝니다.\u0026#34;\n음… 아무리 그래도 그건 팔면 안 되는 거 아닌가….\n전체 내용을 읽어 보면, 납득이 가는 내용이지만, 아무리 그래도 저건 좀 너무 그 레토릭에서 스스로 감동해 버려서 오버한 거 같다.\n그런데 한국 사회에서는 이런 것이 유행이거나, 그런 서사를 차용하려는 기업이나 사람들이 많은 것 같다. 내가 볼 때는 그러지 않아도 좋고, \u0026#34;돈이 필요하고 먹고 살려니 장사를 하려고 합니다.\u0026#34; 같아도 무슨 문제가 있을까 싶다.\n실제로 착하다는 것이 뭔지도 모르고 착한 척만 너무 많은 것은 아닐까 싶었다. 내가 감히 착하다 아니다 평가를 하는게 나 같은 사람이 하는 게 웃기는 일이지만.\n사회적인 압력인 것 같다.\n착한 가게, 착한 기업, 착한 회사, 착한 직원 등등등이 그렇게도 많은데 나는 솔직히 정말 한국에서 왜 그렇게 그게 또 드물다고 말하며 팍팍하고 인간미 없는 사회 분위기만 뉴스에서 소문에서, 또 내 체감으로 보고 듣고 느끼게만 되는 것일까 신기하다.\n그런 존재가 되어서 외부에서라도 인정을 끌어오고 싶은 것 같다. 그리고 남에게도 그런 것을 강요하고. 심지어 자신들이 착하다고 모임의식을 스스로 짓고 그 선 밖에 있는 사람들을 나쁘다고, 다르다고 말하면서 스스로 아무런 변화도 노력도 없이 착해지는 기적을 매일 같이 일으킨다. 그리고 그 선 밖에 나가야 하는 희생양인 연예인이나 도덕성, 적합성 논란의 대상에 세워진 사람들은 벼랑 끝으로 등을 찔리며 밀려만 나간다. 정작 제대로 검증하고 생각해봤어야 할 사람은 단지 어떻게 나이 많고 위대한 국부의 영애에게 버릇 없이 새파랗게 젊은 것이 저러느냐며 단지 그런 이유로 감정적으로 정치적인 판단을 내려놓고 그걸 핑계랍시고 말하는 것이 부끄럽지 않은 정도인 것 같다.\n흥미롭던 연장선은, 과거 광우병과 관련된 촛불시위가 주목을 받지 못하자 다 쓸모 없는 것이라고 편향된 인터넷 커뮤니티로 돌아서던 사람들과 또 어떤 해외의 유명한 학교를 졸업한 연예인의 학적을 밝혀야 정의가 바로 선다고 하며 자신들이 독립투사와 같은 부류라고 말하던 웃기는 이야기들을 기억한다.\n지금도 서로 반대라고 생각하는 정당의 누군가를 공격하거나 끌어내리고 흠집을 내고 싶을 때 그렇게도 매번 똑같이 그런 시시비비를 걸어댄다. 사실일 수도 있고 아닐 수도 있겠지만 나는 그냥 그 부분에는 관심을 갖지 않는 게 더 낫지 않나 싶어졌다. 어차피 그런 이야기를 하는 쪽을 보면 더 조용히 묻힌 그런 이야기들이 현재 진행형일테고 하물며 그게 진위인지 알기 어려운 단면만을 보여주는 것들을 믿고 어쩌면 무고한 사람을 비난하고 미워하고 그런 것을 문제로 들고 온 이들이 바라마지 않는대로 미움을 증폭시키는데 내 시간을 허비하고 싶지 않기 때문이다. 어떤 이들에게는 그런 일들이 너무나 중요하고 정의를 위해서라고 말하고 싶을 것 같다만 말이다.\n오히려 자기 스스로 공정함이나 정의, 올바름을 말하는 이들을 더 경계하고 쉽게 남의 일면을 단죄하려는 이들을 더 조심해야 한다. 왜냐하면 그렇게 간편하게 canned된 정의로움의 기분에 취하는 것을 즐기고 있는 이일 가능성이 높으니까 말이다.\n그래서 청년, 형님, 오빠, 아저씨, 삼촌, 이모 등등은 물론이고 양심, 정의, 공정, 행복 등등도 판다는 가게들은 무섭다. 그런 것은 좀 안 팔았으면 좋겠다.\n왜들 그렇게 싸고 맛있고 몸에 좋은 음식집을 찾아 헤매이는 걸까. 싼데 맛있을리가 없지 않나. 혹은 싸고 몸에는 별로 안 좋지만 맛있을 수는 있을지 몰라도, 아니면 싸고 몸에는 좋은데 맛은 더럽게 없는 경우 정도만 가능하지 않을까. 도둑놈 심뽀가 아니면 뭘까. 가게 주인이 자기 등골이라도 친환경 에너지로 빡쎄게 72시간 동안 푸욱 우려낸 사골국물이라도 내오길 바라는게 아니면 뭘까 싶다. 하지만 그런 간판이나 광고나 다름 없는 티브이 음식 탐방기들.\n차라리 나는 맛은 정말 좋고 값은 싼 재료로 만들고, 몸에는 정말 별로인, 그런 \u0026#34;양심 없는 맛\u0026#34;을 추구하는 음식집을 하라고 하면 잘 할 수 있을 것 같다. 혼자 요리해 먹던 식으로만 하면 될 것 같다. 김치보다 돼지고기가 더 많이 들어가서 국물의 맨 윗 층이 돼지기름으로 한 겹인 feat. 독일 슈퍼마켙 김치찌게나 그와 비슷한 너무 무식하게 두터운 소고기 깍뚝썰기 덩어리들과 허브에 졸인 아기감자가 너무 무식하게 굴러다니는 미역국과 소고기가 들어간 덕분에 힌두인은 고개를 저을 카레(역시 독일 식재료 물가 featuring) 등은 미친 듯이 만들어 낼 수 있을 것 같다.\n연예인들이 선행을 하는 모습을 보고 있으면 나는 너무 슬프다. 돈이 썩어나고 착한 척을 돈으로 사려고 저러는 거라는 이야기를 하지만, 그럴지도 모르지만… 그냥 어떤 이들은 얼마나 사람들에게 괴롭힘을 당했길래 세상이 조금은 정상적인 곳이 되기를 의식적으로든 무의식적으로든 바래서 저렇게 아둥바둥 좋은 세상을 위해서 해야 하는걸까 싶은 기분이 들어서다. 세상에 가장 쓸모 없는 걱정 중에 하나라고는 하지만, 그렇게 괜한 사람을 몰아세우고 괴롭히고 망가뜨리는 것들을 보아오고 나서 그런 생각을 갖게 되었다. 그리고 그래서 이제는 괜히 그런 곳에 끼고 싶지도 않아졌다. 나중이라도 그 사람이 무고했고 오히려 좋은 이였고 나도 단지 내가 착하고 정의로운 사람이 된 것인 양 쉽게 말하고 하면서 일조했다는 후회를 하고 싶지는 않다.\n물론 나는 욕을 더 해주고 싶은 불쌍한 이들이 마음 속에 한 가득이다. 연예인들이나 정치인 자식들 말고도 우리 주변에도 얼마든지 많지 않은가…. 정의를 멀리서 찾지 말자. 거울을 보자. :-)\nFootnotes 1 아주 가끔은 내가 그런 사람인 적도 있고, 또는 다른 사람이 그럴 때도 있는데, 자신을 변명하고 설명하기 위해서, 혹은 과잉친절을 하면서 말을 계속 걸고 집중을 방해하고 집중의 의미나 이유를 이해 못하는 사람들도 종종 있지만. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-10oct/ping-04sun/","title": "🦾 Ping 04/Oct/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 연휴 이전에는 이런 저런 사람들을 만나고 이야기를 나눌 기회가 많았다. 그러면서 대부분 흔하게 느끼고 생각한 것은 사람들은 자신의 머릿 속에 이미 만남 이전부터 만들어놓은 상상에 있는 누군가를 만나고, 실제로는 나를 만나서 이야기를 나눈 사람들은 극히 드물었던 것 같다.\n물론 그 이전에도 마찬가지였다. 어떤 사람들은 같이 생활하고 일하거나 하며 지내는 경우에도 그렇게 살아가며, 자기 자신의 이미지에 대해서도 너무 현실과 괴리가 커서 문제를 일으키는 사람들도 보았다.\n누구나 직접 누군가나 어떤 상황을 마주하는 것이 아니라 이미지와 각자가 이해하고 수용할 수 있는 정도로 살아가겠지만 그 정도가 너무 심한 경우를 본다.\n심지어 주어진 상황과 설명, 이야기는 듣지도 않고 자기 환상적인 이미지를 혼자 이야기하며, 그 불쾌한 이야기를 떠벌리며, 딱히 유치한 감정놀이 이외엔 별 이익도 보이지 않는 헛짓을 하며 시간을 뺏거나, 별로 똑똑하다고 하기는 어려운, 그리고 그다지 이익을 추가하는 것도 아닌데 적당한 이익으로 착각하는 것에 빠져서 삽질을 하는 것도 자주 보게 된다.\n그나마도 그냥 별 숨은 의도나 그런 것 없이 이유를 말해주고, 그냥 제안이나 상황을 설명해줘도, 거기에 어떤 함정이 있거나 거짓말일거라 믿고 오히려 더 이상한 일들을 벌이는 경우들을 너무 많이 본 것 같다.\n별로 의도했거나, 의도하지 않았건 그냥 적당히 그들이 적당히 좋아할만한 이야기나 이유를 만들어 쥐어주면 오히려 너무 행복하게 그걸 받아들이고 하는 것들도 보면서, 아 이 사람은 이 정도인 사람이고 겨우 저정도 욕심을 조금도 내려놓지 못하며 지내고 있구나 싶었다. 그게 그렇게 유용해 보이지도 않는데도.\n결국 상황에 대한 인식과 그를 자신의 다음 행동으로 이어지는 사고를 제대로 못하는 경우들이었다. 아마도 가장 자신이 믿고 싶은대로만 자기 사고를 내버려두도록 계속해서 살아왔기 때문일 것이다.\n답답하고 어이도 없고, 또 한편으로는 그런 이는 아마 내 능력으로는 어쩔 수 없는 것일테니 싶다. 그런 세계 속에서 평생을 살아가는 것을 상상해보면 그런 마음이 든다. 마음이 이상하게도 쓸쓸해진다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-26sat/","title": "🥼 Ping 26/Sep/2020",
     
     "tags": ["ping", "programming", "novel", "book", "books", "kino", "film", "movie"],
     
 "description": "",
 "contents": " 영화, 소설, ..심지어 프로그래밍언어나 사람, idea을 접할 때 어떤 것들은 그 자체로 화려해보이고 천재적이라는 것을 느낄 수 있을지도 모른다.\n프로그래밍언어이나 기술, idea에 대해서는 오히려 그렇게 직관적으로 결론을 내리기 어려울 것 같다.\n영화와 같은 표현은 그런 것을 만날 수 있을거라고 쉽게 오해하는 것 같다. 단지 바라보는 것만으로 명작임을 느낄 수 있을거라고 말이다. 그리고 그렇기 때문에 자신의 입맛을 만족시키는 그것이, 또는 그것만이 명작일 것이라고 오해하기 쉽다.\n그런데 그렇지 않은 경우를 많이 본다. 영화만을 한정지어서도 그것을 이해하기 위해서 더 많은 주변을 둘러보고 그 자체를 깊게 살펴보고 생각해야 하는 경우. 그렇게 바라본 다음에야 그 영화가 영화라는 매체로서 표현될 수 밖에 없는 이야기와 방식을 너무 적절하게 사용했음을 알아챈다. 그리고 그런 것을 나는 명작이라고 생각한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-23wed/","title": "🛞 Ping 23/Sep/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 이제서야 유한하다는 것을 더욱 깊이 생각해본다. 그리고 얼마나 달콤한 행복을 살아가는지 깨닫는다. 매일 매일이 별 것 없지만 그대로 너무나 내게는 행복하다.\n언젠가 내 마지막을 맞이하면 모든 것들이, 나만이 마음 속에 간직한 이 많은 감정과 기쁨들 모두 그대로 담아둔 채 떠나야겠지만 그게 모두의 다들 똑같을 것만 같다. 그렇게 억울하지는 않아졌다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-17thu/","title": "🧴 Ping 17/Sep/2020",
     
     "tags": ["ping", "kino", "film", "movie", "tv", "90s", "coffee", "calling-you", "jevetta-steele"],
     
 "description": "“Calling You” / 바그다드카페 그자체의 기억을 부르는 시그널뮤직",
 "contents": " 영화 \u0026#39;바그다드 카페\u0026#39;를 어릴 때에는 \u0026#39;주말의 명화\u0026#39; 정도에서 다 번역/더빙된, 그리고 아마 편집에 엄청나게 많이 짤려나갔을 버젼으로 봤었던거 같은데 아무것도 기억에 남아있지 않았었다.\n심지어 이번에 다시 디렉터스컷으로 구해서 보면서 내가 기억에 남아 있던 것들은 완전 다른 영화인 것 같았다. 그렇게 기억만큼 어둡지도 않았고 오히려 너무 밝아서 오글거렸다. 아마도 좋은 오글거림이지만.\n기억에는 그렇게 남은 이미지는 브라운관 화면과 더빙 품질 등도 한 몫 했을 것 같다.\n실은 영어를 어떻게 쓰는지, 처음 단어별로 끊어서 이야기 하는 시점(時 ─)과 그 이후에 사람 이름을 어떻게 발음 하는 것(야스민/재스민 등) 억양과 발음, 단어 등등 듣고 있으면서 시간이 흘러감에 따라서 변화하는 것을 봐야 하는 영화인데 더빙이었다면 어떻게 표현했을지 난감할 것 같다.1\n1987~1988년 영화로 알고 있는데, 그 사이 90년대에는 인류에게 대체 무슨 일이 있었을까 생각도 해보게 되는 영화였다. 저때는 어쩌면 저렇게 다양한 인종과 언어를 마구 섞어서 영화를 찍어놓고, 여행을 하며 다른 사람과 문화를 알고 이해해가는 과정을 행복하게 찍었었는데 그 이후에 내가 접한 헐리웃 영화들은 얼마나 비슷한 이야기를 얼마나 부산을 떨며 그리는지 싶기도 했다. 그나마 최근의 \u0026#39;조조래빗\u0026#39;과 \u0026#39;그랜드부다페스트호텔\u0026#39;에서는 덜 그렇고 그 말과 문화를 조금이라도 안다면 소소하게 더 보이는 영화여서 좋았었다.\n코로나 이전에는 오전에 아주 일찍 혼자 극장에 가서 영화를 보고 나오는 나 혼자 조조감상이 너무 좋았었는데 요즘엔 그러지도 못하는 것 같아서 서운하다.\n[EDIT] 2026-01Jan : “Calling You” / Jevetta Steele Footnotes 1 커피에 대한 미국과 독일의 선호 차이도 마찬가지로 표현된다. …어차피 에스프레소 머신이든 적당한 캡슐커피든 뭐든 커피는 집이든 회사에서 얼마든지 마시니까 몰랐었는데 그때 나도 커피 중독이 심했었던 것 같다. 그것도 점점점 진하게 선호가 변해갔다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-16wed/","title": "🛻 Ping 16/Sep/2020",
     
     "tags": ["ping", "programming"],
     
 "description": "",
 "contents": " 그간 작업해오던 일이 있어서 과분하게 고마운 제안, 이미 익숙한 사람들과, 거기에 훌륭한 이들과 멋진 일을 함께 하자는 제안들을 거절을 하며 손해를 보며 살고 있었다.\n그리고 그 일은 마무리를 짓고 다시 또 이야기들을 하고 들으며 돌아다녔다. 그리고 생각보다 훨씬 체력소모가 컸었던 것 같다.\n글쓰기, 코딩하기 지난 기간 동안 해온 작업을 마무리지었고, 앞으로는 다른 일에 매진해야 할 것 같다. 하지만 그럼에도 가능하면 너무 흐름을 잃지 않고 글을 꾸준히 쓰고 공개하지 않더라도 깃헙에 올리며 살아가야겠다. 하루에 생활과 일, 그리고 그 주변을 위한 시간씀씀이를 생각해보면 15분, 20분 정도나 가능할까. 체력과 정신적인 여유도 어렵겠지만. 남에게 보여줄 것은 못되더라도 꾸준히, 지난 달들처럼 열심히는 할 수 없지만 계속해서 쌓아가고 흐름을 잃지 않도록 노력하자. 그냥 그래야 내 자신을 위해 하루 모퉁이를 할애해야지 삶에 다른 부분들도 더 기대하며 매일을 지내는 것 같아서다.\n매일 무언가 내가 내 삶을 알차게 보내지 못한 것만 같아서 잠자리에서 뭔가 아쉬운 마음에 더 다른 생각을 하지 않고 그냥 만족스럽게 내일을 열도록 할 수 있을 것 같다.\n다 다른 사람들이지만 이상하게도, 흔히 말하는 \u0026#34;감정 없이 기브 앤 테이크\u0026#34;이라고 말하는 것이 실은 상대를 동등한 협력자로서 존중하는 것에서 시작하기 위한 좋은 첫 시작일 수 있는 것 같다. 가장 감정이 없을 것 같지만, 명확하게 서로의 이해관계만을 놓고 이야기 하는 것이 역설적이게도 가장 인간적인 것 같다.1 어쨌든 협력이 일어나고 그 방식이 가장 협력하는 특징을 가진 존재인 인간으로서 맞는 방향일 것 같다. 상대를 존중하지 않기 시작한다면 협력은 발전은 커녕 지속되기도 어려울테니 언뜻 보기보다 훨씬 인간적일 수 밖에 없지 않을까.\n사회생활을 하다보면 어떤 사람들은 경제적 존재나 행위라고 한다면 소시오패스처럼 행동하는 것을 가장 이득이라고 생각하고, 그 자신도 은연중에 그렇게 살아야 한다는 식으로 믿고 행동하는 것처럼 보일때가 있다. 그런데 그런 경우엔 또 한편으로는 그 자신은 인간적 가치를 중시한다고 말한다. 혼란스럽다. 그리고 오히려 소시오패스라면 미디어에서 조장하고 그려내는 모습과는 현실에서의 성취는 다를 것 같다. 소시오패스라면 자기가 획득한 장난칠 대상이 있는 작은 틀 안에서 만족할 것 같다. 굳이 협력을 하며 더 성취를 할 필요가 없을 것이다.2\n혹은 반대로 협업과 팀웍 등등을 강조하며 인격이나 도덕성 검증은 그런 면에서 시작도 못하게 되는게 항상인 것 같다.\n감정적인 공감을 기반으로 하고 싶다는 것이 정말로 협력을 얻어내기 위한 것인지, 아니면 쉽게 여러모로 쉬운 대상을 찾고 있다는 이야기를 왜 그렇게 하는 것인지 알기 어려울 때도 많다. 그렇지 않은가. 부끄러움을 나이를 훔친만큼 내다버린 사람들이, 아니면 앞으로 그런 면에서 큰 성과가 기대되는 또래가 흔히 그렇게 표현하는 것이 나는 듣기에 민망할 때가 있다.\n슬프게도 우리는 신성한 존재를 만나도 아마 알아보지 못할 것 같다. 아니면 이미 여러번 그랬었을 것 같다. 나는 그저 나 같은 사람만을 알아보고 이해할 수 있겠지 싶다. 그럼에도 그런 신성하고도 도덕적으로 무결한 존재를 원한다며 자신에게 있을 수도 있는 협력을 얻어내기는 커녕 …한 것은 어떻게 설명해야 할지 모르겠다.\n이번에 알게 된 사람들은 그런 경험들과는 또 달랐던 것 같다. 알게 되어서 하루를, 함께 할 수도 있었을 시간을 상상해보는 것으로 행복하게 해주는 이들도 있었다. 그냥 케잌이 맛있었기를 바란다. 그리고 그런 가치를 이해하는 이들이라면 함께 만나 시간을 보냈었다고 하더라도 시간이 흘러 얻은 어떠한 결과에도 별 후회는 없이 함께 보낸 시간을 이야기할 수 있을 것 같은 이들을 만났었다. 그리고 굳이 내가 아니더라도 지금 그들이 세상에 드러내 보인 것이 그들 자신이 그렇기 때문에 당연히 얻어진 것이었음을 이해할 수 있었다.\nFootnotes 1 물론 서로에게 매칭이 일어나 교환이 일어난다면. 일방적으로 이해관계에 따른 권력관계로 강요가 일어나는 것을 말하는 것이 아니다.\n2 https://en.wikipedia.org/wiki/Amartya_Sen 이 분이 이에 대해서 잘 설명해주셨다는 것 같다. 줏어 들었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-14mon/","title": "⛸️ Ping 14/Sep/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 작년 말, 올해 초만해도, 그때 내가 사람들과 이야기를 하며 기본소득에 대한 지지를 이야기하면 반응은 시원찮았었다. 자신이 초능력자라고 말하는 예전 대선에 도전했었던 어느 사람에 비유하며 웃었었고 나는 그런 반응들이 못마땅했었다.\n또는 나는 나 자신이 못 가진 자라고 생각해서 은근히 더 공정하고 분배에 집중한 사회가 되기를 바랬었다. 왜냐하면 내가 더 안정적이고 피곤할 일들, 혹은 감정적으로도 시달리며 살기는 이미 지친 것 같아서다. 그런 일들을 감내하게 만드는 것은 경제적 이유였었고 더한 모습들이 우리 사회에서는 결국 돈 때문일테니까라고 생각해서였다.\n그런 것들이 이루어진다면 다들 행복하고 더 잘 살게 되지 않을까 이야기를 꺼내지도 못하고 막연히 생각해온 것 같다.\n그런데 어느 새로운 정당에서 나오는 공약들을 보고 있자면 처음에는 당혹스럽고 사람들의 의견을 반영한 것일까 생각했다. 그리고 그래도 세상은 잘 굴러가는건가 생각했다.\n그러다가 무서운 생각이 들었다. 저쪽에서도 저렇게 이야기를 해서 그게 어떻게 이루어지건 아니건 사람들의 마음을 얻고 싶을 정도로 다들 불안한 상황일까 싶었다. 아마도 저 정당의 고정표, 혹은 그간의 분위기는 분배가 초점이라고 하기는 어렵지 않았나 싶은데도 저럴 것이라면.\n혹은 더 무섭게 비약한 상상도 해본다. 그런 상황이 계속 악화될거라는 이야기들, 그리고 크게 나아질 가능성을 찾아보기 어려운 것들을 생각하면 우리나라도 그런 경제적인 시점이 찾아와서 편향되고 극단적인 방향으로 쏠려가도록 하는 첫 번째 단계일거 같아 보여서다. 아이러니하게도 그런 정책에 대해서는 항상 포퓰리즘인 것으로 지적해오던 정당이지만 말이다.\n스스로 불만을 이야기하고 민주주의를 회복한 시민의 힘이 정말 모든 상황에서 좋게만 작용할지는 모르겠다. 자기 자신이 맞다고 믿고만 싶은 때에, 현실적인 이유를 정당화해줄 수 있다면 그런 가속을 낼 수 있는게 항상 좋게만 작용할지, 아니면 더 무섭게 달려나갈지 걱정스럽다. 내가 걱정한다고 뭐가 되는 것도 아니겠지만 그런 상황을 상상하면 무서워서다.\n그리고 만일 마지못해서, 지금처럼 살아가는 체계를 더 이상은 유지할 수 없어 너무 제한적인 것을 지혜롭게 분배해야 하는 상황이 와서 복지와 안전망을, 그 표준을 낮춰서라도 구축, 운용해야 하는 상황이라면.. 나는 반가워할지 자문해보면 많은 것들이 원치 않는 방향으로, 내 자유나 지금 유지하고 싶은 삶의 부분 부분을 포기해야 할 것만 같아 싫을 것 같다.\n난 실은 그것들이 언제, 어떤 모습으로 이루어질지는 생각하지 않고 그저 그런 일들이 일어난다면 모두에게 좋은 일이 아닐까 막연하게 멍청하게 바랬었던거 같다. 지금 시점에서 모두가 그런 변화를 진지하게 고민해야 하는 정도라면 그런 것들이 이뤄진다고 하더라도 마지못한, 더 나은 상황으로이라고 하기는 어려울 것 같다. 아주 오래 지나서 그런 것들이 정착되고 더 나은 시점이 올거라면 그때에도 정착되어 꿈꾸던 것들처럼 남아있다면 좋겠지만 당장은 그렇지 못할 것 같아서다.\n어쩌면 그런 시점이 오는 것이 바람직하다고 말했었던게 아니라 그렇게까지 되지 않았으면 바래서, 그래서 지금 상황에서 조금이라도 그렇게까지 되지 않기를 누군가 말해준 것을 나는 잘 알지도 못해서 오해했었던거 같다.\n세상에서 제일 쓸데 없는 걱정 중 하나를 해봤다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/ping-12sat/","title": "❄️ Ping 12/Sep/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 어떤 개념에 대해 너무도 미신적인 관점을 가진 사람들을 너무 흔하게 본다. 하지만 그들이 생각하는 것은 그렇게 믿고 싶어서 선택한 신화적인 모습이라 더 이상하다. 경험에 기반한 성숙함이 다르기 때문이다.\n하지만 그들이 믿고 싶은 것과 현실은 정반대일수밖에 없다. 그리고 내가 경험한 바에 따라서도 실제로도 항상 예외를 찾지 못하도록 그렇다.\n다만 세상을 보는 시각이 아직은 어둡기 때문이거나, 마치 그것이 진실인 양 주장하고 싶은 이이기 때문이리라.\n어느쪽이건 좋은 일이 있든 힘이 들든 진심으로 축하하고 위로를 할 방법도 알지 못하거나, 마지 못해 해야하는 상황에서도 그 방법도 의도도 모두 혼탁해 함께 하면 괴로울 따름이다. 그들이 딱지붙이기를 하고 싶은 이들이 오히려 비교할 수 없이 인간적이고, 존중과 존경을 받을만한 인격을 갖추고 있다.\n그런 딱지붙이기를 하는 이들이야 말로 그 행동 자체로서 실은 그 사람이 어느 정도인지를 드러낸다. 그런 행동을 하는 이가 인간적이라고 어떤 측면에서 말할 수 있을지는 잘 모르겠다. 다만 그 측면이 아폴론적인 영광된 모습도, 디오니소스적인 유쾌한 모습도 아닌 그 어떤 면으로도 바람직하다고 하기는 절대 어려운 모습이리라 싶다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-09sep/perspective-on-python/","title": "🪗 Python에 대한 내 관점",
     
     "tags": ["python", "lisp", "fp", "oop", "c++", "zero-overhead", "language-construct", "pythonic", "programming"],
     
 "description": "",
 "contents": " Python은 조금 지루한 문법의 언어다. 거기에 매크로 같은 기능도 없어서 항상 평이한 문장을 작성하게 되는 것 같다.\n하지만 다른 비슷한 언어들과는 다르게, 파이썬 문장 자체는 깔끔하면서도 density가 높다. 리습, 하스켈 같은 언어들으로 작성한 것을 생각해봐도 밀도가 높아 표현력이 좋다.\nJava와 같은 언어는 밀도도 낮고 표현력도 가끔은 너무 아쉽다.\n파이썬이 이렇게 밀도가 높을 수 있는 이유는, 언어 자체적으로 매크로를 지원하거나 해서 문법을 확장하는 방법을 채택하는 것이 아니라 SymPy에서 그랬었던 것처럼 값을 계속 쌓아갈 수 있게 만들고 연산자를 재정의해서 문장이 다르게 해석되도록 만드는 방법이고, 이쪽이 더 Pythonic한 방법 같다.\n그리고 그렇기 위해서 언어에 내장된 construct들이 꽤 유연하고 일관성 있는 방법으로 재사용될 수 있게 설계되어 있기 때문이라고 생각한다.\n과거로부터 C++의 천재적인 generic programming, STL의 아이디어랑 비슷한 모습이기도 한 것 같다. C++의 그런 점들은 과거에는 비아냥의 대상이었던 것 같다. 하지만 지금에 와서야 돌아보면, 함수형이니 객체지향이니 더 bloated된 객체를 설계하게 만들고 더 느리고 무거운 결과 코드를 만들도록 하는 방법들을 더 낫다고 생각했었던 것 같다. 하지만 내 생각엔 C++의 의도와 목적을 그런 사람들은 오해했었던 것 같다. 최근에 Rust에서 오버헤드 없이 컴파일 하기 위한 STL, generic programming 같은 것들을 그대로 가져와 사용하는 것을 보며 이제서야 조금은 이해를 해나가는 것 같다.\n그런 Python의 construct은 with 문, for 같은 것들인 것 같다. 그리고 많은 부분에서 with 은 재밌게 응용할 부분이 많다. 마치 Lisp계열에서 let, flet, macrolet 이나 anaphoric macro 처럼 만들수도 있을 것 같다.\n내 경우에는 다음과 같은 부분에 썼었었다:\nDB 트랜잭션 처리: 예외가 발생하는지에 따라서 commit/rollback. DB등 Connection Pool: Connection을 얻고 다시 put-back하는 처리. Stopwatch: 애플리케이션의 특정 코드 영역의 실행시간을 측정, 누적-통계. 매크로와 같이 그 내용 블럭의 평가/실행을 조절하거나 새로운 바인딩을 만들지는 못할 것 같다. 그럼에도 iterator, generator와 같이 일관된 방법으로, 또 아주 간단하게 언어의 의미를 확장할 수 있는 방법인 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-31mon/","title": "🪿 Ping 31/Aug/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 여름이 끝나가는 느낌이다. 또 무더워지는 날이 며칠 있겠지만 지금은 가을이 온 것만 같은 밤공기와 풀냄새가 향긋하다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-30sun/","title": "🛟 Ping 30/Aug/2020",
     
     "tags": ["ping", "proj-a"],
     
 "description": "",
 "contents": " 프로젝트 마무리 문서도 초안을 다 썼고, 마무리 중.\n분산 커밋로그에 저장하고 읽는 것들을 aync. io을 이용해서 실행되도록 하고 있다. 처음엔 그냥 C라이브러리 기반으로 된 blocking 버젼으로 만족스러울 정도로 빠른 커밋로그라 그럭저럭 괜찮았는데 한개의 실제 사이클인 것처럼 줄일 수 있어서.\n또 그냥 failure을 처리하는 부분을 바꾸고, 전체 애플리케이션을 특정시점에 더 실제 실행시점처럼 흉내내서 동작하도록 만들 수 있게 했다.\n마무리도 마지막 검증이랑 마쳐가고 있고. 8월도 마무리 되어간다. 시간이 빠르다.\nEDIT 모두 완료! 클라이언트 애플리케이션, 문서, 만족스러운 검증 등등 원하는 것들을 다 완료했다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-28fri/","title": "🔹 Ping 28/Aug/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 날씨가 덥고 습하다. 거기에 마스크까지 해야해서 내가 좋아하는 오래걷기를 하기에 그다지 좋은 시절은 아니다.\n문득 생각이 들었다. 아주 얼마 전까지만해도 이런 상황을 대부분의 자기 자신이 정상이라고 믿고 싶어하는 이들은 모두가 이렇게 살아가는 세상을 이야기를 들으면 비웃었을 것이다. 그리고 실제로 그런 일들을 많이 보아온 것 같다. 방독면이나 산소마스크 방호복 대신에 KF94 마스크일뿐인.\n많은 아이디어와 예견들이 맞아들어가는 시절이다. 한편으로는 그런 것을 이해하고 세상의 변화에 대해서 조금은 알맞게 나 자신이 알아채고 살아온 것이 뿌듯하면서도 꼭 달갑지는 않기도 하다.\n어쩌면 어떤 이는 여전히 근대적인 사고 방식으로, 현대의 사고방식과는 약간은 동떨어지게 살아가며 실제로는 오히려 자기가 믿는 자신과는 다르게 세계와 접하는 것은 아닐까.\n뉴스와 사람들. 그런 사고방식의 차이, 살아가는 시대가 같은 시간을 살아가는 것처럼 보이지만 실제로는 다른 시대에 속한 사고구조를 가진 다른 사람들이 대립하는 것을 보며 생각한다.\n그리고 그렇기 때문에 사람들은 매번 그렇게도 동일한 도덕성 검증이나 사사건건의 꼬투리를 찾아내며 기뻐하는 것 같다. 그리고 그런 사람들을 잘 알아서인지, 아니면 그런 자신도 그렇기 때문인지 그런 것들을 이용해 누군가를 공격하거나 하는 이들도 지치지도 않는 사회인 것 같다. 정작 아이디어나 그런 것들에 대해서는 이해하려고 하지도 않는 것 같다.\n그런 도덕성, 적합성 등등의 이야기들은 사실 그렇게 그런 유명인에게 들이대기 유치할 때도 많고, 그저 도덕이니 올바른 사회니 하면서 몰려가 특정한 사람에게 린치를 가하는 것이나 다름 없는, 그런 야만일텐데 그것을 정의나 도덕으로 여기고 싶어하는 이들이 너무 많다. 그래서 매년 그런 것에 책임을 질 이유도 없는 이들이 세상을 등지게 만들면서도 자신들은 도덕적이고 정의로운 사회를 원한다고 말한다. 어쩌면 그런 다른 시대를 함께 같은 시공간을 공유하며 살아가는 사람들이 따르는 도덕의 계보가 서로 다르기 때문일지도 모르겟다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/linux-5.8-and-tp-link-archer-t2u-plus-rtl8821au/","title": "🏩 Linux 5.8와 TP-Link Archer T2U Plus (RTL8821AU)",
     
     "tags": ["linux", "kernel", "5.8", "usb", "wifi", "driver"],
     
 "description": "",
 "contents": " arch-desktop의 커널을 무심코 5.8으로 pacman -Syu 했다가 낭패였다.\nUSB무선랜이 잡히지 않았다. 그래서 하는 수 없이, FB워크스테이션을 쓰다가 또 라즈베리파이3에 FB에 달아놓은 realtek USB 무선랜을 붙이고 유선을 통해 dnsmasq으로 연결해서 고쳐나갔다.\n정말 커널 5.8에서 빌드가 잘 되지는 않았다. 그나마 https://github.com/aircrack-ng/rtl8812au 이 드라이버가 살렸다.\n1 2 # lsusb Bus 002 Device 009: ID 2357:0120 TP-Link Archer T2U PLUS [RTL8821AU] 그것도 DKMS으로 빌드하면 안되고 그냥 make install 해서 동작하게 되었다. 다행이었다. 그리고 나서 나중에도 로딩하도록 /etc/module-load /etc/modules-load.d/rtlusb.conf 에 88XXau 라인을 넣고 저장.\nRPi을 그냥 이참에 라우터로 만들어버릴까 싶기도 하다. 방에서 무선랜을 각 기계마다 잡아주는 것도 이젠 귀찮기도 해서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-27thu/","title": "➰ Ping 27/Aug/2020",
     
     "tags": ["ping", "proj-a"],
     
 "description": "",
 "contents": " 그간 진행해오던 프로젝트는 성능에 대해서 premature optimization을 고려해서 만들기 보다는 architectural한 면에 비중을 갖고 가능성을 염두에두고 선택을 해오며 만들었다.\n그럼에도 꽤 괜찮은 성능이었었고, 이제는 첫번째 버젼의 완성과 문서 작성도 완료한 시점이어서 앞으로 성능을 높일 방안을 고민해보고 실험을 몇개 수행해서 방법 결정해봤다.\n(현재 사용하는 방법과 새로이 사용할 방안의 이름은 모두 변경했다.)\n기존 성능 측정은:\nX event-writer\ncommit을 한번에 하지 않고, 매 이벤트마다 수행해서 느림. (현재는 변경되었음) 약 11,196-microseconds (11-ms) X journal-writer\n2615-microseconds / 2.6-milliseconds 로직 처리\n0.000613-microseconds 정도 처리 속도. (0.6 milliseconds) 합계 : (milliseconds 단위)\n11 + 2.6 + 0.6 = 14.2 새로운 안은:\nevent-writer\nY / Z ZZ ZZZ ZZZZZZ. 3-microseconds –\u0026gt; 0.003 milliseconds. journal-writer\nQQQ 3-microseconds –\u0026gt; 0.003 milliseconds. 로직처리 (그대로)\n0.000613-microseconds 정도 처리 속도. (0.6 milliseconds) 합계 : (밀리초 단위)\n0.6 + 2 * 0.003 = 0.6 + 0.006 = 0.606 14.2 (개선전) / 0.606 (개선후) = 23.432343234323433 정도 개선됨.\nTx/Sec 단위로 환산하면, 개선전 : 약 70 Tx/Sec. 개선후 : 약 1650 Tx/Sec. 만족스럽다. 당장 방안을 적용할 것은 없고, 지금도 사실 1개 트랜잭션에 14.2밀리초 정도만 걸리는 것이므로 상대적으로 다른 트랜잭션을 일으키는 것들에 비해면 빠른 것이겠지만.\n새로운 방안이 확실한 방법으로 훨씬 더 빠르고 많은 트랜잭션을 수용할 수 있을 수 있고, 조금만 더 작업하면 전환이 가능해서 마음이 편안하다.\nAssuming you are using a normal harddisk (i.e. no ssd) you can expect a maximum of 50-100 writes per second. It seems that 15 writes per second is slightly low, but not impossible.\nSo if Postgres is doing 1500 updates per second they are either written to some buffer/cache or collapsed into a single update. Without knowing more about the actual test it is difficult to say which is the actual reason but if you were to open a transaction, update a single row 1500 times and commit after that than Postgres should be smart enough to only execute a single \u0026#34;real\u0026#34; write to the disk.\n- https://stackoverflow.com/a/19136265/3309907\n어느 정도 빠른 설정의 RDBMS의 트랜잭션 갯수에 간단히 근접하게 되었다.\n그리고 이정도 개선 접근법도 더 빠른 컴파일러를 통한 최적화를 적용하지 않은 상태에서의 결과라 그런 최적화도 적용한다면 폭은 훨씬 더 커질 것이므로 즐겁다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-25tue/","title": "🍰 Ping 25/Aug/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " the end of the belle époque?\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-24mon/","title": "⏪ Ping 24/Aug/2020",
     
     "tags": ["ping", "proj-a", "games", "doom64", "doom", "gaming"],
     
 "description": "",
 "contents": " \u0026#34;프로젝트\u0026#34; 진행해온 프로젝트의 문서를 작성 중.\n문서를 작성하면서 더 보충/보강할 내용들이 튀어나온다.\n이 또한 사실 즐겁다.\n게임하기 Doom64 리메이크를 클리어했다. 마지막 레벨에서는 도저히 깰 수 없어서 그냥 마지막 한 마리를 잡기 위해서 치트를 켜서 아쉽다. 하지만 그 마지막 보스 이전에 타이드는 그냥 제정신으로 다 죽여서 재밌었다.\n다음 게임은 퀘이크 시리즈를 다시 플레이할까 생각 중. 폴아웃4, 스카이림을 다시 로드해서 플레이를 하며 그 세계에서 시간을 보내도 좋겠지만 조금은 다른 게임을 하고 싶어서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping2-14fri/","title": "🚐 Ping (2nd) 14/Aug/2020",
     
     "tags": ["ping", "proj-a"],
     
 "description": "",
 "contents": " ㅎㅎ좋다. 이제 문서와 추가적인 작은 도구 몇 개를 더 만드는 것만 남았구나.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-14fri/","title": "🤼 Ping 14/Aug/2020",
     
     "tags": ["ping", "meson", "c++", "build", "autotools", "cmake", "sdl", "sdlhan", "configure", "wrap", "wrapdb", "scons", "rake", "rakefile", "makefile", "programming"],
     
 "description": "",
 "contents": " 빌드도구의 경험과 Meson을 사용하기 Meson-ABC 갖고 놀아본 코드\n아주 예전에 commercially 성공적이었었던 C++ 프로젝트를 홀로 기획, 설계, 개발했었었다.\n처음에는 GNU Makefile으로 간단히 시작했었었다. 타겟 플랫폼이 뻔하게 윈도였기 때문이다.\n그 이전에는 ANSI C으로 작성한 SDL 조합형 비트맵 출력 오픈소스 라이브러리 같은 것들을 작업할 때는 그냥 GNU Autotools 을 쓰거나 했었었다.\n하지만 그렇게 configure 하거나 할 부분도 없고 처음 혼자 시작하며 다른 신경 쓸 것도 무지하게 많았었던 프로젝트였고 더욱이 기간도 한정적이었었다.1\n그리고 SCons 같은 것을 조금 쓰다가, 결국 더 간단히 Rake으로 빌드를 작성해 한동안 썼었다.\n어차피 루비 스크립트였기 때문에 자유도도 높고 Configure 같은 기능들도 그냥 스크립트으로 작성해버리면 그만이었을테니까.\n그러다가 몇 년 정도 그 프로젝트가 성장하고 하면서 CMake으로 빌드를 다시 작성하고 재밌는 경험이었었다. 처음 CMake을 배워서 진지하게 적용했었었다.\n그 이후로 C++을 할 일은 별로 없었지만 개인적으로 작성할 때마다 CMake은 좋은 도구였다. 그리고 Conan, CPM, ExternalProject 같은 외부 의존성을 가져오고 빌드하는 등의 확장들도 많아서 C/C++ 특유의 문화를 살리면서 프로젝트를 만들어가기 좋은 것 같았다.\n하지만 잡다한 부분도 많고 튜링완전하기 때문에 자유롭지만 이상한 부분도 있었었다. 정신을 조금 차려보면 이해하기 어려운 cmake 스크립트가 쌓여가는 것을 볼 수 있었었다. 어차피 빌드스크립트야 어느 시점이 넘어가면 그런 것들을 먹고 가주는 역할이 필요하기는 하지만 가끔은 너무 번거로운 것은 아닌가 싶었다.\n그에 비해서 Meson을 익히고, 작은 프로젝트를 납득할만한 수준으로 작성하면서 만들어봤다. 딱 좋은 도구라는 생각이 들었다.\nWrapDB 같은 것을 통해서 기존에 Meson으로 작성되지 않은 프로젝트들도 의존성으로 쉽게 사용할 수 있고 일관된 방법으로 의존성들을 간단히 관리하는 것이 좋았다.\n특히 \u0026#34;Modern CMake\u0026#34; 혹은 \u0026#34;CMake Best Practices\u0026#34; 같은 것들이 이야기하고 빌다시피하며 지켜주길 바라는 것들을 그냥 자연스럽게 그 자체로서 구현해놓아서 굳이 그걸 깨뜨릴 이유가 없는 시스템이어서 좋았다.\n그리고 제한적이지만 원하는 configure 같은 것들을 다 수용할만한 정도여서 고민되지는 않았다.\n다른 언어들을 쓰면서 cargo, go get 같은 것들이 부럽기도 하고 했지만 C/C++은 그 나름을 유지하면서 이런 좋은 도구들이 실은 알아가면 더 즐겁게 해주는 것 같다.\n그리고 내가 좋아하는 방식으로 일하고 쌓아가는데 적합한 도구가 되어서 좋다. 다른 최근에 적용한 도구 중에 이렇게 프로젝트를 관리하는 방식이 나는 좋은 것 같다.\nFootnotes 1 Adobe Flex와 Guice/Java/EMC 등등을 다 맡아서 하고 있었었다. 다른 동료들도 같이 일했었었지만. 그리고 실제 동작하는 것으로 만들기까지 처음에는 C#/.NET으로 작업한 것을 다시 작성하고 하는데 사흘 정도만에 완성했었었다. Installer와 Updater까지 포함해서는 조금 더 시간을 보냈었다. 그래도 어떻게 그랬었는지 지금의 나로서도 의아하다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-13thu/","title": "➰ Ping 13/Aug/2020",
     
     "tags": ["ping", "freebsd", "emacs", "radio", "fm"],
     
 "description": "",
 "contents": " 프비 워크스테이션을 만들어놓고 그렇게 좋은 사양은 절대 아닌 조용한 슬림PC에서, 또 가능한 마우스를 안 써도 좋게 세팅해놓고 편안하게 이맥스에서 작업을 해나간다.\nFM라디오의 가끔 지글거리는 잡음도 좋은 것 같다.\n계속해서 신경을 쓰게 만들고 끊기고 광고가 나오고 또 클릭을 유도하고 멍청하게 징징거리는 것으로 돈으로 바꾸는 요즘의 수많은 다른 매체들보다 훨씬 나를 편안하게 만든다.\n다른 매체들도 비슷하지 않을까. SNS도 그런 것 같고 대부분의 앱, 심지어 운영체제도 그런 환경들과는 다른.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping2-01sat/","title": "🌤️ Ping (2nd) 01/Aug/2020",
     
     "tags": ["ping", "crypto", "p2p", "blockchain", "computation"],
     
 "description": "",
 "contents": " 지난번 포스팅에서 이야기한 것처럼, 인연이 있던 창업자가 새로 창업한 회사에 제안이 있었었다. 더 없이 아쉬운 기회이고 미안했지만 내가 하고 있던 일을 계속하고 싶어서 아쉬운 기회이지만 거절했다. 내 능력에 벅찬 일일 것이고, 또 내게 손해가 있겠지만 내가 결심한바대로 해나가는 것이 내게는 맞는 일이란 생각이다.\n이미 당시에 한국에서 유명한 기업으로부터 창업한지 얼마 되지도 않아 투자를 잘 받고, 안정적으로 성장할 준비를 하고 있었다.\n그 키워드의 기술을 당시에 연구하고 공개한 MS 이외에도 IBM에서도 오픈소스로 작업한 툴킷을 공개하고 실용적인 단계에서 활용이 가능한 형태로 공유를 시작했다.\n내 생각엔 보안과 Privacy의 유출을 원천적으로 걱정할 필요 없이 데이터에 대한 연산을 적용할 수 있게 되어서, 데이터에 기반한 딥러닝이나 스마트컨트랙트의 실행, 블록체인 상에서의 분산된 자원을 공유하는 방식의 컴퓨팅1 을 더 현실적이고 실용적으로 만들 것 같다.\n이런 변화들을 내 세계관 속에서 이해하고 그것이 가끔씩 맞아들어갈 때에 너무 흥미롭고 즐겁다. 그리고 무엇을 익히고 무엇을 해야할지를 더 깊이 이해해간다.\nFootnotes 1 https://www.researchgate.net/publication/278048301_Enigma_Decentralized_Computation_Platform_with_Guaranteed_Privacy 이런 것들.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-08aug/ping-01sat/","title": "🎬 Ping 01/Aug/2020",
     
     "tags": ["ping", "emacs", "vim", "evil", "vi"],
     
 "description": "",
 "contents": " 오랬만에 내 환경을 더 다듬었다.\nEmacs, Evil, General.el. 매일 이맥스에서 코딩을 하면서 조금은 Vim보다 키바인딩이 편집에 불리한 것 같았었다. 그렇다고 Vim을 쓰고 싶지는 않았다. 검색이나 다중편집 같은 이맥스만의 기능을 Vim에서 흉내내는 것은 별로 마음에 차지 않는 정도이고 또 화면 flickering도 이맥스 GUI을 쓸 때보다 터미널 Vim은 심해서 난 피곤해.\n그래서 Evil-mode을 종종 썼는데 문제는 내가 만들어놓은 general.el 키바인딩들이 Evil을 고려하지 않고 만들어서 evil모드를 toggle하며 써야했었었다. 특히 내 이맥스 모드에서의 키바인딩의 prefix이 C-z인데, evil-mode에서는 emacs mode으로 전환을 위해서 사용.\n조금 멍청한 elisp 매크로를 작성해서 문제를 풀었다. 동일한 바인딩을 C-z(이맥스), SPC(Evil)에서 각각 다른 Prefix으로 같은 키들을 쓸 수 있도록 했다. 만족스럽게 동작하는 것 같다. 그리고 Spacemacs, Doomemacs등도 이렇게 prefix을 사용하니까.\n또 capslock이 control key으로서 변경되기 이전에 내가 종종 캡스락을 눌러서, 또 그렇게 캡스락이 toggled on된 다음에 다시 끌 방법이 없어 (대문자만 입력되니까) 짜증나는 경우가 있어서 강제로 스크립트으로 토글해 끄는 것을 작성했다. 쉘에서 대소문자 무시하고 tab completion으로 이 스크립트를 실행은 할 수 있을테니까.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-07jul/ping-24fri/","title": "🍱 Ping 24/Jul/2020",
     
     "tags": ["ping", "games", "summer", "doom64", "ion-fury", "quake", "fps"],
     
 "description": "",
 "contents": " 여름방학을 보내고 왔다. 지난 한달여, 꽤 즐겁게 보낸 것 같다. 그리고 순수하고 맑은 마음으로 행복했었던 것 같다.\n하늘도 여름 같이 맑고 파랗고 공기도 좋았었다. 매일 열심히 집중해서 일할 수 있었고 좋았다.\n그리고 그렇기 때문에 조금은 아련하다. 이런 느낌.\n(기쿠지로의 여름 OST) Summer / 히사이시 조\nhttps://youtu.be/_t1KvFMUNws Games: Doom 64, Ion Fury. Doom 64을 플레이. 클래식 둠, 둠2이랑은 또 완전히 다른 게임이었음. 몬스터들 모델링, 음악, 레벨디자인 모두 완전히 새로 만들어서 재밌었다. 그리고 꽤 다른 분위기라서 플레이하기 좋았다.\n모든 레벨을 다 클리어하지는 못했는데, 그냥 퍼즐을 풀듯이 맵을 하나씩 클리어하는 재미가 좋다.\n그리고 몇달동안 세이브 파일 그대로 멈춰있던 Retro FPS인 Ion Fury도 다시 잡고 게임을 하고 싶을 때 맵을 하나씩 클리어. 둠64이 생존하기 어려우면서도 어두운 던젼 안에서 퍼즐을 풀어나가는 느낌이면, 이온퓨리는 듀크뉴켐3d스러운 유머와 대사, 아이템들을 갖고 쏟아져 나오는 적들을 처리하는게 재밌다. 물론 둠64도 웨이브를 견뎌내고 하는 재미가 있지만 좀 분위기와 웨이브의 강도가 좀 다른 것 같다.\n물론 어둡고 흥미로운 던젼을 풀어나가는 분위기는 Quake I이 가장 좋았었던 것 같다. (물론 Steam에 소장하고 있..)\n베데스다의 둠, 둠 이터널도 언젠가는 플레이하겠지만, 딱히 급하게 하고 싶은 생각이 없다. 둠이터널을 플레이하는게 기대는 많이 되지만.\n툼레이더도 쌓아놓고 아직 플레이하지 않고 있고, 그냥 시간이 날 때 가끔 하나씩 설치하고 플레이를 하려고 한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-07jul/ping-19sun/","title": "🧔‍♂️ Ping 19/Jul/2020",
     
     "tags": ["ping", "ps4", "burnout", "burnout-paradise", "racing", "gaming", "gtx-1060", "1q84", "novel", "haruki-murakami", "book", "books", "reading", "directors", "kino", "film", "movie", "kindle"],
     
 "description": "",
 "contents": " 쉬는 날. 그간 4개월 정도 집중해온 작업이 어느 정도 궤도에 올라갔다. 앞으로도 더 많은 작업을 해야겠다.\n하지만 일요일이고, 오늘 하루는 조금 마무리 작업을 해놓고 휴식을 할까 마음 먹었다.\n1Q84, 하루키 소설 영문판 읽기 군생활을 할 때 시간을 쪼개서 영문판 책들을 많이 읽었었다. 진중문고와 그밖에 휴가를 다녀온 사람들이 놓고간, 세월이 흘러가며 쌓여있는 아무도 읽지 않는 좋은 책들을 많이 읽었었던 것 같다.\n그중에는 아직도 다시 읽고 싶은 책들과 좋아하는 작가와 철학자들이 많이 생겼었던 것 같다.\n내 선택은 주로 현대의 SF소설들을 직접 구매해서 읽거나 알베르 카뮈나 에리히 프롬이었던 것 같다.\n그리고 한국어판 상실의 시대와 영문판 해변의 카프카 같은 소설들도 정말 빠져들어 미친듯이 읽었었다.\n당시에는 읽기 부드럽다는 생각을 별로하지 못했었는데 그냥 하루키 소설 영문판은 읽는 이상한 재미가 있다고 생각한다. 번역이 좋기 때문일까 아니면 그 문체에 내가 익숙하기 때문일까.\n킨들에서 5~6년 전에 읽던 1Q84을 다시 시작했다. 그냥 조금씩 음미하며 깊이 읽어나가며 즐겁다.\n영화와 감독들 최근에는 감독이 좋아지면 그 감독의 영화들을 찾아본다. 최근에 다시 찾아본 감독으로는 쿠엔틴 타란티노와 웨스 앤더슨, 그리고 드니 빌뇌브.\n셋 다 각각 다른 취향의 각자의 색이 너무 좋다.\n번아웃 파라다이스, PS4와 GTX-1060 예전에 회사 동료에게 선물로 받은 GTX-1060으로 번아웃 파라다이스를 오랬만에 열심히 플레이했다.\n그 이전에 1060이 아닐 때에도 PC에서도 하던 게임이었었고, 최근에 휴식할 때 플스4에서도 플레이하는 게임.\n그런데 플스4에서는 어쩐지 내가 둔한가 생각하고 있었는데, 좋은 GPU으로 다시 플레이하니까 그렇지 않고 단순하게 디스플레이의 부드러움이 차이나기 때문에 제대로 플레이를 못했었다는걸 깨달았다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-07jul/ping-17fri/","title": "👕 Ping 17/Jul/2020",
     
     "tags": ["ping", "programming", "github"],
     
 "description": "",
 "contents": " GitHub \u0026#34;Arctic Code Vault Contributor\u0026#34;이 되었다. [[file:/posts/images/2020-07jul/gh-arctic-code-vault-contributor.png ]]\n우연히 기여한 몇몇 프로젝트들이 보관되기로 결정됐나보다.\n2020년의 코딩. 중간에 비는 부분들이 있지만. ㅎㅎ 공개한 오픈소스 저장소도 2~3개이고, 가장 많은 비중을 차지하는 것은 비공개로 진행하고 있는 저장소 1개.\n기간으로 봐도 3~4개월이 되어간다.\n검증 가능하게 꼼꼼히 만들면서 성취감이 크다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-07jul/ping-08wed/","title": "🍻 Ping 08/Jul/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 배워가기 올 한해의 절반이 지나갔다. 그리고 중요한 시점에 정말 좋은 결정을 내렸던 것 같다.\n생각과 관점이 더 발전하고 그에 따라 삶도 더 변화해갔다. 어떤 것들을 거쳐서 어떻게 변화했는지는 쓰고 싶지는 않다. 그리고 어째서 인터넷에 그런 글들이 생각보다 잘 없는지 이제는 조금 이해할 수 있어서 굳이 쓸 생각도 없다.\n너무 당연한 원인, 행동 그리고 결과의 연결이라 만족스럽다. 앞으로의 삶을 바라보는 관점도 많이 변했고 더 없이 행복하다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-06jun/ping-29mon/","title": "🧄 Ping 29/Jun/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 이해하기 읽고 생각하고, 글을 쓰고 살아온 방법과 길에 대해서, 만난 이들과의 일화들에 대한 이해가 더욱 깊어진 것 같다. 그리고 내가 내린 판단과 결정이 만족스러운 것이었었다. 더욱 명확한 기분이다.\n하던 생각들이, 꽤 정확하게 파악했었더라, 그를 기반해 예측한 것이 맞는 것을 알게 될 때면 더욱 만족스러운 기분이 든다. 훌륭한 이들, 존경스러운 이도 있고, 한편으로는 말을 꺼내기도 한심해질 정도의 이도 있다. 정말 안타까운 느낌이다.\n정말 시간은 위대하다는 생각을 한다. 내가 시간의 역할을 욕심내어서는 안되겠다는 생각도 한다. "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-06jun/ping-16tue/","title": "🛑 Ping 16/Jun/2020",
     
     "tags": ["ping", "freebsd", "linux"],
     
 "description": "",
 "contents": " FreeBSD을 조금 오래된 컴퓨터에 계속 사용하기. 매일 업무를 보는데에 메인 피씨, 랩탑은 여전히 아치리눅스를 잘 쓰고 있다. 그리고 조금 사양이 부족한 사이드킥 피씨 본체에는 FreeBSD을 여전히 설치해놓고 쓰고 있다.\n처음 생각보다 훨씬 더 많이 활용하게 되는 것 같다. 그리고 훨씬 가볍게, 안정적이고 강력한 느낌이다. 물론 오히려 리눅스가 더 빠르다거나 안정적인 부분들을 금새 발견할 수 있다. 그리고 리눅스와 동일하게 쓰려고 들지 않는게 더 속편한 부분도 많다.\n예를 들어, 당연히 Steam 같은 것은 기대를 안한다. 그리고 의외로 USB스택은 리눅스에 비해서 종종 실망스럽고, 다양한 파일시스템 지원도 그렇다. FUSE을 통해서 리눅스처럼 다양한 파일시스템을 지원하지만 그렇게 안심하고 쓸만한 것은 아닌 것 같다. (몇 개의 경험을 해보고 나니)\n그런데 어차피 리눅스는 또 있고 굳이 리눅스에서 되는 기능을 동일하게 바랄 필요는 없다. 그리고 대칭적인 관점을 고집부리며 비교를 하는 것은 어떤 다른 것을 제대로 평가하지 못하게 만드는 좋은 이유가 된다.\n나열하면 놀랄 정도인 나쁜 사양의 피씨를, 또 나열하면 놀랄 정도로까지 다양하게 활용하면서도, 매일 많은 시간을 쾌적하게 사용하는 것 같다.\n아마 앞으로도 이 피씨를 사용하는 동안은 계속해서 이 피씨는 BSD을 사용할 것 같다. 그리고 그 이후에도 비슷한 설정으로, 비슷한 정도의 피씨를 메인 데스크탑, 랩탑과 함께 이렇게 사용하는 것이 편안하다.\n어떤 비밀들 어떤 이들을 만나고 이야기를 나누면 놀라게 되는 사람들이 있다. 저런 관점과 생각을 어떻게 얻었을까 싶은 사람. 때론 정반대인 사람들을 마주치기도 하지만.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-06jun/ping-06sat/","title": "😔 Ping 06/Jun/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 조금 더 혼자 진행해오던 일을 계속하기로 결정했다. 좋은 사람들과 스타트업임을 알고 있고, 이전에 함께 일하면서도 인격적으로나 능력적으로 모두 훌륭한 사람들임을 잘 알고 있다.\n그럼에도 나 자신이 이번엔 더 차이를 만들어야겠다고 결심했던 것을 끝까지 해나가고 싶어서다. 합류하면 정말 많은 부분 이득이 많겠지만, 개인적으로도 많이 힘든 고민을 하고 결정을 내렸다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-05may/editors/","title": "⏯️ 코드 편집기에 대한 생각",
     
     "tags": ["editor", "text-editor", "tools", "gw-basic", "basic", "msdos", "ms-dos", "powerbasic", "turbo-basic", "power-basic", "bgi", "borland", "p-code", "pcode", "visual-basic", "vb6", "quickbasic", "vi", "vim", "jed", "edit.com", "turbo-c", "view-mode.el", "vc6", "visual-c++", "delphi", "ultra-edit", "php4", "php", "flex3", "eclipse", "eclipse-jdt", "maven", "notepad++", "lua", "c++", "cxx", "gvim", "intellij", "idea", "undo-tree.el", "kill-ring", "hydra", "general.el", "micro-editor"],
     
 "description": "",
 "contents": " 코드 편집기를 어떻게 써왔었는지 잠깐 생각해봤다:\nDOS시절: MS-DOS Editor.\nGW-BASIC 시절에는 정말 https://en.wikipedia.org/wiki/MS-DOS_Editor 을 열심히 썼었던 것 같다. 그리고 그 다음엔 PowerBASIC for DOS 열심히 썼었다. QuickBASIC 같은 바이트코드으로 컴파일해서 .exe 파일에 인터프리터와 바이트코드를 embedding 하는 VB의 P-code 같은 가짜 컴파일 방식1이 아니라 정말 네이티브 코드로 컴파일해주고, 인라인 어셈블리와 메모리 조작이 가능한 베이직 컴파일러, IDE여서 좋은 환경이었던 것 같다. 터보C 2.0 편집기. PowerBASIC이랑 유사해서 익숙하게 쓸 수 있었던 것 같다. 파워베이직도 그렇지만, 의외로 도스시절의 이런 IDE들이 F1 - Help 메뉴에서 항목별로 문서 정리가 잘 되어 있어서 읽으면서 즐거웠었던 것 같다. (초등학생~중학생이어서 영어를 잘 이해하지는 못했지만)\nBGI 같은 특유의 그래픽 라이브러리 등을 재밌게 갖고 놀기 좋았었다. 리눅스 처음 입문 시절.\nJED 을 열심히 썼었다. 도스의 EDIT이나 터보씨 유사한 UI이고 도움말 등을 통해서 필요한 키를 익히기 충분했었던 것 같다.\n지금도 다시 쓰라면 쓸 수 있을 것 같다. 크게 부족한 점이 없는 것 같다. Vi/Vim : 그냥 어디에나 깔려있고 해서 그냥 적당히 배워서 고통스럽게 썼었던 것 같다. Emacs : 제대로 내게 맞춰서 설정하는 방법 등은 모르고 그냥 썼었던 것 같다. 당시에는 큰 용량인 텍스트 파일도 잘 열 수 있고 view-mode이나 bookmark 등의 기능이 큰 텍스트 파일을 읽는데 좋아서, 또 X윈도에서 한글을 깔끔하게 잘 처리해줘서 텍본 소설을 읽는데 오래 썼었던 것 같다. 혼자 코딩하는 학생시절 ~ 쥬니어 개발자. (군입대 전)\nVisual C++ 6 : 딱히 엄청나게 좋지도, 그런데 묘하게 나쁜 구석도 딱히 없는 편집기였었다. 그리고 이런 편집기가 IDE에 붙어 있는게 좋다고 생각한다. Delphi 5 : 의외로 코딩을 많이 하는데 썼던 환경인 것 같다. VC++6와 마찬가지로 오랬동안 코딩을 하는데 나쁘지 않은 환경이었던 것 같다. Emacs : 웹프로그래밍, 파이썬, 루비, 펄, PHP4을 익힐 때 많이 썼었던 것 같다. 재밌었다. 여전히 설정을 제대로 할 줄 몰랐었던 것 같다. UltraEdit : PHP4 알바를 하고 하면서 동료가 쓰고 있어서 같이 썼었던 것 같다. 당시에 FTP을 통해서 파일을 편집하거나 수직 편집 등이 가능해서 열심히 썼었던 것 같다. 군 제대후 ~ 현재.\nEclipse JDT : 자바, Adobe Flex 때문에 많이 썼었다. 점점 메모리를 차지하는게 많아지고, Maven plugin 등이 안정적이지 않아서 직접 가볍게 세팅해서 사용했었었다. Vim : Adobe FlexBuilder이 Eclipse 기반인데 너무 끔찍하게 느려서 그냥 Apache Ant 빌드 파일을 만들고, Vim으로 Adobe Flex 코딩을 하면서 빌드를 따로하며 썼었던 것 같다. 이외에 업무상 필요한 C++이나 Java 코딩도 계속해서 Vim으로 했다. 처음에는 최소한의 내게 적당한 설정만 적용하다가 점점 정교한 설정을 해나갔었던 것 같다. Notepad++ : 어느샌가 윈도 환경에서 작업할 일이 있을 때, C++/Lua 등을 작업할 일이 있을 때, 윈도용 GVim이 마음에 안 들 때 사용했었었다. 의외로 깔끔하고 가볍고, (아무런 설정 없이) 그냥 만족스럽게 동작해서 많이 사용했었다. 특히 내 컴퓨터가 아니라 급하게 코드를 보거나 해야할 파견이나 트러블슈팅을 위해 파일을 열어봐야 했었던 시절에 많이 사용했다. 오픈소스여서 설치하는데 부담도 없었으니까. IntelliJ : 자바를 더 많이, 복잡한 것들을 짜게 되면서 이클립스JDT에서 넘어와 사용했다. 꽤 깔끔하고 키보드만으로 자유롭게 쓰기 좋았다. 특히 자바를 많이 쓰는 회사에서 일할 때는 너무 편안했다. Emacs : 진지하게 설정해서 사용. 이후 Perl, Python, Node.js, CommonLisp, Java, Go, C++ 작업을 할 때 계속 사용한 것 같다. 그 이후로 계속해서 기본 환경으로 사용하고 있다. evil-mode을 이용해서 반복적인 타이핑이 필요할 때 Vi처럼 사용하고, 내가 원하는 작업 방식을 위해서 Ripgrep연동, Projectile, editable-grep, multiple-cursors 등등 필요한 모든 기능들이 내게 맞춰져서 설정을 만들어놓았다. 그리고 앞으로도 계속 사용할 것 같다. 코딩 이외에 일기를 쓰거나 생각을 정리 하는데에도 사용해서 그냥 거의 계속 사용한다.\nUI 측면에서도 단축키를 기본적인 것 이외에는 대부분은 자동으로 그 다음 단계를 제시해주도록 만들어놓아서 크게 학습이 필요 없었다. undo-tree이나 kill-ring 같은 것들도 다른 편집기에서는 찾아보기 어렵게 편안해서 이젠 오히려 Vim을 사용하면 어색하고 답답하다. Hydra, general.el 같은 것들을 사용해서 원하는 기능들을 내게 맞춰서 모아놓아서 편안하다. 요즘엔 결국 이맥스에 정착한지 10여년 정도 되는 것 같다. 그러면서도 계속 인텔리J, Vim을 같이 사용해왔었었다. Vim은 여전히 익숙하고 설정을 계속 갱신하고 있지만, 요즘엔 종종 오랬동안 써야 하는 코딩 세션에서는 이맥스보다 역시 불편해졌다는 느낌을 받는다. 이맥스는 아예 evil-mode도 그렇고 대부분의 상황에서 완전히 익숙한데 비해서 Vi/Vim은 점점 제한적이라는 것을 느껴간다.\n최근에는 재미로, Micro Editor 을 익혀보려고 했는데, 재밌기는 했지만 몸에 베인 Vim이나 이맥스의 키들이랑 너무 엊갈려서 쓸 수 없었다.\n이맥스는 사람들의 생각이랑 다르게 emacslisp을 조금 익숙하게 다루기 시작한다면 그냥 쓸만한 편집기 같다. 어차피 편집기를 어느 정도 세팅하기 시작하면, 이맥스의 키코드를 외우거나 할 필요도 없어지고 그냥 다음 단계에 어떤 키가 무슨 역할을 하는지 알려주는 패키지도 많고, 그런 패키지를 이용해서 spacemacs, doomemacs 같은 배포판도 있어서. (무거워서 나는 별로 좋아하지 않지만)\nFootnotes 1 https://en.wikipedia.org/wiki/Microsoft_P-Code\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-05may/ping-28thu/","title": "🔡 Ping 28/May/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 5월, 요즘은 매일이 날씨와 공기가 아름답다.\n지금처럼 참 행복하게 지내기 좋은 계절인 것 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-05may/ping-23sat/","title": "🐭 Ping 23/May/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 지난 2달여간 매일 같이 몰입해 매진한 작업의 성능 테스트를 진행했다. 그리고 매 시점마다 테스트와 측정 결과에서 놀라던 것과 마찬가지 포인트에서 많은 관점이 변화한다. 아직도 많은 일을 더 해나가야겠지만 그래도 지금은 이 정도에서 우선은 만족스럽다.\n작년과 재작년, 그 이전에는 매 일터마다 배울 점들이 있었던 것 같다. 그리고 지난 포스팅에도 말했듯이 내 많은 관점들을 발전시켜준 좋은 사람들과 멋진 경험들을 했었던 것 같다.\n다만 올해 잠시 조인했었던 곳에서는 정반대의 경험이었었다. 많은, 이미 알고 있는 것들을 다시 확인했는데 그것들은 나 자신으로부터 배운 것들과 타산지석의 가르침들이었었다.\n최근에는 어떤 새로운 스타트업에 초기 단계에 조인을 고려하고 있다. 지난 주에 만나 이야기를 한 이전 직장의 동료들이 시작한 회사. 이 회사는 보기 드물 정도로 아주 성공적으로 시작을 이뤄낸 것 같고 그 이후에도 너무나 많은 장점과 쉽게 따라잡히기 절대 어려운 점들이 보인다.\n대화, 투자, 그리고 아이템에 대해서 상상해 보는 일 등이, 올해 초의 그 경험과 지금의 스타트업은 너무나 많은 것들이 완전히 정반대로 대비되어 흥미로운 요즘이다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-05may/ping-18mon/","title": "♏ Ping 18/May/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 오랬만에 예전 직접 같이 일한 것은 아니지만, 같은 회사에서 일하던 사람을 만나 오래 이야기를 나눴다. 많은 이야기를 해준 덕분에 재미있는 이야기들을 많이 알게 됐다.\n누군가를 만나고 아주 조금이라도 시간을 함께 하면 언제나 놀랍다. 나 자신을 변화시키는 경험을 하게 해주는 이였다. 아주 짧은 단편적인 일화들만을 경험해도 그렇게 해주는 이를 만나 이야기를 나누는 것은 감사하다.\n지나간 사람들과 시간들을 최근에 생각해보며 어떤 사람들이 어떻게 내 생각에 영향을 주었는지를 보았다. 그리고 감사한 이들이 많이 떠올랐다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-04apr/void-linux/","title": "🤖 Void Linux + Runit으로 데스크탑/랩탑 환경 설정하기",
     
     "tags": ["void-linux", "linux", "runit", "elogind", "dbus", "ssh-askpass", "gnugp", "zzz", "acpid"],
     
 "description": "",
 "contents": " 지난 한 달여간 눈코 뜰새 없이 바쁘게 지냈었다. 그렇게 지내다가 오랬만에 툭닥거려봤다.\n재미로 Void Linux을 설치해봤다. 사실 설치해보고 한적은 꽤 됐고, 메모리 사용량이 훨씬 가볍고 빠른 성능 때문에, Arch Linux도 충분히 가볍고 좋지만, 제대로 설정해서 사양이 좋지 않은 랩탑, 데스크탑들을 위해서 쓰기로 생각하고 있었었다.\n2007년 정도에 Gentoo Linux으로 회사 데스크탑과 Oracle DBMS 서버를 재밌게 설정한 이후로, 오랬만에 정말 가벼운 리눅스 배포판을 설치하는 느낌이었다.\n아치리눅스는 Pacman, Makepkg, AUR 같은 것들도 체계가 잘 잡혀있고, 오히려 Portage 보다 잘 관리되고 괜찮지 않은가 싶기도 할 때가 많아서 굳이 Gentoo을 다시 쓸 일은 없을 것 같다. 그리고 FreeBSD의 Ports도 좋지만, AUR에 비해서 포함하는 패키지, 업데이트 빈도가 다른 느낌이다. 사실 AUR이 정말 빈도가 높은 편이라 그렇겠지. FreeBSD Ports도 정말 열심히 업데이트 되지만.\n그리고 아치리눅스에서 (이제는 익숙해져서, 또 정리가 잘 되어 있고 탄탄해서 systemd을 나는 좋아한다) systemd이랑은 다른 runit을 쓰는 정말 가볍게(아무 것도 없는거 아닌가 싶을 정도의 느낌으로) 부팅 되는 것이 재밌었다.\n여전히 메인 데스크탑과 랩탑의 main driver으로는 Archlinux 그냥 잘 쓸 것 같다. 하지만 RAM이 조금 작은 사이드킥에는 그냥 Void Linux을 깔아놓고 쓰려고 한다.\n그런데 몇 가지 설정이 어려운 점들이 있었었다.\nGnome Keyring + SSH-agent 으로 동작하게 만들기. ACPI Suspend/Hibernate 에서 풀려났을 때 xscreensaver으로 화면 잠금이 지원 안되었음. (랩탑 키보드의) \u0026#34;Power\u0026#34;버튼이 \u0026#34;실수로\u0026#34; 눌렸을 때 즉시 꺼지지 않도록 설정을 바꾸기. Gnome-Keyring + SSH. dbus 설정이 기본으로 되어 있지 않았었다.\nsystemd에서는 기본으로 적용되어 있는 설정이니까. elogind을 설치했다: xbps-install elogind polkit-elogind dbus-elogind dbus-elogind-x11 dbus, elogind, polkitd 을 시스템 서비스으로 시작한다\nln -s /etc/sv/{dbus, elogind, polkitd} /var/service 가능하면 재부팅하거나 기존 dbus 서비스를 재시작한다: `sudo sv restart dbus~\n…왜냐하면 dbus-elogind-* 들으로 기존에 동작하고 있던 dbus들을 바꿔쳤으니까. 이렇게 해서 얻는 것들은: (systemd이 자동으로 elogind으로 해주던 것들.)\n/run/user/*/* 디렉토리의 로그인 사용자의 D-Bus 파이프 파일 등등. XDG_* 같은 환경 변수들. …위의 것들이 제대로 설정되어 있어야 D-Bus을 쓰는 Gnome-Keyring \u0026lt;-\u0026gt; Gnome-Keyring-Daemon이 잘 동작하겠지. Gnome-Keyring-Daemon 시작 시 D-Bus 환경을 적용.\n기존에는 eval $(gnome-keyring-daemon --start ...) 처럼 직접 시작했다면, eval $(dbus-launch gnome-keyring-daemon --start ...)\n이렇게 dbus-launcher 으로 감싸서 관련된 환경변수들이 제대로 설정되어 전달되도록 변경. 끝.\nelogind이 systemd에서는 내장이니 신경 쓸게 없었었다. polkitd, consolekit2(지금은 안 쓰겠지만)등을 신경쓰지 않게 해주던 systemd 고마운 것. ACPI Suspend + XScreenSaver 이것도 elogind 관련.\nhttps://gist.github.com/ryukinix/bd0c1ddcbbafdb4149ae70e41b7c822b 이 스크립트 바꿔서, 스크립트 파일을 작성했다.\n/usr/libexec/elogind/system-sleep/xscreensaver-lock.sh chmod +x ... https://github.com/ageldama/configs/blob/master/void-linux/elogind-sleep-xscreensaver-lock.sh 끝. 잠깐만: sudo zzz or loginctl suspend elogind을 설치하지 않더라도 기본적으로 acpid이 설치되어 있을거고, sudo zzz 커맨드으로 ACPI Suspend 할 수 있다.\n그리고 sudoer에 NOPASSWD으로 등록해서 특정 사용자로는 비밀번호 없이 실행도 가능하다. https://lists.freebsd.org/pipermail/freebsd-questions/2016-April/271312.html sudo 은 물론이고 zzz 도 간단하고 재밌는 커맨드다. 하지만, 이미 로그인 된 데스크탑 사용자를 위해서는 elogind이 자동으로 비밀번호 없이 poweroff, reboot, suspend, hibernate 등을 할 수 있다.\n이것은 또한 흥미로운 커맨드다. man loginctl 해보길. zzz와 xscreensaver와 연동을 위해서는:\n참고: https://github.com/ageldama/configs/blob/master/void-linux/zzz-xscreensaver-lock.sh 키보드의 \u0026#34;POWER\u0026#34; 버튼을 실수로 눌러서 꺼지는 것을 방지하기. https://unix.stackexchange.com/questions/555822/how-to-change-power-button-shutdown-action-to-run-a-script-under-systemd\n파일 경로만 /etc/elogind/logind.conf systemd에서 elogind만 추출해서 쓰는 것이므로. 끝, 소감 리눅스 커널에 마치 BSD 같이1 가벼운 init 시스템, 패키지 시스템. 재밌는 조합이다.\n설치부터 FreeBSD의 그것처럼 단순했다. 그냥 텍스트 기반 메뉴 시스템으로 설치를 주욱 해나가면 되어서 편안했다. 비교대상인 아치리눅스는 모든 것을 커맨드라인에서 설치를 하는 것에 비하면 편안하기는 하다. (어차피 커맨드 몇 개 되지도 않지만)\n그리고 위키나 핸드북은 조금 커뮤니티 크기 때문인지 젠투나 아치리눅스의 문서량에 비해서는 많이 부족하다. 하지만 어차피 같은 컴포넌트를 사용하는 부분들(runit이나 기타 오픈소스들)은 어떤 문서를 봐도 동일하니까 상관은 없는 것 같다.\n그리고 예전에 시도해보았을 때보다 xbps으로 패키지를 받아오는 네트웍 속도가 빨라졌다.\n사실 Void 리눅스를 사이드킥 피씨에 세팅을 해놓고 지금 이 글을 작성하고 있다.\n편견일지 몰라도 뭐가 느린건지 대부분은 눈치채지 못할 것 같던 FreeBSD보다는 조금 더 버벅거리는 것 아닌가 싶기도 하다. (사이드킥 본체의 사양이 정말 낮은 피씨) 원래 Archlinux을 사이드킥에 설치해서 쓰다가 버벅거림이 있어서 FreeBSD으로 넘어가서 만족스럽게 쓰다가 혹시나 Void Linux은 낫지 않을까 했는데, 아마 사이드킥은 FreeBSD으로 다시 설치할 것 같다. ㅎㅎ\nFootnotes 1 https://itsfoss.com/void-linux/ 실제로도 NetBSD 개발자가 시작한 배포판이고.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-04apr/ping-25sat/","title": "🆓 Ping 25/Apr/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 계속해서 글을 쓰기 내용은 없음 * "},
 {
     "permalink": "https://ageldama.github.io/posts/2020-02feb/make-grub2-usb/","title": "🕍 Grub2, Archlinux ISO으로 만능 USB 메모리스틱 만들기",
     
     "tags": ["usbstick", "memstick", "archlinux", "linux", "grub2", "grub", "boot", "rescue"],
     
 "description": "",
 "contents": " 경고 \u0026#34;만능USB\u0026#34;이란 말은 사실 과대광고입니다.\n하지만, 몇 가지 장점이 있는 USB 메모리스틱을 만드는 방법임:\n아치리눅스 설치ISO 이미지으로 부팅 가능한 USB 스틱이면서도, ISO파일의 용량만큼만 USB메모리를 활용하는 것이 아니라,\n용량이 되는만큼 그냥 일반적인 메모리스틱처럼 파일 복사용으로도 쓸 수 있음. 사실 리눅스든 다른 OS의 설치 이미지를 USB메모리에 올리면, 딱 그 설치 이미지만큼만 사용할 수 있게 만들어 버리고, 그나마도 Read-only 상태인 ISO이 되어버리고, 더더욱 나쁘게 다른 추가 파티션을 만들어서 남는 공간을 활용할 수도 없게 만든다. (파티션 이미지가 아니라 디스크이미지인가보다.)\n아치리눅스 설치ISO을 사용하는 이유는 적당히 기본적으로 쓸만한 도구들이 다 들어있고, 무선랜 등 네트웍 설정 등도 쉽게 가능한 설치 이미지이기 때문에. 꼭 아치리눅스를 설치하는 것이 아니래도, 그냥 비상시 하드디스크 파일시스템 복구용으로 쓰기에도 유리하기 때문.\nUSB 준비 당연히 파티셔닝, 포맷을 해서 날려도 괜찮을만한 USB 메모리스틱이 필요함. 과감히 파티션을 설정하고 포맷한다. 파일시스템은 vfat 으로 포맷 한다.\n(리눅스를 쓰고 있다고 전제하고) (내 경우 USB 메모리의 파티션은 sdg1 이었다) mkfs -t vfat /dev/sdg1 다른 파일시스템, NTFS이나 exFAT은 설치이미지의 리눅스 커널이 올라올 때 제대로 마운트를 못한다.\n아마 둘 다 커널에 들어가 있는 FS이 아니라 FUSE등으로 구현되어 있기 때문일 것 같다. 마운트한다.\n여기서는 편의상 /mnt 에. mount -t vfat /dev/sdg1 /mnt 아치리눅스 ISO 이미지를 복사한다.\nmkdir -p /mnt/iso cp archlinux-2014.12.01-dual.iso /mnt/iso\nhttps://www.archlinux.org/download/ Grub을 USB에 설치한다\n참고: https://wiki.archlinux.org/index.php/Multiboot_USB_drive#Installing_GRUB grub-install --target=i386-pc --recheck --boot-directory=/mnt/boot /dev/sdg 이제 이 정도까지만 해도 Grub으로 부팅되는 USB을 만들었다. Grub 설정 + 아치리눅스 설치이미지으로 부팅하기 다음처럼 /mnt/boot/grub/grub.cfg 을 만들어줬다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # path to the partition holding ISO images (using UUID) probe -u $root --set=rootuuid set imgdevpath=\u0026#34;/dev/disk/by-uuid/$rootuuid\u0026#34; # define globally (i.e outside any menuentry) insmod search_fs_uuid search --no-floppy --set=isopart --fs-uuid 123-456 # later use inside each menuentry instead loopback loop ($isopart)$isofile menuentry \u0026#39;[loopback]archlinux-x86_64.iso\u0026#39; { set isofile=\u0026#39;/iso/archlinux-x86_64.iso\u0026#39; loopback loop $isofile linux (loop)/arch/boot/x86_64/vmlinuz img_dev=$imgdevpath img_loop=$isofile earlymodules=loop initrd (loop)/arch/boot/intel_ucode.img (loop)/arch/boot/amd_ucode.img (loop)/arch/boot/x86_64/archiso.img } 위 내용에서 몇 군데 자기 상황에 따라 바꿔줘야한다.\n(1) set isofile=\u0026#39;/iso/archlinux-x86_64.iso\u0026#39; 적당히 다운로드해서 복사한 파일이름으로 바꿔야함.\n(2) search --no-floppy --set=isopart --fs-uuid 123-456 123-456 부분을, 꼭 바꿔줘야함.\nblkid /dev/sdg1 처럼해서 FS UUID을 얻자.\n1 2 3 4 5 # blkid /dev/sdg1 /dev/sdg1: UUID=\u0026#34;7AFD-FE7A\u0026#34; BLOCK_SIZE=\u0026#34;512\u0026#34; TYPE=\u0026#34;vfat\u0026#34; PARTUUID=\u0026#34;1805ce54-01\u0026#34; # 여기에서 `UUID` 부분을 사용한다. # `PARTUUID` 말고. 그래서, search --no-floppy --set=isopart --fs-uuid 7AFD-FE7A 처럼 바꾸자.\n끝 부팅이 아마 잘 될 것임. 그리고 그냥 들고 다니면서 USB메모리로 편하게 쓰기도 좋고, 비상시 복구 디스크로 사용하기도 괜찮은 USB을 하나로 합쳤다.\n아치리눅스 설치 이미지에서 기본적으로 wifi-menu 등 커맨드으로 무선랜을 잡거나, chroot / arch-chroot 등으로 마운트한 하드디스크의 파일시스템으로 chroot해서 사용할 수도 있어서 꽤 유연하고 활용도가 높다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-02feb/ping-22sat/","title": "💡 Ping 22/Feb/2020",
     
     "tags": ["ping", "linux", "refurb", "freebsd"],
     
 "description": "",
 "contents": " 내가 책상을 쓰는 방법, 고물 컴퓨터를 고쳐 쓰기 오래된 피씨 본체를 얻었다. 슬림한 케이스의 삼성 컴퓨터.\n윈도7 설치된 것도 꽤 가볍고 빠르게 정리되어 있었다. 그냥 FreeBSD을 처음에는 설치하려고 하다가, 결국 애플리케이션이나 그냥 적당히 잘 돌아가는, 이맥스 정보만 잘 동작하는 기계면 될 것 같아서 아치리눅스를 설치.\n만족스럽다.\n데스크탑 원래 사용하던 것도 그렇게 엄청나게 좋은 것은 아니지만 만족스러운 사용인데, 문제는 책상 가운데에 모니터랑 키보드를 놓고 쓰면 책을 읽을 자리가 없어져서 항상 키보드 등을 한 켠으로 밀어놓는다.\n그러다가 서브 피씨를 만들고 책상 구석에 놓았다. 책상의 가운데를 여유롭게 비워놓으니 훨씬 마음이 여유롭다.\n그냥 피씨를 켜도 집중되게 램 3기가 짜리 간단한 리눅스 머신에서 할 일만 하게 되고.\n작은 서브 모니터에 그냥 별다른 세팅 없이 가볍게 내가 쓸만한 환경으로 만들어놓은 환경이 예전에, 어릴적에 리눅스를 쓰던 환경이랑 비슷한 이맥스 화면이라 편안하다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-02feb/ping-15sat/","title": "🌓 Ping 15/Feb/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 새벽, 이른 저녁, 풍경과 공기, 일상, 꾸준함 매일 이른 새벽에 깨어나 일정한 방식으로 하루를 보낸다. 만족스럽다.\n매일 매일 조금씩 다른, 하지만 같은 궤도를 걷는다. 그리고 궤도는 조금씩 변해가겠지.\n춥거나 공기가 좋지 않거나. 하지만 그래도 일상은 매일매일이 귀한 시간이다.\n꾸준히 이렇게 살아가면서 행복하다.\n트위스비 에코 매일 일터에서 집에서 메모, 스케치를 하고 글을 쓸 때 만년필을 여전히 쓴다. 결국 계속해서 꾸준히 쓰는 만년필은 라미 사파리와 트위스비 에코.\n라미 사파리는 잉크를 다 쓰고 나면 잘 씻어서 보관을 해둘까 생각하고 있다.\n트위스비 에코를 이제 일년 정도 사용하고 있다. 만족스럽다. 그냥 별다른 신경도 쓸게 없고. 앞으로도 계속해서 적당한 병잉크로 사용할 것 같다.\n바른 기대치, 제대로 된 생각, 잘못된 욕심에 기반하지 않기 어떤 일을 할 때, 어떤 것을 바랄 때, 잘못된 생각, 잘못된 기대를 하지 않는게 좋다는 생각이 든다. 희망과 기대를 갖는 것은 좋지만, 때와 장소, 혹은 주제나 목적, 그 일에 걸맞지 않고, 오히려 아무런 생각이 없이 남들이 말한 그런 것들로만 기대를 해서는 안된다. 그런 것들을 내가 바란다고 착각하면 안된다.\n오히려 너무 당연하고, 확연한 것들을 기대하는게 건강하다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-02feb/ping-09sun/","title": "🍚 Ping 09/Feb/2020",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": " 책: 초난감 기업의 조건 \u0026#39;기계인간\u0026#39;님의 트윗으로 소개를 받았다. 너무 잘 소개를 해주셔서 기대가 많았다. 그리고 기대만큼 재밌는 책이다.\n경영서적, 마케팅, 혹은 자기계발서처럼 무언가 교훈을 얻고 싶어서 읽지는 않는다. 그냥 다른 사람들의 처절한 실패담과 그 아둔함을 보면서 쓰게 웃고 싶을 뿐이다.\n그 사람들이 얼마나 멍청했는지는 잘 모르겠다. 그리고 그걸 비웃고 싶은 것은 아니다. 오히려 사람들이 그런 멍청함을 구현해내는 분위기, 흐름, 예의를 지키느라, 혹은 눈치를 보느라 제대로된 길에 들어서지 못하는 어떤 형태의 인간 사회에 대해 그렇게 냉소하고 싶어지게 만든다.\n책: the linux programming interface 책을 읽기 시작했다. 생각보다 너무 두껍다. 한국어판이 어째서 2부로 나누어져 있는지 알 것 같다.\n그냥 한국어판을 읽으면서 더 원문과 번역문을 서로 고민하고 싶지 않은 책이어서 샀다. 시간을 갖고 조금씩 읽어나가도 만족스러운 책이다.\n오랜지색 리눅스 VT터미널에서 \u0026#34;man 2 execve\u0026#34; Man page을 읽으며 즐겁던 어린시절 같은 기분도 나는 종이책이다.\n봄이 올 것 같다 행복하고 아름다웠던 지난 가을과 긴 겨울이 흘러갔다. 봄이 오는 것 같은 날이다. 한산한 주말 아침에 조조영화를 보러 가고 오는 길의 한산한 서오릉과 고양 스타필드 주변 동네 특유의 공기와 햇살에 내가 좋아하는 음악을 크게 틀고 운전한다.\n새벽 해가 뜨기 전에 직장에 간다. 그리고 해가 지려는 무렵 집으로 향한다. 그 시간의 풍경도 계절이 변함에 따라 함께 변하겠지 싶다. 지금의 차갑고 어느 정도 힘겨운 겨울, 그래서 좋은 새벽과 오후가 또 익숙해지려고 하는데 변하는 것이 아쉽다. 그리고 또 다른 모습, 어떻게 달라질지 기대도 된다.\n평화롭게 계절을 보낸다. 삶을 살아가는 것이 행복하다.\n영화: 조조래빗 주말에 아침에 한산한 극장. 신종 코로나 바이러스 때문에도 한산했다. 처음 시작은 조금 그저 그랬다. 뭘 기대해야 할지 알 수 없는 영화인가 싶었다. 하지만 시간이 흘러가며 내 인생 영화 중 하나라는 것을 알 수 있었다.\n그리고 2회차에 다시 봤다. 그리고 이번에는 아무 생각 없이 왜 이런 장면이 이렇게도 바보 같은 모습으로 여기에 배치되어 있던거지 싶은 장면들이 너무도 소름끼치게 섬뜩하거나 가슴 아픈 장면이었었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-01jan/100days-of/","title": "🌵 100일의 기록",
     
     "tags": ["100days", "changing"],
     
 "description": "",
 "contents": "\n어느 날이었을지, 기록과 기억이 생생하다. 왜인지는 모르겠지만, 그날 새벽부터 앞으로 100일간 시도해보고 싶은게 생겼다.\n그래서 그 당장 시작했다. 그리고 별로 해낸 것도 없는 주제에 당당하게 만족스러운 기분으로 \u0026#34;1일\u0026#34;과 그날 날짜를 필기 노트에 적었다. 그리고 그 다음 날, 또 다음 날.\n그렇게 100일을 채웠다. 매일 나는 행복했다. 고요함, 주변에서 일어나는 일들을 내려놓고 평화로웠다. 그리고 수 많은 것들을 다시 생각하고 무엇보다 생각을 비울 수 있었다. 덕분에 이제는 관점과 행동이 더 많이 변한 것 같다.\n앞으로 여유가 없어진다면, 바빠서 시간이 없고, 체력이 부족해서 계속하기 어려울지도 모르겠다. 그렇기 때문에 언젠가 이번 삶에서 또 다시 이런 100일을 살 수 있을까 생각해봤다. 참으로 행운이었다.\n\u0026#34;100일\u0026#34;이 되던 날, 그냥 덤덤했다. 그 가운데에 있었던 수 많은 감정, 사건들, 날들, 새벽 길, 떠오르던 아침 해와 그걸 바라보던 나와 그 공기, 안개. 모두 선명하게 기억한다.\n가능하면, 멍청한 나 자신이라고 하는 것이, 그것들을 제멋대로 받아들이는게 아니라 있는 그대로 받아들이고 싶어 노력했다. 아니, 차라리 모두 비우고 싶어서 노력했다. 그리고 노력하는 것도 비우고 그냥 매일 매일 일상으로 그렇게 살고 싶었다. 그리고 그게 행복했다.\n만약 바보 같은 생각들, 하지만 딴에는 똑똑하다고 착각하는 생각들로 판단하고 평가했더라면 그대로 받아들일 것이 아무 것도 없는 일이었을지도 모르겠다. 그렇다고 뭐가 바뀐지도 말하는 방법도 모르겠지만.\n얼마나 많이 멍청한 생각으로 잘났다고 고집 부리며 그냥 그대로 받아들이지 못하는지, 잘 아는 것도 없는데 안다고 착각하는지 생각해봤다.\n그리고 다시 돌아왔다. 원래 그 자리 그대로 돌아왔다. 변한건 나뿐이다. 더 없이 만족스럽다.\n언젠가 다시 이런 기회가 내게 와닿기를, 내가 그렇게 만들 수 있길 바란다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-01jan/type-variances/","title": "⏪ Covariant, Contravariant, Invariant등 Type Variances 이해하기",
     
     "tags": ["type", "type-system", "higher-order-type", "covariant", "contravariant", "invariant", "variances"],
     
 "description": "",
 "contents": " 거의 그대로 베껴온 원본 글\n계약서로서의 타입 타입을 생각할 때, \u0026lt;계약서\u0026gt;로 생각하는 것이 편하다.\n왜냐하면, 전달한 값이 그 타입의 범위 안에서 전달 받은 쪽에서 취급이 제한된다는 보장이 있어야 안전한 코드를 컴파일러는 생성해줄 수 있다. (혹은 그렇게 안전한지 체크를 해준다.)\nSubtype, 일반화(Generalization), 특화(Specialization) 타입을 말할 때, 나는 보통 객체지향언어에서의 클래스의 상속 관계를 떠올린다. 꼭 그렇지는 않겠지만, 이 글에서도 그렇게 설명을 해보겠다.\n이 글에서는 계속 다음 3개의 타입이 있고, 다음과 같은 관계라고 가정하겠다.\n1 2 3 4 5 class Animal(object): pass class Bird(Animal): pass class Human(Animal): pass Animal 타입이 있고, 그를 직접 상속하는 Bird, Human 타입이 있다. (클래스와 타입을 섞어서 이야기하겠다.)\n그리고 각각 클래스의 내용이 여기서는 아무 것도 없는 3개의 단지 그냥 이름이 다른 클래스지만, 상속한 클래스, 혹은 하위 클래스,는 상위 클래스보다 더 특정한 방식으로 기능이나 특성을 \u0026#39;특화(Specialize)\u0026#39;했다고 할 수 있다.\n그리고 반대로, 부모 타입은 자식 타입보다 더 일반적(Generalized)이라고 이야기 할 수 있다.\n그리고 이런 상속 관계를 단순하게, Subtype이라고 말하겠다. (이것도 역시 꼭 같은 것은 아니지만) 그리고 반대로 부모 타입은 Supertype이다.\n표기는, Bird \u0026lt;: Animal, Human \u0026lt;: Animal 와 같이 표기하겠다.1\nCovariant Covariant은 너무 당연해보인다. 대부분의 상황에서 Bird, Human 은 Animal 으로 치환되어도 상관이 없다. 즉, 이 둘은 Animal 의 Subtype이고, Animal 이 필요한 자리에 이들이 와도 상관이 없다면, 이를 \u0026#34;Animal 으로부터 Covariant\u0026#34;이라고 말하겠다.\n예를 들면, 다음과 같은 리스트를 보자:\n1 animals: typing.List[Animal] = [Human(), Bird(), Animal()] 허용된다.\n다시 말하자면, 이 리스트에 있는 모든 값/객체는 Animal 인 것처럼 취급 받아도 안전하고, 그렇게 취급할테니까 괜찮다. 모든 요소가 가장 낮은 수준의 특화 수준에 맞춰서 취급되면 안전하다.\n또, 재밌는 점은 다음과 같이 어떤 타입 변수로 지정된 새로운 리스트 타입끼리 Covariant이 적용되어 Subtype이다.\n1 2 3 4 5 animals: typing.List[Animal] = [] #..일때, birds: typing.List[Bird] = [Bird()] animals = birds 항상은 아니지만 Covariant은 거의 기본으로 대부분에 적용되고2, 이해하기에도 직관적이다.\nInvariant Invariant은 더 단순하다. 지정한 타입만 가능할 때다.\nCovariant이나 Contravariant(아직 소개 안했지만)와 같이 타입 상하관계에 따라서 유추하지 않고, 오직 그 타입만을 지정한다.\nContravariant Covariant은 \u0026#34;그 타입과 하위 타입만 허용\u0026#34;이라면, Contravariant은 반대다. \u0026#34;그 타입과 그 상위 타입만 허용\u0026#34;이다.\nCovariant에 비해서 Contravariant은 어떤 상황에 적용해야 하는지 직관적으로 알기 어렵다.사실 이 포스팅을 작성하는 이유다.\n하지만, Covariant와 마찬가지로 계약으로서의 타입, 코드의 안정성을 담보해주는 타입으로서 생각하면 이해하기 수월하다.\n1 2 3 4 5 6 7 8 9 10 11 12 # 다음과 같은 타입의 함수들이 있다: def live(anAnimal: Animal) -\u0026gt; None: pass def sing(aBird: Bird) -\u0026gt; None: pass def love(aHuman: Human) -\u0026gt; None: pass # 그럴 때: f1: typing.Callable[[Bird], None] = sing # OKAY f2: typing.Callable[[Bird], None] = live # OKAY: Contravariant f3: typing.Callable[[Animal], None] = love # FAIL Covariant을 생각하고 보면, 완전히 반대다.\nf1 은 당연히 이해가 쉽다. 하지만 f2 은 이상하다. 설명해보겠다.\nf2 의 타입은 \u0026#34;Bird 값을 받는 함수\u0026#34;를 의미한다. 하지만, live 은 Bird 의 상위타입인 Animal 을 허용하는 함수다. 그리고 이게 괜찮은가? 괜찮다.\n왜냐하면, 말했듯이 타입을 계약으로 보면 이해가 쉽다. f2 값을 호출할 때, 전달하는 값은 아마 Bird 일 것이다. 그렇다면, 그렇게 전달 받은 값을 받는 함수는 Bird 타입이거나 그보다 더 일반화된 그 상위타입만을 기대하고, 그 범위만큼만 접근/사용하는게 안전하기 때문이다.\n만약 Bird 타입보다 더 특화된, 예를 들어 Blackbird 같은 Bird 의 하위타입을 기대하고 그 함수가 동작한다면 안전하지 않을 것이다. 왜냐하면 f2 에 전달될 타입은 Blackbird 같은 특화된 타입이 아니라 그냥 Bird 일테니까.\nContravariant은 값을 받는 측을 고려해서 타입을 지정하기 때문에, 그 범위를 줄인다. Covariant와 반대이다.\nf3 의 경우는, 만약 함수 타입의 인자에 대해서 Covariant으로 취급한다면 맞는 얘기겠지만, 여기서는 타입체커가 틀리다고 알려준다.3\n함수 타입의 파라미터는 Contravariant, 되돌림 값은 Covariant Contravariant의 적용 예시로, 함수 타입을 들었다. 하지만, 더 정확하게는 함수에 전달하는 파라미터 타입은 Contravariant이다.\n(적어도 MyPy에서는) 함수의 되돌림 값에 대해서는 Covariant이다.\n즉, 다음과 같다.\n1 2 3 4 5 6 7 def makeAnimal() -\u0026gt; Animal: return Animal() def makeBird() -\u0026gt; Bird: return Bird() anAnimal: Animal = makeBird() 간단하다.\nSubtype의 관계 Covariant, Contravariant은 어떤 Generic type의 타입변수 위치에 어떤 타입이 올지도 결정하지만, 그 Generic type이 또 어떤 타입으로 지정되었을 때, 어떻게 Subtype 관계를 만드는지도 결정한다. (이미 Covariant 설명 때 말했듯이)\n즉, 위의 예제들에서,\ntyping.List[Bird] \u0026lt;: typing.List[Animal] 이고, (Covariant) typing.Callable[[Animal], None] \u0026lt;: typing.Callable[[Bird], None] 이다 (Contravariant) 언어마다 다를 수 있다 그런데, 꼭 함수 타입의 파라미터는 Contravariant이고, 되돌림 값의 타입은 Covariant이지는 않다.\n언어나 타입체커마다 다르게 유추할 수도 있고, 가끔은 아예 내가 직접 지정해서 그렇게 동작하도록 해줘야 하는 경우도 있다. (Java, Scala등)\nFootnotes 1 https://en.wikipedia.org/wiki/Subtyping\n2 타입체커, 컴파일러가 기본적으로 이렇게 유추하는 경우가 많다.\n3 MyPy 파이썬 타입체커.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-01jan/esup-emacs-init-speed/","title": "🚞 Emacs 시작 시간 빠르게 만들기",
     
     "tags": ["gc", "emacs", "elisp", "init", "speedup", "esup", "profile", "profiler"],
     
 "description": "",
 "contents": " 이맥스 설정이 조금씩 자라날 때마다 이맥스를 새로 시작하는 시간도 길어져서 짜증이 슬슬나기 시작했다. 그래서 조금 개선해봤다.\nQuelpa + MELPA 거절하기 Quelpa 을 이용해서, MELPA등에 등록된 패키지가 아닌 내가 작성해서 GitHub에 올려놓고 사용하는 패키지를 Git으로 받아서 등록해 사용한다.1\n그런데, 어차피 use-pacakge을 이용해서 MELPA 등 패키지를 받아와서 사용하는데, 불필요하게 MELPA 인덱스를 시작할 때마다 받아오고 한다는걸 알게 됐다.\n당연히 껐다. 한참 빨라졌다.\n참고: Inhibit MELPA git checkout or updates on init\nesup profiler Elisp 자체는 프로파일링이 가능한데2, $HOME/.emacs 같은 init file을 실행하는 시간은 측정이 어려운거 같아서 검색해봤다.\nesup 이란 패키지가 있어서 그냥 M-x package-install 설치하고 실행해봤다. 아무런 고민도 없이 바로 이맥스를 새로 하나 더 띄우고 통신을 자동으로 해서 다음과 같이 그럴듯한 시작시간에 소모한 시간을 프로파일링해줬다.\nGC 성능 개선하기 esup으로 알게 된 것 중에 그냥 줄이기 쉬워 보이는게, Garbage Collection 시간이었다.\n그리고 알고보니, 그렇게 자동적으로 있는 메모리만큼 똑똑하게 GC을 하는게 아니라 특정한 크기나 힙에서의 비율만큼 사용했을 때 GC을 한다는걸 알아서 바꿨다.\n1 (setq gc-cons-threshold (* 1024 1024 500)) 그냥 500MiB 정도 사용하면 GC하도록 했다.\n그리고 당연히 GC에 시간을 아예 소모하지 않아서 꽤 빨라졌다.\n나중에 한번에 너무 크게 GC 하지만 사용하다 보니, 어느새 메모리 사용량이 지정한 threshold만큼 찼고, GC을 하는데 아예 이맥스가 잠시 동안 뻗어 있었었다.\n그냥 기다리니까 GC을 정상적으로 마치긴 하더라.\n그래도 이런 문제를 해결하기 위해서 다음처럼 타이머를 걸어서 주기적으로 GC을 돌릴 수도 있는거 같다3:\n1 2 (run-with-idle-timer 2 t ; 2초마다, repeat (lambda () (garbage-collect))) 그냥 이렇게 안하고, 심심하면 내가 손수 해줄까 고민 중이다.\nFootnotes 1 https://github.com/ageldama/moonshot\n2 https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html 이런 것 이외에도 디버깅 기능 같은 것들로 Elisp 개발할 때 나름 편안하다.\n3 \u0026#34;Is there any downside to setting `gc-cons-threshold` very high and collecting garbage when idle?\u0026#34;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2020-01jan/real-communication-skills/","title": "🚨 &lt;소프트스킬&gt;, &lt;커뮤니케이션 스킬&gt;은 어떻게 한국 사회에서 괴물을 만드는지",
     
     "tags": ["soft-skill", "communication", "bullshit"],
     
 "description": "",
 "contents": " 우선 이야기를 시작하기 전에 일러두고 싶다. 내게 \u0026lt;소프트스킬\u0026gt;1은 매우 재밌게, 유용하게 읽은 책이었다. (2016년에)\n이 이야기는 사실 커뮤니케이션스킬, 소프트스킬을 권장하고, 어떻게 해야 할까 하는 고민에서 나오는, 또한 그런 정말 중요한 것이 어떻게 (적어도 내가 느끼기엔) 이상한 괴물을 옹호하기 위해 변질되어 쓰이는지에 대한 것이다.\n\u0026lt;사회생활\u0026gt;, \u0026lt;원만함\u0026gt;에 대해 나는 자라오며 계속해서 잔소리를 들어왔다. 말해주는 사람들은 내 아버지와 몇몇 친척 형, 주변 친구들이었다. 그리고 하나도 그런 말들을 새겨 듣지 않았고, 잘했다고 생각한다.\n다른 조언들에 대해서는 한번 더 생각했겠지만, 내가 거부한 조언의 종류는 \u0026lt;원만함\u0026gt;에 대한 이야기들이었다. 맞는 이야기이다. 하지만 내가 거부하는 종류의 \u0026lt;원만함\u0026gt;의 요구는, 다른 한가지 요구조건이 따라 붙는다. 그걸 말하는 사람이 사실은 내가 걱정되어서가 아니라, 자기가 살아온 방식과 익혀온 사회적 관습과 달라서 당혹스러워서 내게 요구할 때 뿐이었다.\n나는 의외로 예의가 바르게 행동하려 노력한다. 스팸전화를 걸어온 상담사에게 예의 바르게 거절하기, 미친새끼처럼 별 이익도 없이 쓰레기 같이 운전하지 않기, 조용하고 예의 바르게 사회의 익명으로 걷고 가게에 가서 물건을 사고 살아가기. 그리고 가능하면 원만하려 노력한다.\n하지만 어떤 사람들은, 어떤 역할을 맡은 사람들이, 특정한 상황에서는 원만해서는 안된다고 생각한다.\n예를 들면, 공무원이나 군인, 항공기 파일럿, 은행원 같은 사람들이 원만해서는 안된다고 생각한다. 재밌게도 이런 사람들은 기대되는 상황에는 원칙주의자가 된다. 주로 자기에게 책임소지가 생길 상황일 때이다.\n하지만 자기 상관에게 싫은 소리, \u0026lt;사회생활\u0026gt; 못한다는 소리를 들을만한 이야기를 해야만 할 때, 그리고 다시 역으로 책임소지가 생길만할 때는 원칙을 비틀어 이용한다.\n상관의 잘못을 지적해야 하는 시점을 놓치도록 선후배 관계, 위계질서, 사회생활에 대해 고도로 훈련된 항공기 파일럿이 말도 안되는 그런 이유로 추락시켰다.2\n책임을 지기 어려워 책임소지를 놓고 탁구 게임을 하면서, 수백명이 탑승한 여객선을 침몰시키고 제대로 구조하지 못했고, 그 이후에도 제대로된 구조는 물론 책임을 물기 싫어함, 원만함만을 추구했다.\n치매 노인에게, 원금 손실의 위험성을 제대로 인지하는지도 알기 어려운 상황에 놓인 이에게, 또한 투자경험이 없는 노인에게 투자상품을 가입하도록 권유한다.3\n당신도 오늘 이런 풍경을 겪었을지도 모른다. 스팸 전화로 대출권유, 신용카드 발급권유, 보험가입 권유 등등. 사실 권유가 아니라 강요에 가깝지만. 전화상담사는 자신의 실적, 이익에만 관심이 있고, 그걸 가입해서 내 신용평가점수나 내 현금지출에 대해서는 전혀 부각시켜 대답하지 않는다. 내가 아무리 물어도 시원한 답변을 하지 않는다. 고도로 이런 사회분위기에 맞춰진 사람들이다. 그리고 그 사람들을 그렇게 몰아가는 이 분위기와 경제구조를 떠올리기 이전에 그들이 짜증나고 싫어진다.\n어른의 사정, 그리고 그것은 사실 전혀 어른스럽지 못한 어른들 원만함, 사회생활에 능숙함이 어떤 문제인지 말하고 싶다. 그 원만함이란 말은 굳이 \u0026#39;안해도 될말을 해서\u0026#39; 문제를 만들거나 손해를 보지 말라는 이야기인데, 종종 그 안해도 될말이 사실은 공정하기 위해서, 정직하기 위해서 해야만 하는 말인 경우가 더 많다고 생각한다.\n세계 어디서나 동일한 문제일거라고 생각한다. 그리고 한국에서는 참 멋지게도 이런 특성이 무엇이 공정함, 정직함인지 알고 깨닫지 못하고, 그 가치를 사회에서 냉대하고 비웃는다. 반면 이런 원만함, 사회생활, 책임을 전가하기가 \u0026lt;어른의 방식\u0026gt;이라는 우스운 생각이 뿌리가 깊다. 어른의 정의란, 자신의 행동에 책임을 당당하게 짊..이 아닐까.\n하지만 한국사회에서 책임을 진다는 것은, 한 개인이, 한 노동자가 짊어지기 어려운 것을 과한 것을 책임지우고, 더욱이 책임이 없는 이를, 누군가 높은 자리에 계신 책임을 정말 져야할 분이, 그 책임을 떠넘기고 뒤집어 씌워 보여주기식으로 희생양 삼기 때문에 모두가 이렇게 행동하는 것이리라 생각한다. 빨갱이로 몰아가 죽이기, 지역감정, 진보도 다 썩었다, 등등 시대를 바꿔가며 그 모습이 얼마나 추했었는지 우리는 지켜보지 않았던가?\n한국 사회에서 정직하고 공정하게 살기란 큰 용기가 필요하다. 그럼에도 조금씩은 내가 희생할 수 있을만큼은 그런 가치를 깨달아 지켰으면 좋겠다. 그리고 그럴수록 나는 더 좋은 사람들이 주변에 늘어날 것이라고 생각한다. 지금 어쩌면 당신 주변에 있을지도 모르는 무능한데 선동하고 추하게 행동하고 실은 당신이 일하지 않으면 자기도 이득볼 수 없는 주제에 당신을 괴롭히고 당신에 대해 못된 소문을 퍼뜨리는 어떤 사람 대신에.\n\u0026lt;세련됨\u0026gt;과 \u0026lt;능숙함\u0026gt;에 대해 어른으로서, 한국 사회에서 살아남기 위해서 \u0026lt;세련됨\u0026gt;, \u0026lt;능숙함\u0026gt;을 익혀야만 했을 것이다. 하지만 그만큼 당당하지는 못한 어른이 되었으리라 생각한다.\n그리고 다시 자신이 그렇게 된 것을 다른 이에게 강요한다. 그것도 별로 당당하지 못한 이유들 때문이다.\n주로, 자신이 어리숙하고 사회경험이 부족하여 쉽게 이용하고 등쳐먹고 싶은 대상, 그러기 쉬워보이는 청년에게 흔히 이런 말을 한다면, 사실은 그 의도가 길들이기일 것이다. 그렇지 않다면 굳이 열을 올리며 그런 이야기를 강요하며 세뇌하려 노력할 필요가 없다. 그것도 아니라면 자기 자존감을 위해서 그러는 것이고.\n정말 착취하려거나, 자기 알량한 자존감을 충족하기 위해서 이렇게들 행동하는 30대 이상의 한국 아저씨들을 많이 봤다. 나도 그럴지도 모르고. 내가 20대 사회초년생일 때나 지금이나. 그리고 그때는 잘 몰랐었지만 지금은 그냥 그런 이야기들을 들으면 너무 투명해서 피곤함을 느낀다.\n이미 이야기했듯이, 그들이 말하는 원만함, 사회생활의 기준은 강요하는 이의 자기 기분의 만족, 혹은 길들이기 쉽게 만들기에 정말로 충실하다.\n그리고 보통 이런 논법을 통해서 저임금 노동, 말도 안되는 노동조건을 만들어낸다. 그리고 그런게 문제로 제기 되어도 오히려 역성을 낼 수 있는 방법이기도 하다. 어디가서 그렇게 사회생활하면 누가 받아주겠느냐 등등.\n이러한 \u0026lt;세련된\u0026gt; 어른들은, 자신들이 믿는 가치에 정말 충실하다. 그래서 남을 공격하고 비난할 때도, 절대 자신이 공격했다는 책임을 지기 싫어서 빙빙 돌리고 베베 꼬아서 말한다. 그래서 도대체 무슨 이야기를 하는건지도, 대체 왜 지금 시점에 저런 이야기를 하는건지도 알 수 없는 이야기를 중얼거린다. 내가 미성숙한 아이였을 때, 때와 상황을 잘 모르는 주제에 그냥 무슨 말이라도 하고 싶어서 중얼거릴 때와 같이 말하는 것을, 성인이 되어서, 그것도 30대~70대 사이의 성인 남성이 그렇게들 말하는 모습을 자주 봤다. 그래서 덕분에 상대는 어떤 대답도 하고 싶지도, 대답할 문맥도 아니어서 대화, 논의는 아무런 결론도 없고, 성과도 없이 끝난다. 아! 물론 성과는 있겠지. 그걸 중얼거린 바보는 자신의 감정이 어느 정도는 만족했을거고, 자기가 뭔가 대단히 세련되었고 지적이라는 착각을 충족했을테니까.\n이런 탓에, 사회에 그렇게도 \u0026#39;당신이 내 말을 오해했네, 그런 의도로 말한게 아니네\u0026#39;, \u0026#39;네가 너무 예민하게 반응하는 것이다, 그런 의도가 아니었다\u0026#39; 같은 이야기가 너무 많다. 그렇게 고등교육을 받은 인구가 많고 문맹률도 최저인 나라에서 너무할 정도로 대화가 안 통하는 사람들이 그렇게도 많은 이유와 그런 오해를 조장하는 사람이 너무도 많다. 신기할 정도다.\n보통 이런 \u0026lt;어르신\u0026gt;들은 상대가 세상물정 모르는 어린애이고, 그렇기 때문에 적당히 별 이득도 안될 당연한 것들을 생색내거나 말도 협상의 대상으로 생각하지 않기 때문에 어이 없는 조건을 내걸거나, 그래서 협상을 끝까지 이뤄내지 못한다. 그리고 결국 자기 자신도 그 협상이 어째서 이뤄지지 않는지를 이해하지 못하고, 상황을 제대로 인지하지도 못한다. 또 그냥 상대가 어리숙해서 그런다며 탓한다. 정말 어리석고 세상물정을 모르는건 그런 사람인지도 모르겠다.\n이런 사람들을 너무 여럿 봤다. 당연히 내가 수락할 이유도 없는 일이나 조건을 내걸고서 생색을 내거나, 내가 당연히 감정도 없어서 그런 말을 해도 당신의 말을 따를거라고 착각하는 멍청함까지 갖춘 사람들. 도대체 어떻게 그런데도 \u0026lt;사회생활\u0026gt;을 하려고 하는지 나는 이해가 안된다. 그리고 이런 사람들이 자신들이 떠드는 성공은 커녕 시간의 뒷켠으로 사라져갈 때마다 나는 세상이 그래도 제대로 돌아가고 있다는 생각을 다시 되새길 수 있다.\n정말로 유독한 부류에 대해 어떤 사람들은, 이런 세련된 화법, 외교적 방법, 정치적인 감각, 커뮤니케이션 스킬, 소프트스킬을 자신의 강점으로 강조한다. 그리고 그에 곁들여서, 나나 타인의 그런 부분이 얼마나 형편 없는지도 함께 강조해서, 자신의 강점을 더욱 부각시키려 노력한다.\n하지만 내가 봐온 이런 부류의 사람들은 커뮤니케이션, 소프트스킬은 커녕 정치적, 외교적 감각은 커녕, 기본적인 도덕, 양심, 심지어 자기가 오래 일해온 분야에 대한 상식도 없는 사람들이었었다.\n오직 자기가 모른다는 것을 인정하지 못하고 그냥 세련된 화법이라고 생각하는 잔재주로 그걸 치장하기만 열심이고, 남을 잘못도 없는데 뒤집어 씌워서 자신을 강조하고 싶어하며 어떻게든 남을 착취하고 또 그걸 착취하는걸 자기 상급자에게 갖다 바쳐서 이익을 보려고 노력하던 사람들뿐이었었다.\n그들이 말하는 다른 사람들과 원만하게 지내고, 맞고 틀림보다 조금 논쟁에서 져주더라도 사람의 마음을 얻기가 더 중요하다고 말하는 사람인데, 다른 한편에서는 가장 남을 조종하려 노력하고 있고, 나에 대한 나쁜 소문을 만들어서 퍼뜨리거나 하는 식으로 열심이었던 이들이다. 글쎄, 정말 지혜롭고 다른 사람의 마음을 얻고 싶다면 그래서는 절대 안될 일들일거 같다. 차라리 논쟁에서 확실하게 이야기하고 남을 음해하거나 하지 않는게 더 마음을 사는 쪽에 세련되고 확실한 방법일지도 모르겠다. 적어도 나는 자기를 논쟁에서 기분 나쁘게 했음으로 앙금을 품는 사람들이, 자기를 음해를 하는걸 사회생활이니 어쩔 수 없지라며 이해해주는 분위기가 더 정신병자들 같다.4\n후자가 훨씬 유독하고, 조직, 회사, 사회를 병들게 만들고, 절대 용납되어서는 안된다고 생각한다. 하지만 어떤 사람들은 자신들이 그런걸 결정할 수 있다고 믿는다. 아니 착각한다. 그렇기 때문에 사람들의 마음을 잃고 많은 사람들이 떠나게 만든다. 그리고 그래놓고서 제정신이어서, 자신의 정신건강, 육체적 건강, 그리고 경제적 이익 등 모든 정상적인 판단력으로 떠나는게 맞는 상황에서 올바른 결정을 내린 이들을 탓하고 욕한다. 재밌다.5\n개발자 농담과 길들이기, 이를 돕는 사람들과 개발자 자신에 대해 가끔 나는 개발자 농담이 사회현상이라기 보다는 경영하는 분들의 편의를 위해 동작하지 않나 생각도 든다.\n왜냐하면, 개발자들의 이익이나 그런걸 보통 다른 부류는 시기를 하는데 그걸 경영하는 측은 편을 들어주지 않아야 다른 쪽에 균형도 맞출 수 있고, 또 편가르기를 해놓고 서로 융화하지 않아야 모두 조작하기 쉬울거 같다는 생각이기 때문이다.\n개발자 개개인에 대해서도 흔히 말하는 길들이기의 일환으로 그런 비아냥, 농담을 던져서 자존감을 낮추고 조종하는 것도 방안이리라 생각한다.\n또 거기에 한술 더 떠서, 그런걸 알아서 진상하고 갖다바치려 노력하는 위에 말한 유독한 사람들의 부류도 있을 것이다. 재밌게도 정말 평범하고 흔하디 흔한 전형적인 모습일거라 나는 상상한다. 의도적이건 어느새 그렇게 흘러갔건간에 말이다.\n사실 정말로 개발자 자신들이 그런 커뮤니케이션이 불가능하고 멍청한 사람들이 정말로 있기는 하다. \u0026lt;개발자 놀이\u0026gt;에 충실해서, 자신이 개발자라는데에 너무나 감격해서 그 역할에 몰입이 심한 사람들. 이런 사람들은 그렇게 능력이 있지도 논리적으로 말하고 생각하지도 못한다. 왜냐하면, 개발자가 아닌데, 개발자 역할극을 즐기는 사람일뿐이기 때문이다. 이런 사람은 재밌게도 정말 커뮤니케이션이 불가능하다. 그리고 이런 사람들이 위에 말한 그런 낚시에 걸려들어 비슷한 부류끼리 일을 하게 된다. 흥미롭다.\n그렇지 않은 개발자들도, 사실 흥미롭다. 자기가 알아서 자기 계발이라고 시간을 더 투자해서 공부를 하고, 나아가서 그 공부의 주제영역, 그 외연을 계속해서 확장해나간다. 그리고 마침내 커뮤니케이션, 소프트스킬에까지 다다른다.\n소프트스킬, 커뮤니케이션 스킬이 나는 중요하다고 생각한다. 하지만 경제주체로서 어디까지 학습하고 어느 역할까지 해야 한다고 다시 생각하고 물어봐야 한다고 생각하기에 반대한다.\n왜냐하면, 개발자의 역할을 계속해서 늘려나가야만 프로페셔널이라고 말하는 분위기가 나는 잘못 됐다고 생각한다. 오히려 개발자는 더 집중적이고 전문적이어야 하고, 거기에 커뮤니케이션스킬, 소프트스킬을 갖춘이가 있다면 그에 상응하는 또 다른 분야의 전문가로서 생각해야 한다고 말하는 것이다. 하지만 어느샌가 개발자가 진정 \u0026lt;프로페셔널\u0026gt; 해야 한다며, 말도 안되는 논리로, 무조건적으로 남들에게 소통을 하고 남들이 말도 안되는 요구나 대화를 걸어와도 친절하게 응대해야 한다고 개념을 확장해나간다. 당신들이 말하는 그런 \u0026lt;프로페셔널\u0026gt;은 어쩌면 아예 다른 직업일 것이다. 도메인 전문가나 도메인 전문가, 현업과 대화하며 이를 요구사항으로 정제하는 인터뷰어, 혹은 당신들이 그렇게도 도대체 하는 일이 없다고 말하는 프로젝트 매니져들.\n그 프로젝트 매니져, 혹은 프로젝트 어시스트들이 해야 하는 일이, 다른 사람과의 중간 대화를 해주는 역할이라면, 이것만으로도 충분히 전문적인 일이다. 하지만 정작 우스꽝스러운 구조, 그러니까 프로젝트 매니져가 개발자의 보스가 되어서 그냥 압박만 주는 사람으로 통념적으로 잘못 이해되고, 또 그게 뭐여야 하는지 고민도 없이 그 통념에 따르는 회사의 어눌함, 혹은 그런걸 맘껏 이용해 뭐가 됐든 알아서 굴러가길 바라는 마음가짐이건, 등등으로 프로젝트 매니져가 사실 개발자들에게 자신의 직분과 책임을 떠넘긴다. 사실 자신이 현업 인터뷰를 잘하고 그걸 정제해서 요구사항으로 만들고 관리하는게 당연함에도 그걸 개발자의 탓을 하며 떠넘긴다.\n정말 신기하게도, 위에도 언급했지만, 개발자들은 자신이 노조를 결성하거나 해서 다른 전문직업군처럼 활동하지 않는다. 그렇기 때문인지, 아니면 그래서인지, 자신을 더욱 능동적으로 착취 당하기 위해 더욱 자기계발을 하고 자신의 기능을 늘려만 나간다. 그것도 같은 값에 자신의 노동을 팔기 위해서 처절하게 자기 학습을 늘려나간다. 다른 직업이었다면, 너무나 많은 것을 요구 받는 것을 반대하고, 또 그런 것을 요구 받지 않아도 자기 직업을 안정적으로 유지하기를 요구할 것이다. 부당한가? 그렇지 않다. 오히려 너무나 당연하고 공정한 일이다. 그럼에도 개발자들은 자진해서 자신들의 몸값과 기능의 균형을 깨가며 싸게 더욱 더 많은 기능을 탑재해서 노동 시장에 내놓는다. 그리고 그런 압력과 분위기는 개발자들이 모인 SNS, 커뮤니티에 팽배하다. 소프트스킬이 중요하고, 커뮤니케이션이 어떻고, 또 새로운 기술이 뭐가 어떻고.6\n위에서 말했지만, 어떤 사람들이 개발자와 같은 직군을 어리숙하다고 보고, 말도 안되는 제안, 어린애로 무시하는 내용의 제안 등을 내걸고 그걸 수락할거라 착각하는 주된 이유이지 않을까 생각한다. 그리고 사실 어떤 사람들은 정말로 그런 개발자 역할극에 심취해 그걸 수락할지도 모르겠다. 아마 그렇게 이런 분위기로 달려왔으리라.\n어쩌면 개발자들은 노조가 필요할지도 모르겠다. 하지만 자신들은 가장 노조가 필요 없다고 착각하는 부류인지도 모르겠다. 그리고 그렇기 때문에 사람들이 개발자 농담을 하고, 개발자를 그렇게 여기고, 또 정말로 자기 자신의 몸값이 계속해서 떨어질텐데도 말이다.\n설치시 필요사양 / Minimum Requirements 소프트스킬, 커뮤니케이션 스킬, 소통 등등을 제대로 하기 위해서 먼저 필요했던 것이 없었기 때문에 이런 괴상한 모습으로 변질되었다고 생각한다.\n먼저 책임을 남에게 전가하지 않기, 높은 사람이 되어서 책임을 전가하고 희생양을 찾지 않는 책임감과 도덕성, 그리고 그런 사람을 따르고 정말 유해한 사람이 누군지 알고 밀어내는 안목이 필요하다고 생각한다.\n하지만 그것들은 어디까지나 수동적인 모습일 것이다. 오히려 노동조합을 만들어 권익을 지키고, 부당함이 없어도록 하고, 잘못된 일이 바로 잡히도록 하는 것, 그리고 그렇기 위해서 개발자 자신들이 단순히 취미로서 일이 좋아서 하는 마음가짐에서 벗어나서 사회의 일원으로, 경제주체로서 어떻게 행동해야 하는지, 그리고 그렇게 해야 자신이 좋아하는 일을 건강하게 계속해서 해나갈 수 있을지를 고민했으면 좋겠다.\n여기에서 \u0026#39;건강하게\u0026#39;, \u0026#39;지속가능하게\u0026#39;라는 말을 그마저도 타성적으로, 그걸 자기계발의 연장으로 인식한다. 물론 건강을 위해, 지속적으로 하기 위해 체력을 기르고 개개인이 해야한다. 하지만 그럼에도 현실이 그런 운동을 하는 시간이나 체력을 허락하지 못한다면 뭔가 잘못된 것이고, 그렇게까지 또 다른 형태의 자기 계발의 투자를 강요 받는다면 더 사회적인 관점에서 접근해봤으면 좋겠다고 말해주고 싶다.\n그렇게 해서, 정직함, 공정함의 가치가 제대로 평가 받아야 제대로된 대화를 시작할 수 있으리라 생각한다. 능숙함, 세련됨은 그 위에 세워져야 바른 모양이겠지.\nFootnotes 1 http://www.yes24.com/Product/goods/23161141\n2 항공사고 블로그: 권위주의가 부른 참사, …화물기 추락사고\n3 연합뉴스: 은행들의 탐욕…79세 치매노인도 졸지에 \u0026#39;공격투자형\u0026#39; 그 이후에 어느 정도 많이 복구와 보상이 있었던걸로 나는 알고 있다. 사회적 이슈가 되어서 그나마 다행이었다고 생각한다.\n4 나는 \u0026lt;카네기 인간관계론\u0026gt;이 꽤 맞는 이야기라고 생각하고 좋아했던 책이기도 하다. 심지어 이런 부류의 사람들이 틀린 기술적인 자기 주관을 자랑스럽게 설파할 때, 아 그렇습니까. 그렇지요 하면서 기분을 맞춰주려 노력도 해봤다. 알아서 눈치채고 그만두기를 간절히 바라면서. 이런 사람들은 다른 모든 사람들이 그걸 영원히 속아줄거라 착각하는거 같다.\n5 \u0026lt;삼국지\u0026gt;, \u0026lt;마키아벨리\u0026gt;를 정말들 좋아한다. 자기가 조조나 제갈량, 영웅, 군주나 지략가 등등이라고들 착각하지만, 그정도는 커녕 당장 당신 앞에 있는 사람에게 당연히 제안할 것과 어떻게 예의를 갖추는게 중요한지도 이해하지 못하며, 현실인지능력도 떨어진다. 대체 어떤 생각으로 읽었는지, 머릿 속에 남은 생각이나 교훈이 뭔지 너무도 유치할거 같아서 묻고 싶지도, 이에 대해서 대화하기 두렵다. 하지만 그걸 자랑스럽게 떠들어대고는 해서 곤란하다면, 삼국지 등을 읽은 적이 없다고 이야기 하는게 차라리 속이 편할 것이다.\n6 아마 개개인이 속한 부득이한 경제적 사정, 상황에 의해 직업을 구해야만 하니, 또 다르게는 더 그런 삶의 방식을 지속하고 싶은 욕심에 그런 비용을 제공하는 직장을 구하려고 하니 어쩔 수 없겠지 생각한다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/lisp-dynamic-and-lexical-bindings-and-js/","title": "📓 Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let",
     
     "tags": ["lisp", "scheme", "common-lisp", "emacs-lisp", "guile", "clojure", "javascript", "dynamic-binding", "lexical-binding", "commonlisp", "programming"],
     
 "description": "",
 "contents": " 다음의 간단한 코드를 읽어보자.\n1 2 3 4 5 6 7 8 9 10 11 12 var x = \u0026#34;lexical\u0026#34;; function maker() { return function() { return x; }; } { var x = \u0026#34;dynamic\u0026#34;; assert(maker()() == \u0026#34;???\u0026#34;); } maker()() 의 결과는 \u0026#39;dynamic\u0026#39; 이다.\n심지어, 맨 마지막에 있는 {..} 블록을 넘어가서도 x 의 값은 여전이 \u0026#39;dynamic\u0026#39; 이다.\n자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난 느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도 속하지 않는 느낌이고, 이번에 새로 추가된 let 도 이해하기가 어려운게 아니라 그냥 제대로 망가져 있는거 같다.\n그나마, let 키워드를 이용하면, lexical binding으로서나마 제대로 동작하기 시작한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const assert = require(\u0026#34;assert\u0026#34;); let x = \u0026#34;lexical\u0026#34;; function maker() { return function() { return x; }; } { let x = \u0026#34;dynamic\u0026#34;; assert(maker()() == \u0026#34;lexical\u0026#34;); assert(x == \u0026#34;dynamic\u0026#34;); } assert(x == \u0026#34;lexical\u0026#34;); 그러면, lexical binding와 dynamic binding이 뭐길래 나는 이렇게 괴로워 하는가.\ndynamic binding \u0026amp; lexical binding 커먼리습으로 예시 코드를 짜봤다:1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; every `defvar\u0026#39;, `defparameter\u0026#39; is dynamic binding. (defvar *x* nil) (defun f-dynamic () *x*) (let ((y \u0026#39;lexical)) (defun f-lexical () y)) (defun run () (let ((*x* \u0026#39;dynamic) (y \u0026#39;dynamic)) (declare (ignore y)) ; silence the: \u0026#34;style-warning: The variable Y ; is defined but never used.\u0026#34; (let ((l (multiple-value-list (values (f-dynamic) (f-lexical))))) (pprint l) (assert (equal l \u0026#39;(dynamic lexical)))))) (run) ; 실행 dynamic binding와 global variable defvar 으로 global-scope에 만든 변수, *x* 을 되돌리는 함수를 만드는 함수, f-dynamic 이고, 이를 호출 하는 시점에 let 으로 이를 덮어 씌운다. 그리고 결과도 덮어 씌운 값으로 나온다.\n이는 마치 다음이 괜찮은 코드라는 의미:\n1 2 3 4 5 6 7 8 9 10 11 12 x = \u0026#39;no-dynamic\u0026#39; def f(): return x def run(): x = \u0026#39;dynamic!\u0026#39; assert f() == \u0026#39;dynamic!\u0026#39; # 실패한다. # 여전히 f()안에서는, x == \u0026#39;no-dynamic\u0026#39;이다. if __name__ == \u0026#39;__main__\u0026#39;: run() 그런데, 커먼리습에서는 이게 된다.\n심지어, 커먼리습의 대부분의 함수, 매크로는 이렇게 쓰는게 일반적인 idiom이다:\n1 2 3 4 5 6 7 8 9 (defvar *some-stream* *standard-output*) (defun print-sth (x) (format *some-stream* \u0026#34;~a~%\u0026#34; x)) (print-sth 42) (let ((*some-stream* *standard-error*)) (print-sth :error!!!!)) 다른 언어였었다면:\n*some-stream* 을 print-sth 이 종속하므로, 2 파라미터로 받거나, (default value이 지정되어 있는 optional parameter이라던가) builder pattern 같은 것을 사용해서 스트림을 지정하고, 그에 따라 동작하는 메서드로 print-sth 을 정리해야 했겠지 위에 말한 방법들 모두 커먼리습에서 쉽게 가능하고 많이 사용하는 방법이지만, 그래도 이런 방식으로 context 객체나 어떤 모듈에서 널리 공유하는 상태를 적용할 때 이렇게 dynamic binding 을 이용한다.\n그리고 이렇게 적용하는 것도 defvar, defparameter, let 으로 간단하고 일상적이다.\n전역변수와 같은 모양이지만, 전역변수랑 동일하게 생각하기는 조금 다르다. 언제나 문맥에 따라서 파라미터로 사용하기 위해서 있는 것이고, 또 그렇게 쓰도록 권장하니까.3\nJS에서 var, let 모두 이렇게 만들기는 잘 모르겠다. 쉽지는 않을거 같다.\nlexical binding 위 예제 코드에서 f-lexical 은 그 함수가 선언되는 시점, defun f-lexical 시점의 y 을 언제나 갖고 있고, dynamic binding와는 다르게, let 을 통해 변경할 수 없다.\n또, 어떤 변수가 lexically하게 가장 가까운 scope에서 선언된 내용을 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (let ((x \u0026#39;f)) (defun f () (pprint x))) (defun run () (let ((x \u0026#39;run-1)) (let ((x \u0026#39;run-2)) (pprint x) (f)))) #| CL-USER\u0026gt; (run) RUN-2 F |# 같은 함수, 호출스택 안에서는 단순하게 가장 가까운 let 의 선언으로 덮어씌운 x 을 사용하지만, dynamic binding와는 다르게, f 을 호출해서 스택프레임이 달라지면 덮어 씌우지 못한다.\n이해하기 단순, 간단하다.\nclosure와 lexical binding 사실, lexical scope만 제대로 있어도 여러모로 편안해진다.\n블록의 단계별로 같은 이름인 변수의 덮어쓰기, 요즘 흔히 말하는 shadowing. 그리고 요즘 많이 알려진 closure으로 감싸는 환경environment, 그 변수를 감싸서 갖고 있는 것도, lexical closure 이다. JS은 closure을 지원하기는 했지만, let 이전에는 제대로 lexical binding을 지원했다고 할 수는 없다. (맨 처음 섹션에서 보였듯이)\n추가: Emacs-Lisp, Scheme, Clojure에서 lexical/dynamic bindings 오늘 포스팅은 딱히 엄청난 결론을 이끌어내지는 못해서 그냥 Lisp계열 언어들의 예제들을 나열이나 해보려고 한다.\nScheme Scheme에서는 lexical binding만 지원한다.\n하지만, dynamic binding은 SRFI-39 으로 라이브러리/함수로서 추가적으로 지원한다.\n위 SRFI-39에서도 보이듯이, closure와 macro을 이용해서 스킴 컴파일러/인터프리터를 확장하지 않고도 추가할 수 있다. (그리고 어쩌면 이렇게 유사한 방법으로 JS에도 추가할 수 있겠지)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (use-modules ((rnrs) :version (6))) (define var-dynamic (make-parameter \u0026#39;dynamic)) (define (lexical-maker) (let ((var-lexical \u0026#39;lexical-1)) (lambda () var-lexical))) (define (dynamic-maker) (lambda () (var-dynamic))) ; `var-dynamic\u0026#39; needs to be evaluated as ; a function to get its\u0026#39; value. (define (run) (let ((var-lexical \u0026#39;lexical-no!)) (assert (eq? ((lexical-maker)) \u0026#39;lexical-1))) (parameterize ((var-dynamic \u0026#39;dynamic-yes)) ; not just `let\u0026#39;, it\u0026#39;s ; `parameterize\u0026#39;. (assert (eq? ((dynamic-maker)) \u0026#39;dynamic-yes)))) 조금 괄호가 복잡해보인다. Scheme의 특성으로, lambda-function을 값으로 되돌리고, 또 그걸 그대로 (...) 으로 감싸서 funcall 처럼 바로 평가해 버리니까 2중 괄호로 감싼게 좀 보인다.\nmake-parameter 으로 만든 dynamic binding은 사실 언어 차원에서 지원하는 바인딩이 아니고, 그냥 box-container의 일종일테고, parameterize 매크로를 사용해서 마치 커먼리습에서 let 을 이용해 값을 binding한다. ..그리고 또 괄호로 parameter object을 감싸서 함수로서 평가하여, bind된 값을 참조해낸다. (이렇게 괄호가 또 생긴다.)\nGNU Guile 에서 테스트했다. Racket등에서는 use-modules 이 동일하게 동작할지 모르겠다. 아마 이 라인 대신에 #lang racket 정도로 대체하면 잘 동작할거 같다.\nEmacs-Lisp Emacs-Lisp은 원래는 dynamic binding만 지원했엇다.\n그리고 지금은 lexical binding을 지원하기 위해서는 사용하려는 소스코드의 file local variable 으로 지정해줘야 함.\n1 2 3 4 5 (assert (eq \u0026#39;dynamic (let ((x \u0026#39;lexical)) (let ((f (lambda () x))) (let ((x \u0026#39;dynamic)) (funcall f)))))) 위 코드는 dynamic binding으로 동작한다.\nlexical binding을 쓰려면 다음과 같이 달라진다.\n1 2 3 4 5 6 ;;; -*- lexical-binding: t; -*- (assert (eq \u0026#39;lexical (let ((x \u0026#39;lexical)) (let ((f (lambda () x))) (let ((x \u0026#39;dynamic)) (funcall f)))))) 맨 첫 번째 특별한 주석으로 표기한 부분을 눈여겨 보라.\nClojure Clojure은 기본은 lexical binding을 지원한다. (let 을 통해서)\n그렇지만, ^:dynamic metadata와 binding 으로 dynamic binding을 지정 가능하다:\nhttp://clojure.github.io/clojure/clojure.core-api.html#clojure.core/binding\n1 2 3 4 5 6 7 8 9 10 11 user=\u0026gt; (def ^:dynamic x 1) user=\u0026gt; (def ^:dynamic y 1) user=\u0026gt; (+ x y) 2 user=\u0026gt; (binding [x 2 y 3] (+ x y)) 5 user=\u0026gt; (+ x y) 2 결론 커먼리습하자.\nFootnotes 1 다른 Lisp이 아닌 언어로는 짜기가 어렵거나, 아예 가능하지도 않으니까. 그리고 커먼리습이 Lisp-dialects 중에서 이를 표현하기에 명확하다고 생각한다.\n2 이렇게 dynamic binding인 변수는, 커먼리습의 관례는 *...* 와 같이 표기한다. 참고로 상수는 +...+. –\u0026gt; Google Common Lisp Style Guide\n3 오히려 전역변수는 없는 쪽이 가깝다. 다른 변수로 상태를 표현하고 싶다면, defstruct, defclass 으로 객체를 만드록 정리하겠지.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/direnv/","title": "1️⃣ direnv + direnv-mode 이맥스 지원 + C/C++/Python등 프로젝트 설정 적용하기",
     
     "tags": ["direnv", "direnv-mode", "dot-envrc", "emacs", "c", "c++", "python", "virtualenv", "programming"],
     
 "description": "",
 "contents": " 프로젝트의 빌드 디렉토리, virtualenv와 같은 경로의 설정, 경로 설정에 따른 빌드/실행/테스팅/스크립트을 편하게 하려고 만든 moonshot.el 와 유사한걸 검색해봤다.\n몇 가지 이런 비슷한게 몇 가지 있는데, 내 상황에 쓸만한 것은 direnv\nNPM: dotenv https://www.npmjs.com/package/dotenv\nNode.js에서 Unix environment variable으로 .env 파일을 로딩해주는 역할인 듯.\nShell에서 Hook 걸어서 사용하기엔 별로 인거 같았다.\n그리고 Node.js 이외의 프로젝트에 적용하려면 매번 JS으로 wrapper을 짜주고 하기 싫었고,\n.env 파일이 그냥 정적인 key-value 문자열의 나열이라, 파일시스템에서 경로를 조립하고 하는데 별로라는 생각이 들었다. 항상 절대 경로만 표기하거나, getenv 해서 문자열을 가져와서 상대 경로 등으로 지정된 값을 매번 절대 경로로 만드는 작업을 해야할테니까.\nPython: autoenv https://github.com/inishchith/autoenv\n파이썬으로 작성되어 있고, .env 파일이 있는 디렉토리에 들어가면 내용을 스크립트로서 실행해준다.\n그리고 그 디렉토리를 떠나면, .env.leave 에 지정된 스크립트를 실행.\n..딱 바라는 일들을 할만하게 생겼는데,\n.env.leave 을 매번 작성해주기 귀찮다.\n설정한 환경 변수를 역으로 해제해주는걸 일일이 해줘야 하는 것 같다. autoenv의 프로젝트 페이지에서 direnv을 쓰라고 추천해줬다. 범용성도 좋고, 성능도 좋고, 기능도 강력하고: direnv https://direnv.net/\n우선 파이썬이나 Node.js이 아니라, Golang으로 작성해서 디렉토리에 진입할 때 가볍다.\n그리고 자동으로 디렉토리를 떠날 때, 설정됐던 내용들을 되돌려준다. (아마 진입 전후의 envrionment variables을 비교해서 자동으로 처리해주는 것 같다.)\nzsh와도 연동이 깔끔했다.\ndirenv + Python virtualenv Virtualenv을 사용하는 파이썬 프로젝트를 만들려면,\n다음과 같은 .envrc 파일을 프로젝트 디렉토리에 하나 만든다.\n1 layout python 그리고 direnv 프로젝트 페이지에 설명된 Shell와 연동하는 부분 을 잘 해놓았다면, 그리고 다음을 실행하면, 바로 위 내용이 활성화된다.\n1 direnv allow layout python 만으로 자동으로 .direnv/python-... 디렉토리에 virtualenv을 조성하고, 활성화까지 해준다.\n사실, layout python 한 줄은 대충 다음과 같은 내용과 같다:\n1 2 3 4 5 6 7 export VIRTUAL_ENV=\u0026#34;$(pwd)/venv/\u0026#34; if [ ! -d \u0026#34;${VIRTUAL_ENV}\u0026#34; ]; then virtualenv \u0026#34;${VIRTUAL_ENV}\u0026#34; fi source \u0026#34;${VIRTUAL_ENV}/bin/activate\u0026#34; 위 예제에서는 virtualenv의 디렉토리만 조금 다르게 지정한 것을 제외하고, virtualenv환경을 만들고, VIRTUAL_ENV 환경변수를 설정해주는 것, 마지막에 활성화해주는 것 모두 동일하다.\n유연하고 강력.\n이맥스에서 적용 이맥스에도 연동이 가능하다.\n어차피 이맥스에서 파이썬 프로그램을 작성한다고 하더라도, virtualenv에만 존재하는 모듈이나 툴을 이용해야 할테니까 적용이 자동으로 되는게 속편하다.\nhttps://github.com/wbolster/emacs-direnv\n설치와 설정을 마치고, dired (C-x d)으로 프로젝트 디렉토리를 열면, PATH, VIRTUAL_ENV 등 환경변수가 자동으로 적용된다.\n1 2 ;; 다음을 M-: 누르고 입력해서 확인: (getenv \u0026#34;VIRTUAL_ENV\u0026#34;) 파이썬 프로젝트 디렉토리나 파일을 열 때 자동으로 Virtualenv을 활성화 하도록 설정해봤다:\n1 2 3 4 (add-hook \u0026#39;python-mode-hook (lambda () (when (getenv \u0026#34;VIRTUAL_ENV\u0026#34;) (pyvenv-activate (getenv \u0026#34;VIRTUAL_ENV\u0026#34;))))) 그래서, 파이썬 프로젝트를 예제로 만들고, Emacs와 연동해봤다.\n이맥스쪽에는 lsp-python-ms 와 elpy 에 적용해서 테스트해봤다.\n몇 가지 문제가 있어서 lsp-python-ms은 접어두고, 그냥 기능적으로 잘 동작하고 부족한거 없는 elpy와 direnv-mode을 쓰기로 했다.1\n파이썬의 예시만 들었지만 C/C++ 프로젝트를 위한 부분들도 적용을 해나가면 moonshot.el 만을 쓸 때보다 훨씬 깔끔하게 프로젝트 빌드나 경로 관리가 가능해질거 같다.\nFootnotes 1 lsp-python-ms은 virtualenv의 경로를 venv 으로만 인식하거나, flycheck의 내장된 flake8, pylint등의 checker와 잘 어울리지 못해서 짜증났다. 아직 LSP으로 바꿀 이유도 없는거 같다. elpy만으로 모든 기능들이 거의 동일하거나 더 완성도 높게 동작하니까.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/moonshot-1st-rel/","title": "👢 moonshot.el 최초 릴리즈",
     
     "tags": ["elisp", "emacs", "launcher", "debugger", "executable", "shell", "compile", "compilation-mode", "build", "programming", "opensource"],
     
 "description": "",
 "contents": " moonshot.el 을 만들어서 공개했다.\n이맥스를 써오면서 불편하다고 생각한걸 간단히 하고 싶었었다:\n불편함들 빌드 디렉토리 Projectile을 사용하니까 프로젝트 디렉토리는 관리가 쉬운데, 빌드 디렉토리는 관리가 어려웠다.\n아예 Projectile이 추론하는 디렉토리 바깥에 빌드 디렉토리는 위치하는 경우도 있으니까.\n예) GNU Autotools configure 이나 CMake으로 작업할 때, 소스트리 바깥에 빌드 디렉토리를 걸어놓아서 정리를 깔끔하게 할 수 있으니까. 그런데 이 \u0026#39;빌드 디렉토리\u0026#39;가 중요한게,\n말그대로 컴파일한 .o 파일이나 최종 결과 실행파일 등이 여기에 쌓이니까 디버깅, 테스트를 위해서 실행파일을 실행하거나, 심지어 make 이나 ninja 같은 빌드 커맨드를 실행하기 위해서도 빌드 디렉토리를 지정하거나 이동해서 실행해야 하니까 귀찮다. compilation-mode, realgud: 실행 파일 찾아서 실행하기, 디버깅하기 예전에 만들어 써오던 이맥스를 위한 C/C++ 설정 처럼,\n빌드 디렉토리를 적당히 감지해서, 현재 편집 중인 버퍼의 파일 이름과 Levenshtein 거리가 유사한 실행 파일을 우선으로 정렬한, 빌드 디렉토리에 속한 실행 파일 목록을 나열하고, 선택한 실행파일을 compilation-mode으로 실행하거나 realgud으로 디버깅 시작. compilation-mode은 실행을 종료하고도 편집/빌드한 다음에 다시 compile-buffer에 가서 g 키만 누르면 다시 반복 실행하기 편안하니까 애용.\n그런데, 이것도 꼭 C/C++ 개발할 때만이 아니라, 다른 언어를 사용할 때도, 예를 들어, 파이썬 같은 언어로 작성하고 chmod +x 해서 실행파일으로 만들어서 테스트 할 때도 편리하겠다고 생각했다.\n이렇게 프로그래밍언어 mode별 설정을 만드는게 아니라, 그냥 유닉스에서 실행 가능한 파일을 쉘에서 실행하듯이 바로 선택하기 쉽게 고르고 실행할 수 있다면 편하겠다고 생각.\n또 compilation-mode: configure + build을 위한 쉘 실행 위에 불편함들과 마찬가지로, 프로젝트 루트 에서 configure, cmake 을 실행하고, 그 결과가 빌드 디렉토리 에 쌓이도록 하고, 빌드 디렉토리 에 이동해서, 또 빌드 명령, make, ninja 등을 실행하는게, 생각보다 쉽게 자동화되거나 일반화되지 않아서, 귀찮았었다.\n그래서 moonshot.el을 만들었다 프로젝트별 설정: .dir-locals.el .dir-locals.el 은 조금 생소할 수도 있는데, 프로젝트 루트 디렉토리에 위치해놓고, 그 이하의 모든 파일을 열 때 자동으로 적용할 변수들을 지정할 수 있다.\n프로젝트별 빌드 디렉토리의 설정 혹은 자동 유추 기본적으로는 projectile-project-root 을 쓰거나 현재 버퍼의 디렉토리를 빌드디렉토리로 쓴다. (가능하면 projectile을 이용)\n그런데, 다른 빌드 디렉토리를 지정할 수 있도록, moonshot:project-build-dir 변수를 만들었다.\n.dir-locals.el 파일에 설정해서, 프로젝트별로 특정한 디렉토리를 빌드디렉토리로 지정할 수 있도록 했다:\n그냥 상대 경로를 문자열으로 설정하면, projectile의 루트나 현재 버퍼의 디렉토리에서 상대경로로 설정, 절대 경로면 그냥 그 경로가 빌드 디렉토리. 그것도 아니고, 코드를 실행해야 한다면, Lisp code을 그대로 적어서 빌드디렉토리를 찾아낼 수도 있도록 했다. 빌드 디렉토리에서 실행파일 찾아 실행/디버깅 moonshot:run-executable, moonshot:run-debugger\n빌드 디렉토리를 지정할 수 있으니, 그냥 쉽게 실행파일을 찾아서 실행/디버깅 가능해졌다.\nconfigure and make: 빌드 디렉토리에서 moonshot:run-runners 으로,\n미리 preset으로 지정해놓은 명령을 실행, 프로젝트별로 추가 명령들을 dir-locals에 등록해 쓸 수 있다. 그리고, 명령에 포함되는 경로명 등을 필요에 맞게 쓸 수 있도록, %a 이면 현재 파일의 전체 경로, %p 이면 프로젝트 루트, %b 이면 빌드 디렉토리 등등의 경로 확장 기능을 만들었다.\n이렇게만 해도, 명령을 일반화 해서 계속 한 프로젝트 안에서는 물론이고 다른 프로젝트에서도 그대로 사용하기 좋으니까.\n예시: Python + Virtualenv을 쓸 때 스크립트를 실행하기/디버깅하기 에를 들어, 파이썬을 Virtualenv을 사용해서 작업하고 있고, Virtualenv 디렉토리를 moonshot:project-build-dir 으로 설정해 빌드 디렉토리로 지정했다.\n1 2 3 ;;; .dir-locals.el, 프로젝트 루트 디렉토리에 위치함. ((nil . ((*project-build-dir* . \u0026#34;venv\u0026#34;)))) ; 프로젝트 루트 디렉토리 바로 밑에, ; `venv/\u0026#39; 디렉토리에 virtualenv == 빌드 디렉토리. 이제, 내가 작성한 파이썬 스크립트를 실행하려면, 다음을 거쳐야겠지.\n빌드 디렉토리(venv/)에 위치한 Virtualenv을 source .../bin/activate 으로 활성화하고, 그 환경 안에서 내 파이썬 스크립트를 실행. 이렇게 하려면, 다음처럼 M-x moonshot:run-runners 을 실행하고 입력한다:\n1 source \u0026#34;%b/bin/activate\u0026#34;; cd \u0026#34;%p\u0026#34;; \u0026#34;%a\u0026#34; %b 은 빌드 디렉토리 == Virtualenv 디렉토리.\n%p 은 프로젝트 루트 디렉토리.\n%a 은 현재 버퍼의 파일의 전체 경로.\n결국, virtualenv을 activate하고, 프로젝트 루트 디렉토리로 이동해서, 스크립트를 실행.\n이걸 매번 입력하려면 귀찮으니까, 설정으로 만들어 놓아도 좋다:\n1 (add-to-list \u0026#39;moonshot:runners \u0026#34;source \\\u0026#34;%b/bin/activate\\\u0026#34;; cd \\\u0026#34;%p\\\u0026#34;; \\\u0026#34;%a\\\u0026#34; # Run with Virtualenv\u0026#34;) 마무리 완벽하게 모든 케이스를 다 커버하지는 못할지도 모르겠다. 하지만 조금 문서와 코드를 읽고, 이해를 하고, 여기저기 다른 언어나 프레임웍의 프로젝트에 아주 쉽게 적용하기 좋은 범용적인 도구일거 같다.\nEmacsLisp을 작성하고, Ivy을 이용해서 대화 프롬프트 / 선택 화면 / 추천을 구현하고, compilation-mode을 활용해서 편안하게 개발사이클에서 반복적으로 행하는 작업을 쉽게 시작하고 반복하기 좋게 만드는게 편안할거 같다.\n별거 아닌 빌드 커먼대를 입력하고 실행하는거지만, 이런걸 줄이고 매번 이맥스 설정을 특정한 프로젝트 구조에 맞춰서, 혹은 예상해서 짜놓는 것도 한계가 있다는 생각을 자주했는데, 차라리 이런 범용적으로 활용하기 좋은 구조를 만들어서 앞으로 더 편안하게 프로젝트를 시작하고 작업할 수 있을거 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/look-back-2018-2019/","title": "👃 2018, 2019년을 돌아보며",
     
     "tags": ["looking-back", "2018", "2019"],
     
 "description": "",
 "contents": " \u0026#34;일의 기쁨과 슬픔\u0026#34; 2018년은 정말 바쁘게 회사에 시간을 쏟으며 보낸거 같다. 그렇다고 개인적인 발전이나 성과를 얻을만한 일은 아니었다. 오히려 알던 것들을 소비하고 엔지니어링 이외의 분야에 많은 흥미로운 경험과 성장을 했던거 같다. 그리고 한국을 떠날때 싫었던 점들을 역시 그대로 느낄 수 밖에 없었던거 같다.\n그리고 2019년에는 한국에서 다시 시작했었던, 내겐 그다지 만족스럽지 못했던 회사생활을 정리했다. 정리하는데 반년 정도가 걸렸다. 나도 우유부단하게 괜한, 그리고 헛된 기대를 했었기 때문에 시간을 오래 끌었었는데, 문제를 경험하고 처음 받았던 인상과 결정이 맞았다.\n수많은 생각을 해봐도, 결국, 내가 능력이 부족하고 덕이 없어 그런 선택지 밖엔 없었으리라. 앞으로의 선택에는 배운 것들을 잊지 않고 결정을 내리려고 노력한다.\n교훈들에는 너무 세상에 당연하게 퍼져있음에도 아무도 그러리라 믿지 않는 것들, 혹은 세상에 너무 당연하게 퍼져있는 것과 정반대의 이야기들인거 같다.\n여러군데의 스타트업을 경험하며 창업자들보다 오히려 더 많은걸 배운거 같은 기분이다.\n정말 주옥 같이 좋은 기업, 사람들, 경험이었었다. 정말로 고마운 일들이었었다. 위선적으로 그저 하얗게 밀가루를 뒤집어 씌우는 그런 말로써가 아니라, 정말 그런 역할들이 있어줬기 때문에, 고맙다.\n그간 오랜 기간 일하며 경험한 일들과 감정들, 벌어진 일들이 왜 그럴수밖에 없었는지 납득이 되었다. 그리고 어떤 사람들이 어째서 그렇게 행동했었는지 이해가 명쾌해졌다. 그리고 그에 따라서 다시 사람들을 평가하고 앞으로 만날 사람들을 바라보게 되리라.\n공부, 만들기, 코딩, 릴리즈, 론칭, 내 정체는. 커먼리습을 다시 잡았다. 그리고 뭐라도 만들었다. 힘들었다. 즐거웠다. 괴로웠다. 자본주의적으로 냉철하게 게을렀던 내가 싫어졌다. 어째서 내 기분이 그런지 너무나 잘 알고 있어서, 외면할 수 없었다.\n세상엔 해야할 일, 했었어야 했을거 같은 일들이 너무나 많다는걸 다시 깨달았다. 그일을, 그 프로젝트를 내가 혼자 힘들게 했었어야 했었다. 누가 뭐라고 하건. 그게 얼마나 세상에 뻔하디 뻔하게 널린거고, 돈이 안되는거고, 누구든 관심도 없고, 얼마나 멍청하고 시대에 뒤떨어졌든… 그런 것들이 어떤 이유로든 아무런 중요도 없다는걸 알게됐다.\n그래서 커먼리습을 선택했던거 같다. 황량하고, 거대하고, 지저분한, 엉망으로 보이지만, 무엇이든 내가 원하는걸 표현하고 그에 따라 무엇이든 바꾸고 다시 고치고 또 다시 고치고, 그에 따라서 그 자신도 변해가고.\n하지만 커먼리습이 아니더라도 마찬가지겠지. 혹은 마찬가지였으리라.\n마음 모든 면이, 어떤 일에 닿아도, 이상하게도 마음이 편안해졌다.\n해야할 일, 바라는 것, 생각하는 것, 바라보는 방법이 더욱 명확해졌다.\n다들 내가 누군지 내게 다가와 알려주려고들 했었는데, 정작 그러는 자기 자신이 어떤 모습인지 생각하지 못했었다. 웃겼었다. 그냥 이젠 그런 사람들에게 시간을 빼앗기고 싶지 않다.\n무엇을 위해서 그 수많은 이야기들을 듣고, 생각하고, 또 그걸 마음에 두고 살아왔는지, 굳이 더는 바보 같이 생각하고 마음에 두지는 않기로 했다.\n생각과 마음을 비우고, 언제나처럼 고요하게.\n이 마음이 아주 오래전부터 그대로 이 자리에 있었던 것만 같다. 그리고 앞으로도 계속 그럴 것만 같은 기분이다. 무슨 일이 있더라도 그렇게 하고만 싶다. 아마 다른 것들과는 달리 내게 무슨 일이 생기더라도 그럴만한 것이리라.\n\u0026#34;이젠 조금은 알 것 같다\u0026#34;.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/hololog-perl-cli-1st-rel/","title": "🐖 Hololog Perl/CLI 버젼",
     
     "tags": ["hololog", "perl", "exe", "par-packer", "memo", "programming", "opensource"],
     
 "description": "",
 "contents": " https://github.com/ageldama/hololog-perl-cli\n한줄씩 메모를 하는걸 좋아하고, 그냥 데스크탑에서 PDF을 읽거나 웹페이지를 읽으면서 어딘가에 생각난거나 이해한걸 필기하면서 진행하고 싶어서 만들었다.\n다음 트윗 타래에서 이야기한것처럼, 그냥 트위터 비밀계를 써도 괜찮지만, 그것도 너무 웹브라우져 열고 하다보면 산만해져서.\ntweet 1206138361968070656 처음 시작은 Unix/GNU cat 을 간단하게 터미널에서 쓰면 된다는 생각이 들었다.\n1 cat \u0026gt;\u0026gt; foo.txt ..그런데 유닉스가 아닌 사람들, 윈도를 쓰는 사람들은 어떻게 하지?\n1 copy con foo.txt ..사실 위와 같이 cmd.exe 에서 실행해도 되겠지만, 뭔가 그래도 윈도 사용자들이나 터미널 화면을 무서워하는 사람들이 저런거 좋아할까.. 싶어서 조금 생각.\nTk이나 wxWidgets 사용해서 간단한 GUI 프로그램을 만들어볼까.. 했는데, 너무 오버킬인거 같았다. 그렇게 복잡하게 만들면 그만큼 산만할거라고 혼자 생각.\n그래서 처음 생각은 간단하게 한줄짜리 Perl 프로그램을 트윗에 달아볼 생각이었다.\n1 perl -ne \u0026#39;BEGIN{$|=1;} print;\u0026#39; ..완벽하다. 그냥 loop구성도 펄이 알아서 해주고 autoflush 기능만 $| = 1 해서 켜줬다.\n그런데 조금 욕심이 더 생겼다…\n처음 스크립트를 시작할 때나 작성한 내용을 언제 작성한건지 시간을 기록하고 싶었다.\n그래서 조금 스크립트를 더 키웠다.\nlocaltime + POSIX: strftime 시간 남기기. 그러다가, 아예 프로그램으로 만들고 윈도용 .exe 실행파일을 제공하려고 완전히 뜯어고쳤다.\nIO::Handle 모듈 사용해서 입출력하고, autoflush제어. 기본 설정 이외에도 펄스크립트 수정해서 기능 동작 바꿀 수 있도록 설정 변수로 정리. 스크립트 인자로 다른 텍스트 파일에 저장 가능하도록 변경. 새로 시작할 때, 기존 텍스트 파일의 내용을 모두 보여줘서, 저번에 뭘 하고 있었는지 감을 잡을 수 있도록 하기. 예쁜 프롬프트, 저작권 및 경고 표시. 재밌게 작성했다.\nPAR::Packer 사용해서 윈도우용 실행파일을 만들고, VirtualBox 윈도우 이미지 안에서 실행하며 테스트.\n그리고 깃헙에 프로젝트랑 README 작성하고 릴리즈했다.\n재밌었다. 오랬만에 Perl을 써서 재밌는걸 만들어서 좋았다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/org-spreadsheet-and-babel/","title": "✳️ Org모드에서 스프레드시트 기능과 Babel 섞어쓰기",
     
     "tags": ["emacs", "elisp", "lisp", "spreadsheet", "tips", "babel", "org"],
     
 "description": "",
 "contents": " 쩌는 Org-mode Spreadsheet 소개 를 읽고 감명 받아서 따라해봅니다.\n다른 부분은 만족스러웠는데, 조금 복잡한 elisp식을 쓰기 귀찮으니, 미리 defun / defmacro 으로 정의해놓고 그걸 spreadsheet에서 불러 쓸 수 있을지가 궁금했습니다.\n그래서 다음과 같이 해보면 가능할지를 실험:\nOrg-Babel으로 원하는 함수를 정의한다.\n그리고 Org 파일이 로딩될 때 평가하도록 속성을 지정해놓는다. Spreadsheet에서 불러서 쓸 수 있는지 확인해본다. 우선 C-h a 을 눌러 vsum 을 검색해보니, defun calcFunc-vsum (\u0026amp;rest vecs) 으로 미리 선언되어 있는거 같았습니다. 이런 형태로 내가 정의하는 함수도 구현해보면 될까 싶습니다.\n이제부터 작성하는 내용은 HTML으로 렌더링된 내용과 실제로 제가 작성한 Org 파일의 소스에만 드러나는 내용이 다를 수 있으니\nhttps://raw.githubusercontent.com/ageldama/ageldama-github-io-hugo/master/content/posts/2019-12dec/org-spreadsheet-and-babel.org\n여기를 참고하며 비교해 읽으시면 좋을거 같습니다.\n간단한 함수 2개를 정의해볼게요: str-reverse, str-palindrome? Org-Babel으로 정의를 하고 테스트를 해보겠습니다.\n1 2 3 4 5 (defun str-reverse (s) (reverse s)) (message \u0026#34;Well, `str-reverse\u0026#39; has defined.\u0026#34;) ;; ~C-c C-c~ to run this snippet Well, ‘str-reverse’ has defined. –\u0026gt; 이렇게 #+CALL: str-reverse() 호출해도, 결과로 치환되어 표시됨을 위에서 확인 가능합니다.\n그리고 이 파일의 헤더에\n1 #+COMMENT: -*- eval: (let () (org-babel-goto-named-src-block \u0026#34;str-reverse\u0026#34;) (org-babel-execute-src-block)); -*- ..와 같이 지정해놓아서, 이맥스에서 이 파일을 열려고 하면, 이맥스는 지정한 코드 블록을 실행할 것인지를 확인할 것입니다. (그냥 무조건 실행하면 바이러스 같은걸 Org 파일만으로 얼마든지 만들 수 있을테니까요.)\n여기 https://www.reddit.com/r/emacs/comments/64jhlt/autoexecuting_code_in_org_mode/ 에 나온 방법을 사용했고, 다른 방법으로도 이렇게 Org 파일을 이맥스에서 여는 것만으로도 Org-Babel 블록을 평가하도록 하는게 가능한가 봅니다.\n그리고, defun str-reverse (s) 이 잘 동작하나 테스트 해볼게요:\n1 2 3 (list (str-reverse \u0026#34;foobar\u0026#34;) (str-reverse \u0026#34;\u0026#34;) (str-reverse \u0026#34;abc\u0026#34;)) raboof cba ..적당한거 같습니다.\n이번엔 defun str-palindrome? (s) 을 만들어 봅시다. 그리고 이번에는 testcase을 table으로 만들어 입력에 적용해보겠습니다.\nabc abcba madam zoom anna 1 2 3 4 5 (defun str-palindrome? (s) (string-equal (str-reverse s) s)) (mapcar (lambda (i) (mapcar #\u0026#39;str-palindrome? i)) inputs) nil t t t nil t .. 빈 문자열, abcba, madam, anna 은 palindrome이 맞으니 잘 동작하는거 같네요.\n이렇게 하기 위해서는 https://orgmode.org/worg/org-contrib/babel/intro.html#arguments-to-source-code-blocks 여기를 참고했습니다.\n테이블에 이름을 할당하고: #+tblname: foobar #+BEGIN_SRC 에 변수로 바인딩해주고: #+BEGIN_SRC emacs-lisp :var varname=inputs 코드 안에서 varname 을 리스트로 접근해 사용. 이외에도 R, Python등 실행한 결과로 생성된 파일을 참조해서 inline image으로 표시할 수도 있는거 같으니 정말 유용할거 같습니다.\n그래서 정의한 함수를 적용해볼 테이블입니다: 여러개의 Org-Babel 블록을 헤더에 추가하기 귀찮으니 str-reverse 만 시험해봅니다:\nString Reverse abc cba foobar raboof madam madam 쨔잔!1\n뭔가 잘 된거 같아 기쁩니다.\n느낀점 Org 모드에 있는 수많은 기능을 다 알고 매일마다 쓸 필요는 없겠지만,\n그래도 뭐가 있는지 한번 살펴보고, 이해하고 그때 그때 필요할 때 적용해 쓰는 습관은 나를 위해 좋을거 같다. 특히 다이어그램을 그리거나, 코드를 실행한 결과를 삽입하거나, 표를 그리거나 등등에 유용할만한 기능인데 활용을 안해오고 살아서 나 자신이 게으른거 같은 기분. 이맥스 세상은 역시 리습과 유닉스로 이루어져있다. 죽여주는 문서로 새로운 것을 배우는 것은 언제나 즐겁다.\n혹은 안다고 생각해왔지만 잘 이해 못하던 것을 조금이나마 이해가 깊어지는 경험. 고맙습니다. https://seorenn.github.io/ Footnotes 1 Org as a spreadsheet system: a short introduction의 Interactively edit formulas 섹션 참고, C-c = 눌러서 elisp식 입력.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/the-web-and-the-free-world/","title": "🧤 원하는 웹브라우져, 웹환경, 그리고 익숙하지만 싫은 어떤 신앙체계",
     
     "tags": ["web", "www", "paranoid", "internet", "capitalism"],
     
 "description": "",
 "contents": " 지금의 웹환경은 너무 과도한 치장, 보이는 이미지 중심이어서 딱 한가지 측면을 제외하고 모든 면에서 정말 끔찍하다는 생각이 들었다. 하긴 그러니 많은 사람들이 열심히 쓰는걸지도 몰라.\n그래서 정말 많은 사람들이 오히려 그런 치장, 자바스크립트로 덩어리진 화면을 로딩 하느라 보이지 않는 시간을 조금씩 모아서 낭비하고 있다는 생각도 든다. …그리고 또 그걸 만든다고 시간은 버려지고. 그렇게 모두가 하는 방식대로 하는 수 밖엔 다른 방법을 모르겠고, 그렇게 만들어가는 자바스크립트, 프론트엔드 개발자들의 시간도 마찬가지고.\n더욱이 그런 \u0026lt;예쁘고 조잡한\u0026gt; 화면이 정보의 전달도, 명확하게 사람들이 사용할 수 있는 화면을 만들어 준다고 생각지도 않는다. 컴퓨터에 조금 관심이 없는 사람도 조금 평균적인 기준이랑 다르거나, 그런 평균적인 기준을 따라가려고 흉내와 고생은 많이 했지만 그러지는 못한 사이트를 써보라고 한다면 당혹한다. 나는 그렇다. 차라리 단순한 텍스트 메뉴와 숫자나 방향키 입력을 통한 텍스트 메뉴가 더 명확하고 나을 지경인거 같다. 하지만 잘 디자인되고 개발한 화면에서는 정보 전달도, 사용성도 좋겠지만, …문제는 그런 사이트는 거의 본적이 없다.\n단 한가지 훌륭한 점은, 우리가 살고 있는 세계와 놀랍도록 닮았다는 점이다. 조잡하고 예쁘게만 보이려 노력하느라 대체 이 사이트가 뭔지 알기 너무나 어렵다. 가능한한 화려하게 보이려고 반짝거려서, 심지어 미니멀리즘을 이용해서라도 예쁨만을 추구한다. 순수한 아름다움에 추구가 나쁘지는 않겠지만, 나는 그 의도가 길거리 네온사인들이나, 전광판 빌보드들처럼 사람들을 반짝거리는 빛과 시끄러운 소리로 유인하고 정신을 아득하게 만드는데에만 치중한거 같다. 와! 밝고 화려하고 정말 좋은 소리가 들려온다. …하지만 내가 뭘 보고 들었는지 기억이 안나. 뭐 크게 중요한건 아니었던거 같아. 그냥 그걸 보고 넋을 잃고 있을 때는 멋지고 즐거웠던거 같기도해.\n어쩌면 원래부터 요점이 없기 때문에 예쁘게라도 보이려는걸지도 모르겠다. 그런 점도 우리가 사는 실제 세계와 닮아있다.\n하지만 삶은 그냥 실존으로 만족스러울 수도 있을테고, 오히려 본질을 추구하면 할수록 각자의 삶은 더 황폐해질거라고 생각한다.\n이런 사물, 목적성이 있는 매체에서는 본질의 추구가 꼭 나쁠까 싶다. 하물며, 지금에 내가 관찰하고 생각한 이러한 현상은 삶에 대한 관점과 웹이나 웹사이트, 웹브라우져 같은 사물에 대한 관점이 그러해야할 방향과는 완전히 반대로 우리에게 주어지는거 같다. 삶을 실존으로서 행복하게 받아들이고 살아갈 수 있도록 하기 보다는 삶에 절대적인 본질이 고정되어 있다고 믿도록 등떠밀고 그를 추구하도록 부추기는 분위기와, 그와는 정반대로 광고-유인매체일뿐으로 전락한듯한 웹환경은 그 본질이 그저 사람들을 현혹하고 생각을 하지 않고 따르도록 만드는데 집중하는데, 그를 위해 발전해온 방식은, 사실은 별거 없이 단순한, 전달하려는 정보나 통신내용, 즉 알맹이는 그다지 변한바 없이 단순하고 좋은데, 그를 포장해 더 복잡하고 거대한 무언가로 보이게 하는 쪽으로만, 이상한 형태로 발전한 것 같다.\n사실 그대로 단순하지는 않겠지. 예를 들어 보면, (10년, 아니 그걸로도 부족할 것 같다. 어쩌면 20여년전) 천재적인 발상을 해서 당시로서는 첨단기술을 응용하여 인터넷으로 사람들끼리 텍스트 메시지를 주고 받는 \u0026lt;메신져\u0026gt;를 내가 시작했다고 상상해보자. 처음엔 단순히 메시지를 주고 받기, 친구들의 추가와 삭제 같은 단순하고 당연한 기능들로 시작했겠지만, 금새 다른 기능이 가능하고 또 재밌을거라는걸 깨닫겠지. 예를 들면, 친구에게 내가 방금 인터넷에서 찾아낸 고양이 사진을 보내기, 그리고 친구가 그걸 다시 메신져에 들어와 확인하지 않아도 언제 어디서나 그 고양이 사진이 자신에게 도착했다는걸 즉시 알아차릴 수 있도록 알림음을 보내서 집중을 흐뜨러트려주기 등… 물론 고양이 사진으로 친구의 정신을 산만하게 해주는 일은 중요하다. 어차피 딱히 엄청나게 중요한 일이나 생각을 하고 있지도 않고 있을테니까. 그리고 더 나아가서 우리가 익숙한 이런 기능 예시에서도, 얼마든지 세부적인 사항들은 발전하고 더 세세해져 왔으리라 추측한다. 고양이 사진이 더 효율적인 크기의 파일으로 더 빠르게 지구 반대편으로 날아가도록 그러면서도 손실이 거의 느껴지지 않도록 압축을 하거나 이미지의 화질을 조정하거나, 수많은 사람들이 동시에 보내는 고양이 사진들을 무리 없이 배달하기 위한 노력과 자본의 투입을 효율화하기 위한 방법들이나… 그렇게 발전해왔으리라 생각한다.\n정말 고양이 사진을 주고 받는게 인류에게 중요한지 아닌지를 따지지는 않겠다. 그건 정말 중요할테니까.\n더 중요할 수도 있는 의문이겠지만, 짜증나게 서로의 집중력, 주의력을 뺏는 알림창, 알림음, 실시간 전송시스템 같은 것들이 사실은 그냥 전기에너지와 사람들의 수많은 시간과 신경줄을 쏟아부어서 우리가 열심히 생산해내는 공해라는 점에 대해서도 말하지 않겠다. 그건 너무 치사한 이야기일거 같아서.\n조금 예시를 들어보니, 단순하게 그 알맹이가 그대로만은 아니라는걸 알 수 있다.. 하지만 그럼에도 내 주장에 조금 더 고집을 부려볼 구석이 있을거 같다. 그런 세부사항들이 그렇게 발전한다고 외양도 함께 복잡해지고 조잡해져야할 이유가 있을까? 처음이나 중간과정에는 만든이들도 뭘 어떻게 해야할지 어려워서 복잡하겠지만, 사용하는 사람이나 만드는 이들 모두 익숙해져가고 점점 세련된 표현방법을 알아가면서, 복잡함을 잘 감추고 다시 요점에 충실한 명쾌한 디자인으로 발전하는게 당연하고 예측 가능한 발전방향이 아닐까.\n그렇다면, 우리가 언젠가는 세련되어질 중간 과정에 놓여 있다고 마음 편하게 가정하더라도, 현재의 사용하기에도 또한 만들기에도 복잡하고 화려함 이외엔 뭐가 있는지도 모르겠는 웹, 인터넷 환경을 어째서 계속 만들어 가는걸까? …소비자는 \u0026lt;언제나\u0026gt; (혹은 \u0026lt;언젠가는\u0026gt;) 맞는 선택을 해낼 것이라고 믿고 기다려야 할까? 이는 시장이 언제나 올바르고 맞는 방향을 추구한다는 맹목성에 근거를 제공하지 않나.\n그러니까 지금처럼 내버려두고 아무 생각 없이 계속해서 좋은게 좋은거지. 소비자들께서 원하신다잖아! 하면서 그에 맞춰 달려나가면 언젠가는 웹 접근성이나 모든게 좋아질까? …모르겠다. 나는 회의적이다. 우선 시장과 소비자가 언제나 무조건적으로 옳다고 말하는 사람치고 믿을만한 사람은 없다고 생각하는 내가 문제인거 같다. 왜냐하면 그런 발언을 하는 사람은 시장에서 \u0026lt;자유롭게\u0026gt; 돈을 가진만큼 횡포를 부릴 권리가 있다고 믿는 이들이었고, 그렇게 자신이 휘둘러와서 앞으로도 그러고 싶은데 못 그럴까봐 걱정하시는 고귀한 분들이나, 아니면 앞으로 그러고 싶은 꿈고 희망으로 부풀어 있는 이거나, 그것도 아니면 그런 말들이 \u0026lt;자유\u0026gt;라고, 하지만 누구를 위한 자유이고, 누구에게서 자유와 안전, 존엄, 돈, 시간 등등을 뺏어와서 구현되는 자유인지를 잘 몰라서 무조건적으로 좋다고 착각하는 사람들이기 때문이다.\n소비자와 시장은 언제나 옳다. 그들이 광고를 올리는 사람의 주머니를 불려주고, 한편으론 그러면서 그들의 회사를 위해 노동하며 가치를 창출해주면서도 생산수단을 공유 받지 못한채, 일한 만큼 값어치도 못되는 월급을 받으며 만족하거나, 어쩌면 아주 운이 좋다면 미래에 있을수도 있고, 또 더욱 운이 좋다면, 가치가 있게 될지도 모르는 스톡옵션을 상상하며 말도 안되는 조건에 노동하며 달려갈 때, 거기에 더해서 그 회사에 노동자이면서도 또한 소비자로서 더할 나위 없는 기여를 하기 때문에. …소비자와 시장은 항상 옳다고 말해져야 하고, 그렇다고 믿어져야 한다. 아주 소수는 정말로 그렇게 생각하고 느낄 수 밖에 없고, 절대 다수는 그렇게 믿고 말하도록 강요 받고, 자신도 그렇게 믿어야만 뭔가 가슴 한구석이 덜 아파올테니까.\n웹과 웹기술에 대한 사람들의 생각을 보고 듣고 있으면 어떤 오컬트 숭배라는걸 느낀다. 더 빠르고 더 복잡한 웹브라우져를 위한 프로그래밍언어와 프레임웍… 이런 부분은 오히려 건강하고 이성적이지 않은가 싶을 정도로. …그렇게 느끼는 부분은 화려함, 혹은 그 반대로 보이지만 사실은 동일한 목적에서의 미니멀리즘을 추구한다는 시각요소, 더 나은 사용성, 사용자 경험을 이야기하지만 실상은 오히려 사용성은 더 나빠지고 복잡해져만간다.\n사용자의 경험이랑 정반대로 나아가는데 신기하게도 어떻게 웹개발자들은 모를 수 있고, 더욱이 왜 그렇게만 만들어갈까?\n최근에 사용한 새로운 웹페이지가 시각장애인이나 작은 단위의 움직임으로 세밀한 마우스 조작이 어려운 사람을 위해 배려해 만들어 놓았을까? 아주 아주 아주 운이 좋다면 조금은 그런 요소들이 들어가 만들어져 있겠지만, 그것도 공공기관 웹페이지거나 한 등등의 이유로 아주 요식적인 형태로만 구현해놓고, 실제로는 정말로 사용 가능한지 검증절차를 거치지 않았으리라고 나는 매우 확신한다.\n그 이유를 묻는다면, 소비자를 탓하기 좋은 형태로 대답을 던져줄 것 같다. 그런 상황에서 접근하는 사용자가 거의 없으니 그렇게 배려 없이 만들어놓고 그렇게만 유지보수한다. 오지도 않는 손님을 배려할 필요는 없지 않겠는가? 하지만 진짜 이유는 그렇게 해서 더 돈을 써야 하는게 이유겠지. 소수 사람들을 배제하고 그래서 사용할 수 없게 해놓고 그들이 쓰지 않기 때문에 배려할 수 없다고 말한다.\n마찬가지 이유일거 같다. 이렇게 만들어야만 사람들이 좋아할거라는 공유된 어떤 재밌는 감각과 취향이 있다. 그리고 이런 공유된 감각은 아주 간단하게 검증이 가능하다. 왜냐하면 내가 보기에 무엇이 좋아보인다면 그건 아주 보편타당한 것이기 때문이다. 자기 자신이 왜 그걸 좋아하고, 어디서 많이 경험했고, 단지 익숙하기 때문에 좋아하고, 그게 왜 좋은지, 정말 좋은지는 생각할 필요를 느끼지 못한다. 그리고 모두가 그렇기 때문에 다른 이야기를 하는 사람은 차가운 비웃음의 강물에 던져 그 의견을 익사시킨다.\n그럼에도 나는 텍스트 위주의 사용자 인터페이스, 과도하지 않은 이미지와 자바스크립트를 제한적으로만 적용하여, 검색엔진, 텍스트를 소리로 읽어주는 프로그램(TTS)을 고려한 웹사이트를 만든다면, 혹은 그런 웹브라우져가 있다면 현재의 웹브라우져와 웹사이트들에 비해서 절대대다수에게 훨씬 더 나은 가치를 제공할거라고 생각한다. 일부 소수자들에게만 그런 접근가능성이 열리는 것 뿐만이 아니라, 더 많은 사람들에게 지금과는 다른 편안함과 또 다른 가능성을 열 수 있을거라고 상상한다.\n하지만, 누구나 알고 있는거 같은 Fortune 100대 기업 어쩌고의 웹사이트들은 그렇지 않을 것이다. 알고 있다. 그리고 우리가 알고 있는 절대적으로 성공적인 기업과 웹사이트들은 그렇지도 않고, 그럴거면 어째서 절대적인 위대한 웹개발자인 누구누구는 왜 그렇게 개발을 했을까. 글쎄, 난 잘 모르겠다. 나름의 이유가 있었겠지 생각하고 싶다. 하지만 그들이 그렇다고 나와 우리가 지금부터도 계속 그래야 한다는 생각은 근거로 삼을 수 없다고 생각한다. 나는 그런 모든 신화적인 성공 스토리, 미신, 이래야만 한다는 믿음, 통계, 분포, 트렌드 등등을 거슬러서 웹브라우져와 웹사이트를 설계하고 만들었으면 좋겠다고 말하고 싶다.\n아마도 자신들도 그렇게 믿으며 헌신적으로 그 어떤 특정한 미신이나 종교에 빠져 살겠지 싶다. 그러니 그런 사람들일수록 더욱 더 권위적인 배경이나 경력을 추구하고, 다수를 위한다는, 그게 자랑스러운 옳은 일이라는 대의명분 등에 맞춰 자신의 삶을 다바쳐 일한다고 생각할거라고 생각한다. 그리고 그 화려함에, 삶에 절대적 가치를 추구하는 이들과, 또 빛과 소리에 이끌려 살아가는 더 수많은 사람들이 있을거고.\n그래서 그런 사람들은 다른 사람들에게 세상에 절대적인 무언가, 혹은 당신은 잘 이해하지 못하지만 명백한 진리가 있는 것처럼 설파한다. 현대에는 주로 외교적, 정치적인이라는 말을 붙이거나, 금융, 경제, 혁신, 창업, 가치, 본질, 기업가정신, 화술, 대인관계, rhetoric, 원칙, 가치, 투자, 투자방법론 등등으로 부르는거 같다. 그리고 그런 것들을 중심으로 인터넷에는 오늘도 내가 지금 쓰고 있는 이 글보다 정말로 미친 이야기들이 끝도 없이 퍼져나간다.\n그런 이야기들은, 그래프와 숫자들을 보이며 이야기한다. 이제 비트코인의 시세가 반등할거고, 가치가 얼마일거고, 등등. 글쎄, 제대로 맞는 경우도 없었던 것 같고, 저런 이야기가 근거라니. 저거 그냥 도박사의 오류인 이야기이지 않나.\n뭐가 아이러니 하냐하면, 웹과 마찬가지로 유물론자에게서 나왔을거 같은 창조물인 비트코인이 저런식으로, 그것마저도 웹과 아주 비슷하게, 오히려 제대로 오해되어, 세상의 아주 몇몇 사람들만을 위한 무언가로 변하여 오컬트적 맹신과 신앙, 경외의 대상, 그런 이상한 신앙의 대상이 되었다는 점이 아이러니하다. 그리고 오늘도 사람들은 그런 절대적 진리이라고 하며, 영원불변하다는 그런 가치체계를 다같이 믿어주며 확고하게 다져나간다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/dissect-radio-gaga/","title": "🦟 radio-recorder 프로젝트 설명",
     
     "tags": ["radio-gaga", "radio", "recording", "perl5", "sqitch", "postgresql", "mplayer", "perl", "programming"],
     
 "description": "",
 "contents": " 2년전쯤에 한국 라디오를 혼자 듣고 싶었었다. 하지만 시차가 많이 나는 지역에 살았었다. (8시간 정도 느림)\n그래서 한국 인터넷 라디오를 녹음해서 개인적으로 들을 수 있다면 좋겠다는 아이디어로 작업했던 프로젝트 소스코드를 공개한다.\nhttps://github.com/ageldama/radio-recorder\n방송사의 인터넷 라디오를 녹음 하는 스크립트는 커밋에서 제외하고 공개한다. 이는 방송사에게 문제가 될 수 있으므로 개인적으로 알아내서 사용하고 타인과 공유하지 않기를 바란다.\n프로그램 구성 cron 서버 지정된 시간에 녹음/인코딩 스크립트를 실행하는 스케쥴을 담당한다. 오래된 임시 파일 정리 등등도. 한국의 시간대와 내가 있는 시간대가 달라서 다른 cron scheduler을 쓰지 않고 그냥 짰었던거 같다.\n그럼에도 결국 그냥 KST 시간대로 사용자 계정에 설정해서 돌린거 같은데? ㅋ https://github.com/ageldama/radio-recorder/blob/master/cron.pl\nSchedule::Cron (Metacpan) webapp 서버 녹음한 파일과 녹음 목록을 RSS feed을 생성해서 팟캐스트 프로그램이 접근할 수 있도록 해주는 웹애플리케이션. https://github.com/ageldama/radio-recorder/blob/master/webapp.pl\nhttps://metacpan.org/pod/Mojolicious::Lite : 웹프레임웍으로 가볍게 써봤다.\nhttps://perldoc.perl.org/perldata.html#Special-Literals __DATA__ 리터럴 문자열을 템플릿으로 사용해서, 별도 템플릿 파일 없이 그냥 스크립트 안에 모든걸 때려넣었다. ..등등의 모듈을 사용했다. 필요한 프로그램, 의존성 등 mplayer, sox, lame, gnu grep, gnu sed, gnu xargs 등을 사용해서 적절하게 쉘스크립팅을 활용. 대부분은 어차피 Perl에서 실행을 제어하지만. 그리고 파일시스템에 인코딩한 파일을 저장해놓고, 메타데이터는 PostgreSQL에 저장했다. 특정 웹프레임웍, 개발프레임웍보다 마이그레이션, DB접근, 객체시스템 등등 모두 MetaCPAN에서 검색하고 하나씩 찾아서 돌려봤던거 같다. Mplayer으로 Wave파일으로 덤프 내리기 mplayer에서 -ao pcm 으로 실행 옵션을 지정하면 지정한 wave파일으로 저장해준다.\nhttps://superuser.com/questions/53683/mplayer-ao-pcmfile-c-x-wav 녹음을 마치고 mplayer의 gracefully한 종료를 위해서, slave mode으로 실행하고, pipe file으로 키보드 커맨드를 보내 종료.\nhttp://www.mplayerhq.hu/DOCS/tech/slave.txt : mplayer -slave -input file=\u0026lt;/tmp/fifofile\u0026gt; \u0026lt;movie\u0026gt; 그렇게도 안 종료하면 SIGINT 보내서 종료. IO::Async (MetaCPAN) 모듈을 사용해서,\nmplayer 프로세스를 PID으로 모니터링하고 필요하면 재시작하거나, 종료 시그널을 보냈다. IO::Async::Timer::Countdown 이용해서 녹음 시간이 끝나면 종료하도록 만들었다. https://github.com/ageldama/radio-recorder/blob/master/lib/Proc/RestartAndTimeout.pm 프로세스 관리에 시작할 때 처음엔 조금 신경을 많이 써서 작성했다.\nIO::Async 프레임웍이 펄에서 비동기 입출력을 잘 지원해줘서 편안했다. 조금 달라서 익숙해지는데 연습이 필요했었지만. https://github.com/ageldama/radio-recorder/blob/master/lib/RadioGaga/Steps.pm#L110 여기에 작성했듯이,\n외부 프로세스 관리를 패턴화하고, 상태를 체크하거나, 단계별로 종료를 하는 부분을 분리해서 sub 을 지정했다. Busy polling을 간단히 구현했다. https://github.com/ageldama/radio-recorder/blob/master/lib/Timeout/Wait.pm Database Migration: Sqitch Sqitch: DB Migrator https://github.com/ageldama/radio-recorder/tree/master/sqitch/pg 테이블이 복잡하지도, 많지도 않다. 그냥 하나.\n그럼에도 그냥 공부하는셈치고, 적용해봤다. 다른 언어로, 다른 프로젝트를 할 때도 다시 사용하고 싶은 생각이다. RSS XML 생성 Podcast::Rss::Generator 마음에 드는게 MetaCPAN에 없어서 간단히 만들었다.\nPerl 5스럽게 인라인 HEREDOC 문자열 + Template::Toolkit (MetaCPAN) 사용.\nDB \u0026lt;-\u0026gt; Object Mapping https://github.com/ageldama/radio-recorder/blob/master/lib/RadioGaga/Schema/Result/Recording.pm DBIx-Class (MetaCPAN) 사용했다. 좋았던 점: 객체시스템, 펄이라 가능한 유연함.\nDBIx-Class 이든, 직접 내가 package + bless 으로 만든 객체든, 다같이 섞어서 쓰기 좋아서 편안했다. Moose, Moo, Mouse등등 다양한 OO-framework이 CPAN에 있지만 다들 대부분은 잘 호환되고 하니까. CPAN에 방대한 모듈들.\nIO::Async, Mojolicious, Sqitch..등등\n그냥 언어 자체가 변하지 않아도, 펄5 자체가 유연해서 IO::Async와 같이 확장이 가능한걸 보면 마음이 편안하다. ..이외에도 별별 잡다한 기능들을 생각할 때마다 검색해보면 항상 있어서 편안했다. 아쉬운 점: 테스팅과 큰 메인 스크립트 이 스크립트 에 왠만한 로직을 다 넣었던게 조금 후회스럽다. 테스트 코드를 착실하게 작성하고 작업해 나갔었다면 작업이 더 쉬웠었을거 같다.\n더군다나 펄에는 좋은 Mocking, Testing 라이브러리, 프레임웍이 많은데도 그런걸 잘 활용하지 못했어서 아쉽다. 깜빡하고 Twitter API 키 커밋했다. 하지만 방금 지웠다. 휴우… \u0026lt;2019-12-11 Wed 17:24\u0026gt; "},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/foo/","title": "🧁 Org 파일으로 Hugo 포스팅 테스트",
     
     "tags": ["org", "emacs", "hugo", "blogging", "blog", "blogging"],
     
 "description": "",
 "contents": " 적당히 잘 동작하는거 같으니 앞으로는 그냥 혼란스러운 Markdown 대신에 그냥 Org 파일으로 블로깅 하며 될거 같다. 행벜.\n예전 버젼 Hugo에서는 지원을 제대로 못하던거 같은데, 어느샌가 업데이트 하니까 되는거 같아서 그냥 슬그머니 쓰기로. https://gohugo.io/content-management/formats/\n기존 마크다운들도 인라인 이미지 문법을 바꾸고, ToC 표시 설정도 바뀌어서 조금 변경.\n아쉬운건 여전히 Org 파일에서 ToC 지원은 빠져 있는거 같아서… https://github.com/snosov1/toc-org 설치해봤다. 그냥 고민할 필요가 없었구나. ㅋ\n제일 좋은건 code syntax highlight이 예뻐졌다.\nTable of Contents \u0026lt;– :TOC: –\u0026gt; foobar\nsubsection a subsection b another section + tables yet another section Footnotes foobar 123\n어엉 아ㅣ머이ㅓ아미ㅓ암\n이어미어머ㅏㅣ 1 (do-sth-useful t) 심연을 오랬동안 깊이 들여다보면, 심연도 내게 반한다.\nsubsection a 123\nsubsection b b\nanother section + tables …적당히 잘 동작한다.\n테이블 예시:\n이름 국어 수학 과학 오컬트 ㅂ 0 1 2 99 yet another section …?1\nFootnotes 1 footnote!\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/cl-state-machine-1st-release/","title": "🗳️ First release of cl-state-machine",
     
     "tags": ["programming", "commonlisp", "common-lisp", "lisp", "opensource", "state-machine", "cl-state-machine"],
     
 "description": "",
 "contents": "Made a small state machine library/DSL in/for CommonLisp.\nhttps://github.com/ageldama/cl-state-machine\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-12dec/tips-ecl-clisp/","title": "👩‍🦽 커먼리습 설정하기, ASDF 시스템 코드를 받기",
     
     "tags": ["commonlisp", "common-lisp", "lisp", "asdf", "quicklisp", "ecl", "clisp"],
     
 "description": "",
 "contents": "1. ASDF을 최신 버젼으로 설정한다 (이부분에서 많이 고생했는데) SBCL와 다르게 CLISP, ECL 은 최신 버젼의 ASDF을 내장한걸 패키징해놓지 않았다.\n대부분은 문제가 없이 동작하지만, 내가 작성한 커먼리습 시스템에서 실행파일을 빌드할 때 문제가 많았다.\nASDF 의 최신 버젼을 git clone 해서 적당한 디렉토리에 받는다. https://common-lisp.net/project/asdf/ make을 내려받은 ASDF 디렉토리에서 실행한다. 실행하면 build/asdf.lisp 파일으로 한 파일으로 뭉쳐서 로딩하게 편안한 파일을 생성해준다. 내 커먼리습 구현체의 시작설정파일 맨 앞에 다음처럼 추가한다. (load \u0026quot;~/local/asdf/build/asdf\u0026quot;) 여기서 나는 $HOME/local/asdf/ 에 ASDF을 받았다고 가정. 그리고 asdf.lisp 파일이더라도, 마지막에 .lisp 확장자는 생략했다. ECL은 $HOME/.eclrc CLISP은 $HOME/.clisprc.lisp 그리고 중요한데, 그 다음에 Quicklisp 초기화 내용이 오도록 한다. Quicklisp을 초기화하기 전에 ASDF 최신 버젼이 로딩되어 있는게 더 나을테니까. 어차피 위의 (1~3)의 순서대로 ASDF 먼저 설정한 다음에 Quicklisp설치한 다음에 ql:add-to-init-file 실행하면 이런 순서로 추가해준다. \u0026hellip;별거 아닌데, 이거 때문에 빌드한 결과 실행파일이 이상해서 좀 고생했다.\n참고: https://github.com/ageldama/cl-state-machine/blob/master/build-tamagochi-exec-ecl.sh\n2. ASDF 로딩하는 디렉토리를 알거나, 설정한다 예전에도 언급한 내용이다.\nASDF 매뉴얼에서 나오는 항목들을 잘 읽어본다: 내 마음에 드는 위치에서 로딩하도록 설정하거나, 기본값으로 어디에서 로딩하는지 이해한다. (매뉴얼) 기본 검색 위치 : https://common-lisp.net/project/asdf/asdf.html#Controlling-where-ASDF-searches-for-systems (매뉴얼) 설정 방법 : https://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems 내 설정 파일 : https://github.com/ageldama/configs/blob/master/emacs/sly/source-registry.conf 3. 처음 받은 ASDF시스템은 Quicklisp으로 로딩한다 조금 이상하다고 생각하는 부분.\n처음으로 asdf 시스템인 프로젝트를 체크아웃 받아서 로딩하거나 테스트를 실행할 때,\n(asdf:load-system :foobar)와 같이 로딩하려 하지말고,\n(ql:quickload :foobar)와 같이 Quicklisp을 이용해서 로딩해라. 어차피 Quicklisp이 ASDF이랑 연결되어 있어서 로딩하고, 또 해당 시스템이 참조하는 Quicklisp 의존성들도 이렇게 해야지 제대로 로딩.\n그리고 테스트 시스템도 마찬가지로 (ql:quickload :foobar-tests)와 같이 로딩한 다음에야 (asdf:test-system :foobar) 혹은 (asdf:test-system :foobar-tests)으로 실행해라.1\n끝 https://github.com/ageldama/cl-state-machine/ 작업하며 많은 팁들이 쌓인거 같다. ASDF와 테스트suites 연결하기, ASDF으로 실행파일 만들기 같은 것들에 대한 노하우도 많이 쌓았다.\n이런 저런 노하우들을 정리해서 블로깅을 조금씩 해나가야지.\nfoobar 의 defsystem 선언에 :in-order-to ((test-op (test-op \u0026quot;foobar-tests\u0026quot;)))으로 테스트 시스템과 연결되어 있다면, (asdf:test-system :foobar)해도 자동으로 foobar-tests의 테스트들을 실행하겠지.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-11nov/the-dark-side-of-cl-equality/","title": "🥝 (Common Lisp의 어두운 면) Equality",
     
     "tags": ["commonlisp", "common-lisp", "programming", "lisp", "equality", "same", "samesame", "the-dark-side-of-common-lisp"],
     
 "description": "",
 "contents": "오늘은 커먼리습의 어두운 면을 이야기 해볼까. 보통 나는 리습 팬보이니까 리습에 대해 불리한 이야기는 잘 쓰지 않는거 같아서 한번 써보기로 생각했다. 그리고 놀랍게도 이 글의 끝에 가서는 다시 이런 리습의 결점을 리습의 위대함으로 승화시키는 단계까지 끌어가 보도록 하려고함.\n뭐 커먼리습의 CLHS - HyperSpec을 읽다보면 비슷한데 아주 약간씩 미묘하게 달라서 지원하는 것들이 있다:\nlet Special Operator LET, LET* Special Operator FLET, LABELS, MACROLET map Function MAP Function MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON Function MAP-INTO prog Macro PROG1, PROG2 Special Operator PROGN Macro PROG, PROG* Special Operator PROGV \u0026hellip;그밖에도 좀 더 있을듯? 이렇게 나열해 놓으면 꽤 무서워 보이지만, 막상 차이를 이해하면 별로 복잡하지도 않아서 나중엔 더 편안해진다. (정말로)\n이 글에서는 위에 나열한 것들의 차이를 정리하지 않겠다. 그냥 예시로만 보여봤다. 이번에는 값의 동치관계에 대해서만 집중하겠다.\n1. 같은 값 비교 연산: 숫자, 심볼, 같은 객체를 참조하는지: EQ 오늘의 주제는 바로 \u0026lsquo;같은 값 비교 연산\u0026rsquo;이다. 혹은 동치관계연산자(同値關 係\u0026hellip;, Equality operators).\n가장 간단한 =, /= 부터 시작해볼까:\nFunction =, /=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= ..숫자값, 그러니까 System Class NUMBER 의 하위타입들만 적용됨. 왜 NUMBER 타입에 대해서만 한정지어 말했냐하면:\n1 2 (= :foo :foo) ; Debugger entered on #\u0026lt;TYPE-ERROR expected-type: NUMBER datum: :FOO\u0026gt; ..처럼 Lisp에서 가장 Primitive한 값 타입의 하나인 심볼에 대해서도 완강히 지원하지 않으시기 때문이다.\n오.. 마이 ㅂㅋㄱ\u0026hellip; 그럴거 같애서 이제 조금 더 길이가 긴 연산자가 필요해진다.\nFunction EQ 숫자는 물론 심볼도 비교 할 수 있다. 이는 숫자, 심볼 비교에서 두 값이 완전히 같은 객체, 즉 참조가 같다는 원리를 이용한 것이다. 테스트해볼까:\n1 2 3 4 5 6 7 8 (eq (+ 1 2) 3) ; =\u0026gt; T (eq :foo :FOO) ; =\u0026gt; T (eq \u0026#39;bar \u0026#39;BaR) ; =\u0026gt; T 적당하다. 하지만:\n1 2 3 4 5 6 7 8 9 10 11 (eq #\\a #\\a) ; =\u0026gt; T (eq #\\a #\\A) ; =\u0026gt; NIL (eq \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34;) ; =\u0026gt; NIL (eq \u0026#39;(a b) \u0026#39;(a b)) ; =\u0026gt; NIL 그렇다. System Class CHARACTER인 #\\a 도 대소문자 구분이 생기자마자 이 연산자로는 같지 않다.\n문자의 대소문자 이야기는 잠깐 접어놓고, 나머지 문자열, 리스트에 대해서도 이런 결과를 얻은 이유를 설명하자면: EQ은 정의 그대로, \u0026ldquo;메모리 상에서 같은 값의 참조인지\u0026quot;만 판단하기 때문이다.\n심볼과 키워드 심볼은 같은 값이 여러개 생기지 않고 항상 유일하게 하나만을 공유한다는걸 보장하니까 당연히 EQ으로 비교가 쉽다.\n그리고 숫자의 경우에도 마찬가지일거 같다. 숫자의 경우 추측을 해보면, 이것도 심볼과 마찬가지로 메모리 상에서 레퍼런스에 담긴 값이 같은 값일거 같다. 왜냐하면, 숫자 값은 그 자체로 레퍼런스 값 그 자체로 저장되어 있을거라고 생각한다. (예: Tagged Pointer) 그리고 이런 tagged pointer의 아이디어가 처음 생긴 것도 리습이고, 그런 전통에 따라 현재는 분리되어 저장하더라도 EQ에서 그런 것처럼 동작하게 만들어 놓았으리라.\n그래서 단순히 참조포인터에 저장하기 어려운 복합적인 구조를 갖는 복소수 값은 NUMBER타입임에도 EQ으로 같은지 알 수 없다.\n1 2 (eq #c(1 2) #c(1 2)) ; =\u0026gt; NIL 다만, 문자열이나 리스트, cons의 경우에는 같은 값을 갖는 다른 메모리 위치이라면 EQ은 다른 값이라고 말한다.\n1 2 3 4 5 6 7 8 9 (let ((a \u0026#39;(a b c)) (b \u0026#39;(a b c))) (values :same-ref? (eq a a) :equal-val? (eq a b))) ; =\u0026gt; ; :SAME-REF? ; T ; :EQUAL-VAL? ; NIL 이런 값들에 대해서는 순서를 갖고 하나씩 어떻게 비교해야할지 이야기 해나가겠다.\n2. \u0026ldquo;한 걸음 더\u0026rdquo;: EQL EQ보다 한 글자 더 길어진 Function EQL.\nEQ의 모든 비교를 동일하게 수행. 1. 같은 참조인지를 체크: 심볼, 키워드, 모든 값에 대해서. 1. 숫자에 대해서도, 같은 타입, 같은 크기의 값인지를 비교. 거기에 더해서, CHARACTER도 비교를 할 수 있지만, 1. 대소문자를 구분한다. 확인해보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (eql #\\a #\\A) ; =\u0026gt; NIL (eql #\\a #\\a) ; =\u0026gt; T (eq #c(1 2) #c(1 2)) ; =\u0026gt; NIL (eql #c(1 2) #c(1 2)) ; =\u0026gt; T (eql #c(1 2.0) #c(1 2)) ; =\u0026gt; NIL EQ 보다는 조금 더 비교가 가능함을 확인했다. 같은 크기를 갖는 #c(1 2)의 서로 다른 복소수 참조에 대해서 비교를 잘 해낸다.\n그러나 여전히 cons, list, string등 조금이라도 복합적인 값은 비교를 하지 못한다.\n1 2 3 4 5 6 7 8 (eql \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34;) ; =\u0026gt; NIL (eql \u0026#39;(1 2 3) \u0026#39;(1 2 3)) ; =\u0026gt; NIL (eql \u0026#39;(a . b) \u0026#39;(a . b)) ; =\u0026gt; NIL 3. 약간 더 구조가 있어도 지원: EQUAL 이제서야 스펠링을 그대로 타이핑하는 연산자다. 그리고 그만큼 = -\u0026gt; EQ -\u0026gt; EQL -\u0026gt; EQUAL 순서로 길어져서인지 꽤 원하는대로 비교를 해준다.\nFunction EQUAL\n대부분 잘 비교해준다. 숫자, 심볼, 키워드, 문자열, 리스트, cons, pathname.\n1 2 3 4 5 6 7 8 9 10 11 (equal \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34;) ; =\u0026gt; T (equal \u0026#34;foo\u0026#34; \u0026#34;FOO\u0026#34;) ; =\u0026gt; NIL (equal \u0026#39;(a b c) \u0026#39;(a b c)) ; =\u0026gt; T (equal \u0026#39;(a . b) \u0026#39;(a . b)) ; =\u0026gt; T \u0026hellip;그런데 여전히 struct, CLOS object, array, hash table 값들은 비교를 못한다. 반대로 말해서 비교 가능한 값들은 cons을 기반으로 이루어졌거나 비교적 선형적인 문자열만이라고 볼 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;;; Array (equal #(1 2 3) #(1 2 3)) ; =\u0026gt; NIL ;;; Hash Table (let ((a (alexandria:alist-hash-table \u0026#39;((apple . red) (yellow . banana)))) (b (alexandria:alist-hash-table \u0026#39;((apple . red) (yellow . banana))))) (equal a b)) ; =\u0026gt; NIL ;;; Struct (defstruct point-2d x y) (let ((a (make-point-2d :x 1 :y 2)) (b (make-point-2d :x 1 :y 2))) (equal a b)) ; =\u0026gt; NIL ;;; NOTE: CLOS Object은 어차피 Struct와 Slot을 처리하는 방식이 같을테니 생략. (참고: 예제의 작성 편의를 위해 Alexandria 라이브러리를 사용해서 Alist을 hash table으로 바로 표현했다.)\n4. 완전체?: EQUALP 그래서 Function EQUALP 까지 커먼리습에는 지원한다.1\n1 2 3 4 5 6 7 8 9 10 11 12 (equalp #(1 2 3) #(1 2 3)) ; =\u0026gt; T (let ((a (alexandria:alist-hash-table \u0026#39;((apple . red) (yellow . banana)))) (b (alexandria:alist-hash-table \u0026#39;((apple . red) (yellow . banana))))) (equalp a b)) ; =\u0026gt; T (let ((a (make-point-2d :x 1 :y 2)) (b (make-point-2d :x 1 :y 2))) (equalp a b)) ; =\u0026gt; T 이제는 모두 다 평범한 기대대로 비교한다.\n5. 문자, 문자열 문자값(Character) Function CHAR=, CHAR/=, .., CHAR-EQUAL, CHAR-NOT-EQUAL, .. 문자열(String) Function STRING=, STRING/=, .., STRING-EQUAL, STRING-NOT-EQUAL, .. 설명하지 않겠다.\n다만, -=-suffix인쪽은 (더 짧으니까) 대소문자 구분을 하고, 더 긴 이름이 대소문자를 무시하고 비교해준다.\n1 2 3 4 5 (string= \u0026#34;abc\u0026#34; \u0026#34;ABC\u0026#34;) ; =\u0026gt; NIL (string-equal \u0026#34;abc\u0026#34; \u0026#34;ABC\u0026#34;) ; =\u0026gt; T 6. 하지만 나는 더 특별하고 싶다: EQUALS EQUALP면 이름도 길어질만큼 충분히 길어진거 같고, 왠만한 경우를 다 비교하는거 같은데 굳이 왜 EQUALS은 뭐고 이런게 필요한가?\n하지만 이런게 필요할 때가 있긴 하다 \u0026ndash;\u0026gt; Generic Equality and Comparison for Common Lisp\n다른 프로그래밍 언어를 경험해봤다면 한번 정도는 봤었을 다음과 같은걸 하기 위해서:\nPython: __eq__ Java: equals() 그렇다. 기본적으로 CLOS 객체를 만들거나, Struct을 정의해도 커먼리습은 모든 슬롯(slots)와 타입을 비교해서 같은지를 자동으로 비교해주는 EQUALP을 제공해서 보통은 파이썬이나 자바처럼 이런 메서드를 일일이 작성할 필요가 없다.\n하지만 내 struct이나 CLOS객체에 특정 슬롯을 비교에서 제외하고 싶다면, 정말정말 유니크한 특별한 비교 연산을 지정해서 구현하고 싶다면 EQUALS을 쓴다.\nEQUALS은 Quicklisp으로 간단히 불러올 수 있다. (ql:quickload :equals)\n그리고 Inspector으로 #'EQUALS:EQUALS을 살펴보면 다음과 같이 설명한다:\nName: EQUALS:EQUALS Arguments: (EQUALS::X EQUALS::Y \u0026amp;REST EQUALS::KEYS \u0026amp;KEY EQUALS::RECURSIVE \u0026amp;ALLOW-OTHER-KEYS) Documentation: The EQUALS generic functions defines methods to test for \u0026rsquo;equality\u0026rsquo; of two objects a and b. When two objects a and b are EQUALS under an appropriate and context-dependent notion of \u0026rsquo;equality\u0026rsquo;, then the function returns T as result; otherwise EQUALS returns NIL as result.\nIf the argument recursive is T, then EQUALS may recurse down the \u0026lsquo;structure\u0026rsquo; of a and b. The description of each known method contains the relevant information about its recursive dependent behavior.\n특별한 파라미터 없이 그냥 2개의 X, Y을 받고, :RECURSIVE T 정도의 키 파라미터만 지정이 가능한 generic function이다.\ngeneric function이기 때문에, 내가 원하는 클래스, struct등에 대해서 type specialize해서 구현하면 된다.\n기본적으로 hash table, CLOS object, struct, string, array, character, cons, number에 대해서 모두 기본 구현한 메서드들을 제공한다.\n하지만 hash table에 대해서는 어차피 specialization이 필요 없을테니 그냥 EQUALP을 쓸 것을 권한다.\nCLOS object, struct에 대해서는 어차피 기본 구현 내용이 EQ을 이용한 완전히 같은 참조인지를 보는 것이기 때문에 EQUALP을 쓰길 권한다.\n아니라면 다음과 같이 간단한 메서드 구현을 통해 해결한다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 (defmethod equals:equals ((x point-2d) (y point-2d) \u0026amp;rest args) (declare (ignore args)) (equalp x y)) (let ((a (make-point-2d :x 1 :y 2)) (b (make-point-2d :x 1 :y 2))) (equals:equals a b)) ; =\u0026gt; T (let ((a (make-point-2d :x 1 :y 2)) (b (make-point-2d :x 2 :y 2))) (equals:equals a b)) ; =\u0026gt; NIL 혹은 아예 Java, Python에서 이를 직접 구현하듯이 할수도 있다:\n1 2 3 4 5 6 7 8 9 10 11 (defclass person () ((name :initarg :name :accessor person-name) (age :initarg :age :accessor person-age))) (setf jhyun (make-instance \u0026#39;person :name \u0026#34;jhyun\u0026#34; :age 17) old-jhyun (make-instance \u0026#39;person :name \u0026#34;jhyun\u0026#34; :age 1700) stranger (make-instance \u0026#39;person :name \u0026#34;stranger\u0026#34; :age \u0026#39;???)) (defmethod equals:equals ((x person) (y person) \u0026amp;rest args) (declare (ignore args)) (equalp (person-name x) (person-name y))) 위의 예제에서 name 슬롯만을 동치비교할 때 사용하도록 구현해봤다. 다른 언어들의 구현과 달리 x, y 끼리의 타입 비교, nullity check 같은건 어차피 defmethod의 type specifier에서 모두 걸러지니까 신경쓰지 않았다.\n꽤 불만스럽게 지금까지 이야기를 끌고 왔는데, 이 방식이 장점도 많다는걸 생각해본다.\n불필요하게 specialized equality checker을 매번 작성하지 않아도 대부분은 잘 동작한다. (Java에 Eclipse/IntelliJ 같은 IDE은 물론 Common-Lang, Guava은 물론 Java SE의 API에도 이걸 해결하기 위한 Helpers, Utils, Generators이 항상 넘치는거에 비하면 훨씬 좋은 상황이다.) 그리고 defmethod에서 이미 타입 매칭이나 그런걸 다 해결해놓았고, nil 같은 값도 타입이 있어서(NULL타입) 여기에 걸리니까 동치비교 메서드의 구현이 안전하고 간단하다. 커먼리습에서 이 주제에 대해서는 거의 모든 내용을 이 글에서 정리한거 같다.\n7. 그냥 항상 EQUALS이나 EQUALP 쓰면 되는거 아닌가? 그럴지도 모르겠다. 하지만 그럴 필요가 없는 경우에 굳이 복잡하고 더 느린 연산을 적용할 필요가 없을 때도 많을거 같다. 그리고 그런 이유로 이렇게 세세하게 분류해서 커먼리습은 여러 레벨으로 등치비교를 제공한다.\n내가 어떤 함수를 정의할 때 타입을 명확하게 지정했는지에 따라서 어떤 연산을 사용할지 명확하게 결정하기 쉽고 성능도 훨씬 차이가 날거라고 생각한다. 값의 타입을 실행시간에 알아내거나 타입에 따라서 generic function에서 매칭하는 method을 찾아서 dispatch하는건 아무래도 아주 약간은 더 느릴테니까.\n커먼리습의 find 계열 함수와 같이 predicate을 인자로 받아서 시퀀스 등에 적용하는 경우도 그렇고, make-hash-table처럼 아예 자료구조를 만드는데도 각 요소를 어떻게 비교할지 predicate을 지정하기를 요구할 때가 많다.\n그때 그때 어떤 값을 다루는지를 잘 결정해서 =에서부터 equals까지의 넓은 선택 범위 안에서 고르는게 유리하다고 생각한다. 그리고 이들이 잘 효율적으로 컴파일 시간에 문제를 미리 예측할 수 있도록 이 값들을 다루는 코드나 정의에서 type specifiers을 잘 지정해서 컴파일러가 체크하도록 유도를 잘하는 것도 커먼리습이 다이나믹 타입시스템임에도 컴파일러가 똑똑하게 코드를 타입에 따라 체크하고 최적화를 해줄 수 있으므로 중요하다.\n맺음말 \u0026ldquo;the greatest single programming language ever designed\u0026rdquo;\n\u0026ldquo;지금까지 설계된 단일 프로그래밍 언어 중 가장 위대한 언어\u0026rdquo;\n\u0026ndash; Alan Kay, on Lisp\n\u0026hellip;Alan Kay께서는 Smalltalk을 통해 IDE, GUI, 마우스 등을 발명, 도입하셨습니다\u0026hellip;\n\u0026ldquo;Life is a tragedy when seen in close-up, but a comedy in long-shot\u0026rdquo;\n\u0026ldquo;삶은 가까이 보면 비극이지만, 멀리서 보면 희극이다\u0026rdquo;\n\u0026ndash; Charlie Chaplin, 챨리 채플린\n\u0026hellip;그러게요.\n이름의 끝에 -p-suffix은, predicate이라는걸 나타내는 컨벤션 전통. 요즘엔 -?을 붙이는 경우도 있는데, 커먼리습의 CLHS 시절에는 -p-suffix이 더 일반적인거 같다. (예: zerop, evenp, oddp; 반례: null), 참고: https://www.cliki.net/Naming+conventions\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-11nov/why-sharpsign-in-method-path/","title": "🚍 (소프트웨어 고고학) 어째서 `String#replaceAll`처럼 메서드 경로의 구분자로 `#`을 쓸까?",
     
     "tags": ["programming", "smalltalk", "java", "javascript", "ruby", "javadoc", "symbol", "archaeology", "history"],
     
 "description": "",
 "contents": "오늘 아침 다음은 오늘 아침 트위터의 타임라인에서 내가 스쳐본 한 스크린샷의 일부이다:\n1\n\u0026hellip;뭐에 느낌을 받았냐하면, 바로 저 String#replace(..) 이라는 부분이다. (다른 부분에서는 String.prototype.replace(..) 와 같이 썼는데 굳이 저기서만 갑자기 튀어나온 표기법)\n사실 나도 종종 내가 작업한 코드의 문서를 쓰거나2 아니면 다른 사람과 텍스트로 대화를 해야할 때 이렇게 표기를 해왔었다.3\n각각의 언어들에서 (내가 생각하는) 저렇게 표기하는 근거들은 다음과 같다:\nJava: https://www.oracle.com/technetwork/articles/java/index-137868.html @see Component#getGraphics() JavaDoc안에서 다른 메서드, 필드를 참고로 넣고 싶을 때 이게 표준표기법이고 javadoc도 요렇게 써줘야 링크처리를 해준다. JavaScript 공식적인건 아닌거 같다. Mozilla MDN을 봐도 그런 표기는 사용 안하는걸로 보인다. 예: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toString Ruby Java와 마찬가지로 RDoc에서 강제한다. 스택오버플로우: What is the # (sharp, number, pound, hash) sign used for in Ruby? 스택오버플로우: Use a hash character or a dot when referring to methods and fields in software documentation? [closed]에 답변이 있으나 내가 볼 땐 내 가설이 더 확실한 이야기라고 본다.4\n기원 - Smalltalk 내가 생각하는 기원은 Smalltalk language에서 메서드명을 표기하는 방법에서 시작했다고 생각한다.\n더욱이 더 흥미로운 점은 문서를 위한 표기법이 아니고, Smalltalk 코드에서 직접 메서드 값을 얻을 때 사용하는 코드표현식 그자체라는 점이다.\n다음과 같이 주로 표기한다:\n인스턴스 메서드: String\u0026gt;\u0026gt;#indexOf: String 인스턴스의 indexOf 메서드. (파라미터를 1개 받는) 클래스 메서드: String class\u0026gt;\u0026gt;#empty String 클래스의 empty 메서드. 실제로 실행해보면 다음과 같이 실행 가능한 표현식이다 (실행해서 각각의 결과를 Pharo Inspector으로 살펴보는 스크린샷):\nJava, Ruby에서는 그냥 문서 쓸 때 표기법일뿐이었는데, Smalltalk에서는 아예 저게 실행가능한 표현이고, Smalltalk문서, 서적들에서도 그냥 저렇게 표기한다. (Smalltalk 개발환경 안에서도 마찬가지고.)\n더 흥미로운 부분은 이 표현식을 분석해보면 나온다:\n#blah 와 같은 부분은 Smalltalk에서 Symbol 값의 literal 표현이다. Lisp의 심볼이랑 유사하다. 그리고 Smalltalk에서는 이렇게 메시지/메서드의 이름을 심볼으로 Lisp처럼 표기한다.5 Smalltalk 커뮤니티에서는 이런 메시지/메서드 이름을 심볼으로 표기한 것을 흔히 selector 이라고 부른다. \u0026gt;\u0026gt; 부분은 Class 객체의 \u0026ldquo;binary operator\u0026quot;으로 정의되어 있다. 좀 더 정확하게는 Pharo Smalltalk에서는 Class의 조상 중 하나인 Behavior. 내용은 \u0026ldquo;주어진 selector에 해당하는 메서드 코드 값을 찾아 되돌려줌\u0026quot;이다. 그러니까, 결국 다음과 같이 써도 맞는 표현식이다.\nString \u0026gt;\u0026gt; #indexOf: (String class) \u0026gt;\u0026gt; #empty 조금 더 Java스러운 코드나 Lisp식으로 써보면\u0026hellip;\n// Java-style String.class.getMethodByName(\u0026#34;indexOf\u0026#34;); // Imaginary code ;;; Lisp-style (get-method String \u0026#39;indexOf) ; I know, not an idiomatic Lisp 물론, \u0026gt;\u0026gt; 대신에 getMethodByName() Java 메서드나 #'get-method 같은 Lisp 함수가 있다고 가정한 예시다.\n사실 내 생각엔 스페이스 없이 다 붙여쓰는건, 표현식의 덩어리 붙여서 읽기 편하라고 그런거 같다. 예로, Smalltalk에서 2차원 공간에서 좌표를 표기하는 Number\u0026gt;\u0026gt;#@ 메서드는 다음과 같이 보통 literal을 표현한다:\n11@42\nX=11, Y=42인 Point 객체의 표현이다. 이렇게 붙여쓰는게 더 잘 보이는 경우이니 그런거 같다.\n\u0026hellip;그러면 뭔가 난감함이 밀려온다 온다. 왜 그럴거면 \u0026gt;\u0026gt; 부분은 몽땅 다 날려버리고 그냥 심볼 표기법만을 그대로 붙여서 써왔던건가? 그렇다.\n맺으며 Lisp이나 Smalltalk에서는 평가값 자체의 문자열 표현식을 그대로 다시 평가하면, 그 값 자체로 평가되도록 출력하는 문화가 있다. (가능할 경우에는)\nPython도 이런 특성이 남아있다: 어째서 객체를 정의할 때 __str__와 __repr__ 두 가지 다른 방법이 모두 있는지 궁금하지 않았었나? https://docs.python.org/3/reference/datamodel.html#object.__repr__ 6\nJava, Ruby은 모두 Smalltalk의 영향을 많이 받은 언어이리라 생각한다.\nJava의 경우에는 내 생각엔 거의 \u0026ldquo;C++의 문법을 뒤집어 쓴 Smalltalk\u0026quot;인거 같으니까. (비슷한 특성을 이야기하자면 JIT, VM, Garbage Collection, Single Inheritance\u0026hellip; 끝도 없을거 같은데)\nRuby야 워낙 문법이나 설계 등등 많은 부분을 Lisp, Smalltalk, Perl 등에서 따왔다고 말하니까.\nJavaScript야 \u0026ldquo;Java랑 거의 같은 언어\u0026quot;니까 이렇게 된거 같다.7\n그냥 Smalltalk의 영향이 아주 조금이나마 보이는 부분에 이렇게 남아 있고, 그게 조금 말도 안되는 형태이기는 하지만 강제되고 전파되어 온게 흥미롭다.\nSmalltalk은 Domain Specific Language을 Lisp이랑 다르게 Macro이 없이도 그냥 주욱 만들어가기 좋은 언어로 의도해 성장해왔고, 그 영향은 현재의 대부분의 객체지향언어들이 Lisp의 매크로 시스템을 갖지 못한데다가 Smalltalk와 더 유사함이 많고 해서 비슷하게 전파되어진거 같다. (Java, C#, Groovy, Scala등등\u0026hellip;)\n그리고 그런 DSL으로 표기한게 문서화에 그대로 써도 되게 간결하고 확실한 Smalltalk이 흥미롭다.\n출처 https://v8.dev/features/string-replaceall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n특히 Java 코드를 작성했다면, JavaDoc에 이렇게 메서드 이름을 표기하는게 표준이고 강제되니까. (이렇게 적어야 링크가 제대로 걸림ㅋ)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n그리고 동료들은 대체 왜 그렇게 표기하느냐고 물어왔었다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n아니면 뭐\u0026hellip; 어쩔 수 없지.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSmalltalk의 설계자 중 한명인 Alan Kay은 이미 Lisp에 대해 알고 있었었고, 이를 좋아했었던거 같다: https://www.quora.com/What-did-Alan-Kay-mean-by-Lisp-is-the-greatest-single-programming-language-ever-designed/answer/Alan-Kay-11?share=1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n하지만 현재는 디버깅을 위한 용도로, 읽는 사람을 테크니컬한 정보로 깜짝놀라게 하고 싶은 용도로 사용한다. 그리고 반대로 사람의 마음을 안정적으로 유지하기 위한 문자열 표현은 __str__ 을 사용한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n죄송합니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-11nov/ping-01fri/","title": "🏰 Ping 01/Nov/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "그 이전의 시간 한국으로 돌아와 1년 반 정도 한 회사에 다니다가, 정리하고 나와서 시간을 보내고 있다.\n관점, 사고방식, 일하는 방식 등등 대화가 통하기도 어려운 상황이었고, 그런 세계관도 너무 차이가 나서 같이 있기 힘들었었다.\n그리고 어째서 한국을 떠나기로 결심했었었는지 뒤돌아봤고 거의 동일한 경험이었다. 조금은 달라진게 있으려나. 아마 그러리라 생각한다. 완전히 똑같은 경험은 아니다. 왜냐하면 거기에서 내가 얻은게 다르다.\n어떤 사람은 그럴리 없고 내가 오해를 한거라고 이야기를 해주지만, 그냥 나는 나와 같은 상황도, 처지도, 지위도 아니었으니 그런 충고가 무의미하다고 생각한다. 그 사람은 그 사람의 입장으로 경험을 한거고 그러니 판이하게 달랐겠지.\n그냥 화낼 일도 서운할 일도 아닌 것 같다. 사람들은 자신이 뭔가를 이루고 자신의 정신이 그걸 결정했다고 생각하고 싶어하지만, 자신이 살아온 환경, 처지가 그 사람일 때가 많은 것 같다. 나도 그럴테고.\n정신을 놓고 그냥 살아가며, 그러다보면 나아지겠지라는 맹목적으로 살았지만, 지나오며 깨달은게 생겼다. 그래서 결정을 내렸고 가장 탁월한 결정이었다.\n삶 책을 읽고 또 오랬동안 알아오던 세상을 보는 관점에 놀라운 변화를 겪게 되고, 살아가는 방법을 바꿔보고있다. 재미 있고 행복하다.\n언젠가 또 다른 결심을 할 때가 오겠지만, 그때까지는 그냥 내게 어떤 용도나 본질을 스스로 강요하거나 강요 받지 않고 그냥 존재하는대로 살아가려고 노력한다.\n글을 많이 쓰고 정리한다. 너무 지저분하게, 그리고 산만해지지 않도록 노력한다. 연속성을 가진 집중을 해나가려고 한다. 너무 산만한 다양한 생각들을 하기보다 그게 낫다.\n운동을 하고 매일 루틴을 갖고 지켜나가고. 지루한데 이상하게 엄청나게 재밌고 생산적이다. 누구에게 보이거나 할 수도 없고, 증명할 필요도 없이 생산적인거 같다.\n내 File vault에 정리하고 저장한 글들, 혼자만의 위키처럼 가꾸어 나가는 글들이 계속해서 쌓여가고 즐겁다. 나름 중량을 불려나가는 것이 즐겁다. 그리고 점점 중량이 불어남에 따라서 질적인 변화도 일어나는걸 느낀다.\n방법 생각을 메모하고, 정리하고, 다시 정제하는 방법과 루틴을 정리했다.\n생활하면서 가장 편리하고 집중된 주제에 연속성을 잃지 않는 방법을 오래 고민해오던 것들.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/exg-pro-trackball-pgupdn/","title": "🦱 ELECOM EX-G Pro Trackball 잉여 버튼을 Page Up/Down으로 쓰기",
     
     "tags": ["linux", "xorg", "xdotool", "xbindkeys", "xev", "trackball", "mouse"],
     
 "description": "",
 "contents": "컴퓨터를 많이 쓰니까 다른 부분보다 손목이 먼저 망가져서, 손목을 조금만 큰 각도로 꺾으면 아프다. ㅠ.ㅠ.. 예전에도 그랬었는데1\n마우스 안쓰고, 트랙볼 쓰기2 키보드 넘패드 부분 없는 짧은 86키 레이아웃 쓰기 로지텍 마블 트랙맨 잘 쓰다가, 지름을 받아서 조금 다음 티어의 제품으로 업그레이드 해봤다.\n그래서 바꾼게 \u0026ndash;\u0026gt; 엘레컴 EX-G Pro Trackball ..그런데 다 좋은데, 저기 있는 Function assignment button 이라고 써있는게 2개가 더 달려있음.3\n이 추가기능버튼들은 윈도였다면 벤더에서 제공하는 프로그램을 통해서 할당이 가능할거 같은데, 리눅스/X윈도에서는 xev으로 확인해보니 그냥 Button 10번, 11번이었다.\n그래서 조금 설정을 해보기로 했다. 원하는건 단순하다:\n어차피 wheel 달려있지만, 강렬한 Page Down, Page Up 기능으로 웹페이지나 문서를 읽을 때 더 강렬하게 편안하고 싶다. 마우스휠을 굴리는 것도 딸캌 한 번 클릭에 비하면 칼로리 소모가 무시 못하게 크다. 그래서 다음의 조합으로 설정해봤음:\nxbindkeys 키보드, 마우스 이벤트를 잡아서 원하는 쉘커맨드 실행 GNU Guile을 설정파일을 작성해서, Scheme으로 원하는 기능 작성도 가능. (그렇게 열심히 코딩할 것도 없지만) xdotool \u0026ldquo;fake keyboard/mouse input, window management, and more\u0026rdquo; 이걸로 Page Down / Page Up 키를 대신 눌러주도록. 참고로, X윈도에서는 \u0026lsquo;Page Down\u0026rsquo; / \u0026lsquo;Page Up\u0026rsquo; 키들을 \u0026lsquo;Next\u0026rsquo; / \u0026lsquo;Prior\u0026rsquo;이라고 부름.4\n그래서 xbindkeys 설정 파일은 다음처럼 만들어봤다:\n1 2 3 ;;;; ~/.xbindkeysrc.scm (xbindkey \u0026#39;(\u0026#34;b:10\u0026#34;) \u0026#34;xdotool key Next\u0026#34;) (xbindkey \u0026#39;(\u0026#34;b:11\u0026#34;) \u0026#34;xdotool key Prior\u0026#34;) 간단하다. 그리고 적당히 시작스크립트에 xbindkeys 실행하도록 한 줄 넣어줬다.\n그냥 언제나 X윈도로 이런거 할때마다 느끼는거지만, 유닉스쟁이들은 자동화와 커맨드들의 연결을 통해 뭔가를 하는걸 정말 사랑하는구나 싶다.\nXTEST X윈도 프로토콜 같은거 일일이 표준화하면서 넣어서 xdotool 같은 자동화 도구 만들어내는거나 그런거 보면 재밌다. 하긴 뭐 그럴려고 리눅스, 오픈소스 쓰는거겠지만.\n그나저나 참 오랬만에 Guile을 설정 언어로 쓰는 프로그램을 봤다. ㅎㅎ Guile으로 설정 파일 쓸거면 그냥 거기서 키이벤트 발생하는 기능 넣어놓으면 좋았을까 싶다가도, 유닉스스럽게 한 프로그램은 한가지 일만 잘하기 가 떠올랐다.\n한 10여년;;;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n저렴하고 그럭저럭 쓸만한 로지텍 마블 트랙맨 (소개글)을 주로 썼었다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n다른 \u0026ldquo;Back\u0026rdquo; / \u0026ldquo;Forawrd\u0026rdquo; 버튼 같은건 리눅스에서도 웹브라우져에서 잘 동작함.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n참고 http://xahlee.info/linux/linux_show_keycode_keysym.html, https://cgit.freedesktop.org/xorg/proto/x11proto/tree/keysymdef.h\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/blog-font/","title": "🦋 블로그 폰트 적용",
     
     "tags": ["font", "cdn", "webfont", "blogging", "blog", "css", "webdev"],
     
 "description": "",
 "contents": "그냥 CDN에서 내려받는 공개된 Noto 폰트를 적용했다. 깔끔하다.1\n어제는 네오둥근모 적용해서 완전 귀엽고 내 취향이기는했는데, 그렇게 두면 안될것 같아서 좀 평범한 폰트로 바꿨다.\n깔끔하게 글이 눈에 잘 들어오고 CDN에서 내려받으니 빨라서 좋다.\n워드프레스에서 본명조(Noto Serif CJK KR) 폰트 사용하기 이 포스팅을 참고. 고맙습니다. 글 쓰신분 아이디가 이스크라(러시아어 \u0026lsquo;불꽃\u0026rsquo;)이라니\u0026hellip; 심장이 뜨거워진다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-20sun/","title": "🚜 Ping 20/Oct/2019",
     
     "tags": ["ping", "gaming", "driving", "burnout-paradise", "civ5"],
     
 "description": "",
 "contents": "장거리 드라이브 고속도로를 내려와서 국도에 들어서서 우회전 신호대기에서 창문을 내리자마자 깨달은게 공기가 말도 안되게 좋았다.\n가보고 싶었던 곳들을 돌아다니고 정말 많은게 변했구나 싶기도 하고 쓸쓸했다. 세상에 이런 곳도 아직 있구나, 내가 사는 세상이, 그게 절대적으로 전부라고 생각하는 복잡하고 발전된 모습이 아니라, 이런 곳이 있을 수 있구나 싶어서 신기했다.\n다시 또 가고 싶다. 아주 옛날엔 거기가 지루하다고 생각했었던거 같은데.\n게임: 번아웃 파라다이스 \u0026lsquo;벗아웃 파라다이스\u0026rsquo;, 리마스터 버전으로 만난다 - 이도원 기자 입력: 2018/02/22\n..돈도 없지만 질렀다. 예전 플스2일때 좀 했었던거 같은데. 아니면 기억의 오류로 피씨로 했었던걸지도 모르겠다.\n그냥 기름을 너무 많이 쓰면서 운전을 하고 싶어서 안달이 난거 같고 게임콘솔 안에서 주행거리를 아무리 늘리고 rpm 빡쎄게 엑셀을 밟아도 괜찮을거 같아서 샀다.\n게임: 문명V 문득 Steam에서 예전에 사놓고 플레이를 조금1 했었던 시드마이어의 문명V 설치했다.\n금요일 저녁, 토요일이 사라진거 같다\u0026hellip; 토요일 밤 잠들기 전에 \u0026lsquo;악마의 게임\u0026rsquo;이구나 지우고 다시 봉인을 해야겠다고 생각했다.\n290여 시간 정도 였었던거 같다\u0026hellip; 다른 플레이어들에 비하면 별로 많이 한건 아니라고 생각한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/cl-toy-stack-lang/","title": "🧜‍♀️ cl-toy-stack-lang 첫번째 버젼과 작업하면서 깨달은것",
     
     "tags": ["programming", "common-lisp", "commonlisp", "toy", "opensource"],
     
 "description": "",
 "contents": "일단 첫번째 버젼 다 만들었다.\nhttps://github.com/ageldama/cl-toy-stack-lang/releases/tag/v0.1.0\n그냥 장난으로 인터프리터도 아니라 그냥 eval 이용한 간단한 파서도 필요없이 lexer만으로 만들만한 Forth 비슷한 언어를 만듬.\n명령어도 실용적인 목적이 아닌만큼 그냥 문자열 장난 밖엔 없다.\n느낀점 라이브러리 좋은거 갖다 잘쓰자 uiop 같은거, feature-expression 삽질을 적게하거나 안해도됨. 더 portable하고 잘 굴러가는. Test! 3. 짜고 하나씩 진화시켜가면서 다시 돌리는 재미. Idiomatic하게 그리고 역시 Test! ..처음엔 그냥 전역변수에 상태를 갖도록 만들고, 그걸 dynamic binding으로 바꿔서 파라미터화하고, 또 그걸 다시 상태를 캡슐화하는 클래스로 감싸고, 처음엔 단순하게 리습스럽게 짜고 그걸 진화시키고, 그리고 역시 다시 테스트. 아는만큼 보인다 setf 병렬로 하기, +destructuring asdf:operate + :build-op : SBCL/ECL 등 리습컴파일러에 관계 없이 실행이미지 빌드 편안하게 https://github.com/xach/buildapp 같은거 써볼까 하다가, 처음엔 그냥 간단히 쉘스크립팅으로 시작. 기타 등등 \u0026hellip;그리고 무엇보다 재밌었다. 그리고 뭐가됐든 그냥 짜보고 굴러가는 형태로 계속해서 작은 프로그램을 많이 만들고 하면서 놀아야겠다고 생각했다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-15tue/","title": "👩‍🦯 Ping 15/Oct/2019",
     
     "tags": ["ping", "programming", "lisp", "toy", "stack", "forth", "commonlisp", "common-lisp"],
     
 "description": "",
 "contents": "커먼리습으로 간단한 스택기반 장난감 프로그래밍언어를 만들고있다.\nhttps://github.com/ageldama/cl-toy-stack-lang\n튜링컴플릿이나 그런거 관심도 없고 사실 Parser도 적절하게 만들지 않았다.\n다만 유니코드 잘되고 쓸만한 lexer generator이 커먼리습에 있는지가 궁금했다.\n적당히 내일 정도면 어느 정도 완전히 굴러가는 프로그램으로 다 만들고 마무리 할 듯.\n처음에는 QuickLisp 에서 어떤 Lexer을 써야할까 고민하다가, cl-lex 쓰다가 실망스러웠다.1\n그러다가 만난게 Alexa 인데, 가장 마음에 드는 lexer generator.\nhttps://www.rigetti.com/ 이 회사를 발견. 커먼리습으로 Quil Compiler2 만들고 퀀텀컴퓨팅 관련된 기업인가 보다.\n그리고 깃헙 저장소 살펴보는데 흥미롭고 써보면 어떨까 싶은게 많이 보였다.\n정규표현식으로 패턴을 지정하는것도 그렇고, 뭔가 제대로된 구현이 딱 하나가 dominant한게 없어서 여기저기 비슷한 lexer 프로젝트들이 있는데 다 장단점이 달라서 혼파망 느낌.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nQuil (instruction set architecture) https://en.wikipedia.org/wiki/Quil_(instruction_set_architecture)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-14mon/","title": "🚜 Ping 14/Oct/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "어제 오늘 요즘에 들어서 생각을 겨우 하기 시작한 고민을 사람들이 트윗하더라.\ntweet 1183311320822607872\n..이번에 직장을 그만두고1 새로운 직장을 열심히 알아보고 있지는 않고 있다.\n몇군데 인터뷰를 진행도 해보고 했지만, 모두 솔직히 나도 모르겠고 거절도 많이 받고 해서 꾸준히 진행을 하고 있지는 않다. 그리고 나도 이직을 하고 recruiting 과정을 한국만이 아니라 독일에서도 다양하게 겪어보니 어떤것이 좋거나 나쁜 신호인지 캐치하게 되는거 같고, 또 그런 시그널들이 생각보다 적절하게 그 회사측의 모습이나 생각을 반영하는게 맞는거 같더라.\n하옇튼, 아무래도 내가 엄청나게 학벌이나 경력이 화려한것도 아니고 스킬도 별로인데다가, 예전보다 나이도 있고 괜히 좋은 신호를 주기도 회사들도 부담이 되리라 생각한다. 그리고 굳이 젊고 말 잘듣고 고분고분하고 조금 거시기해도 스리슬쩍 넘기기 좋은 사람들이 많을텐데 내게 그럴 필요는 없을거 같다는 생각도 든다.2\n살아오면서 항상 한국에서 일터에서는 너무 동일한 경험이었던거 같다. 축약하면, 경제논리에 충실한데, 그 충실한 경제논리도 어정쩡한 거시기한3 버젼으로 매번 충실해서 너무 당연히 \u0026lsquo;아 당연히 그러시겠지\u0026lsquo;라는 생각이 드는.\n그리고 앞으로도 예상을 벗어나는 직장에 취업을 하는것에는 너무 기대를 하지 않는게 좋을거 같다. \u0026lsquo;환상\u0026rsquo; 이라는 말로 표현할수도 있겠지만, 그냥 \u0026lsquo;기대\u0026rsquo;라고 말해야겠다. 왜냐하면 내가 기대하는것들이 틀렸다거나 이익을 추구하는 공동체 안에서 구현될 수 없다고 생각하지 않고 오히려 추구해야 하는거라고 나는 아직도 생각해.\n여핳튼, 나는 앞으로 어떻게 살아가야할까 고민스럽다. 그리고 지금은 잘 모르겠다.\n4\n나는 그 직장에서 일하는 재미도, 보상도, 육체적으로나 정신건강상에도 내겐 맞지 않는다는 판단이 들어서. 나와는 다른 생각으로 짜여져있던 직장이니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n쉽게 말해서 경험이 있는 사람보다는 \u0026lsquo;\u0026rsquo;아, 의도적으로 그런건 아닌데\u0026hellip;\u0026rsquo;\u0026rsquo; 이런 소리를 하기 더 쉽겠지. 나도 많이 듣고 그러려니 해줘야만 했던 소리들. 막상 자기들은 매번 의도랑 상관없이 그러지만 내가 내 이익을 위해 정당하게 행하는것도 의도와 내 본성을 알아서 판단해서 진단까지 저들은 내리는 주제에 말이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n자세한 표현은 생략.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n엔딩크레딧, 김종서의 \u0026lsquo;지금은 알 수 없어\u0026rsquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-13sun/","title": "🌫️ Ping 13/Oct/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "집중하는게 내게 더 좋겠다는 생각이든다.\n단시간에 어떤 일에 집중하는 일은 만족스럽다. 그런 시간단위의 집중이 아니라 기간이라고 할만큼 며칠, 몇주에 걸쳐, 한정된 한두개의 주제에만 집중해서 생각하고 만들거나 글을 써가는게 필요하다.\n혼자 관심이 가거나 생각하는 주제가 떠오르면 Org파일 한 개나 메모지, 핸드폰에 적어놓는다. 그리고 내가 가진 정리하는 방식에 따라 조금씩 생각이 다듬어질때마다 저장매체를 바꿔가며 기록해나간다. 문득 그 Org 파일 을 열었는데, 너무 많은 내용들이, 그것도 폭넓은 다양한 주제들에 대해서 걸쳐있음을 봤다.\n다양한 주제에 관심이 있는건 어쩔 수 없겠지만 각 주제마다 내가 투사하는 시간과 노력이 너무 분산되는거 아닌가 생각해왔다.\n그래서 뭐라도 만들고 쓰려면 적은 주제에 대해 한정하고, 그 기간 동안엔 다른건 내려놓고 몰두하는게 필요하겠다 싶다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/zettelkaesten-12sat/","title": "📐 Zettelkästen?",
     
     "tags": ["thinking"],
     
 "description": "",
 "contents": "어제 Ping에서 계속 블로깅을 하면서 생각 하는걸 계속 다듬어 갔으면 좋겠다는 말을 했었는데,\n마침 HN에 그런걸 하기 적절해 보이는 글이 올라와서 읽어봤다.1\n간략히 정리해보면,\n생각 적기: 짧은 길이 메모를 적어서 생각만으로 카드를 만들고,2 3 이 상태에서는 우선 각 카드는 \u0026ldquo;순번없음 (Unsorted)\u0026rdquo; 상태 deck으로 쌓아만 놓는다. 순서매기기(1): 카드끼리 1, 2, 3 같이 순서를 두고 정렬. \u0026lsquo;Unsorted\u0026rsquo; deck에서 꺼내와서 정리하는거겠지. 각 순서는 생각의 순서일수도 있겠고, 아니면 그냥 구분되는 다른 생각의 단절을 나타내는 방법으로 쓸수도 있겠지. 순서매기기(2): 그리고 위에 만든 1, 2, 3와 같은 순서 카드에 딸린 하위 생각들은, 1a, 1b, 2a, 2a1, 2a2 와 같이 alphanumeric으로 하위 생각들을 표현해 나간다. 연결하기: 그리고 각 카드들의 서로 연결 을 적어나간다. 예를 들어, 1a에서 하위 카드가 아닌데도 연관이 있는 2a1, 2a2으로 연결을 갖는다면, 1a 카드에 2a1, 2a2을 링크 라고 적어준다. 위 3단계에서 계층적으로 순서를 할당하는걸 시각화해보면 다음과 같은 트리가 되겠지4:\n(1) | +-- (1a) | +-- (1b) | (2) | +-- (2a) | | | +-- (2a1) | | | +-- (2a2) (3) 그 순서 사이에 2a, 2b, 2b1, 2b2, 2b1a와 같이 계속 하위 계층을 만드는건 마인드맵이랑 비슷해보인다. 다만, 마인드맵보다 처음에 순서를 부여하지 않고 쌓아놓았다고 하는걸 더 선호하라고 하는게 재밌었다.\n그리고 이렇게 순서, 혹은 인덱스 번호(alphanumeric)을 부여했다면, 그걸 갖고 다른 카드랑 하이퍼링크를 만들면서 연결시켜나감. 이건 위키랑 비슷.\n하지만 위키는 위키페이지의 내용에서 각 키워드가 링크가 되는건데, 이건 그냥 카드 자체가 링크의 대상이고 링크의 시작점인게 다름.\n계속 나 자신과 대화하면서 생각을 만들어가는게 재밌는 방법 같다.\n생각하던 필요에 맞는 방법이다.\n내가 생각하는게 한번에 완전한 생각을 다 해내는 것도 아니고, 계속해서 탐색하고 하며 생각을 다듬어 나가고, 또 다른 생각과 연결을 갖는데 위키 같은 무언가가 있으면 좋겠다고 생각했다.\nhttps://clerestory.netlify.com/zk/ 이 아티클에 다른 좋은 관련 링크들이 많이 있음.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\u0026ldquo;Zettel\u0026rdquo; 에 대해서 비트겐슈타인은 https://en.wikipedia.org/wiki/Zettel_(Wittgenstein) 이런 의미로 사용했었었다고 한다. \u0026ldquo;Zettelkaesten\u0026rdquo; 이란 단어가 그냥 이런 \u0026lsquo;카드들의 박스\u0026rsquo; 정도라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n어차피 다른 카드들 더 적어서 순서에 따라서 배열/재배열을 하고, 카드들끼리 링크를 만들어서 연관을 지을거라, 너무 한 카드에 많은 생각을 넣으면 재구축하기 불리해진다. 가능하면 Atomic하게 적어야 좋다고.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n이 트리에는 각 카드들이 가로지르는 연결 (crossing links) 을 갖는걸 표현하지 않았다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/cl-rutils/","title": "⚒️ rutils으로 커먼리습 확장해서 clojure 비슷하게, 더 편하게",
     
     "tags": ["programming", "commonlisp", "common-lisp", "lisp", "clojure", "macro", "syntax"],
     
 "description": "",
 "contents": "커먼리습은 CLHS 이후로 언어 자체 정의는 변하지 않았다.\n구현체마다 조금씩 확장이 있을수도 있지만 딱히 그렇게 하지도 않는거 같다. 그럴만도 하다고 생각하는게 어차피 커먼리습에서 lisp reader을 확장하는게 CLHS에서 정의해놓은 기능 중 하나이고, 구현체들도 스펙을 잘 구현해놓았으니까.\n결국 커먼리습에서 문법이나 그런게 조금 마음에 안들거나 확장하고 싶으면 언제든지 매크로를 만들듯이 확장하면 되니까.\n\u0026lsquo;커먼리습 언어 자체를 커먼리습으로 프로그램 할 수 있다\u0026rsquo;\n이런 커먼리습 확장 \u0026lsquo;라이브러리\u0026rsquo; 들이 여러가지 있는데, 가장 요즘에 쓸만할거 같다고 생각하는건 rutils이다. https://github.com/vseloved/rutils\n(eval-when (:compile-toplevel :load-toplevel :execute) ...) 같은거 매번 반복해서 쳐넣는걸 그냥 eval-always으로 바꿔준다거나. gensym하는것도 with-gensyms 제공하거나 하는 이런류의 라이브러리들에서 보통 제공하는것들부터.1\n내가 제일 유용할거 같은건:\nClojure 같은 Lambda 함수 표현 Hashtable, Vector, Heredoc String literal 표현 Clojure 같은 -\u0026gt;, -\u0026gt;\u0026gt; threadings macros2 rutils.bind:with: destructuring 편안하게! rutils.generic:?: nested object에 대해서 편안하게 accessing 리터럴 표현들의 경우에는 sharpsign을 쓰는 문법이 기존 커먼리습 편집기들이랑 별 충돌 없이 잘 동작할듯.3\nrutils의 기능들을 일일이 하나씩 소개하지는 않겠음. 그냥 tutorial 주욱 읽고 자기가 커먼리습 코드를 작성할때 참고해서 더 편안하고 깔끔한 코드를 짜는데 도움이 되었으면 좋겠다.\nhttps://common-lisp.net/project/alexandria/draft/alexandria.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n.. https://en.wikipedia.org/wiki/Thread_(computing) 이거 말고.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n왜냐하면 #... 와 같은 형태로 sharpsign은 http://clhs.lisp.se/Body/02_dh.htm 와 같이 더 보편적인 리더매크로 표현법이니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-11fri/","title": "📠 Ping 11/Oct/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "매일 글쓰기. 블로깅하기 나도 해볼까.\n해보려는 이유는 메모는 계속해서 하면서 살고 있는데, 연속해서 같은 주제에 대해서 더 생각하고 하면서 발전시키는 방법으로 일기를 쓰는것과 반복적으로, 또 이전에 썼었던 글을 읽어보면서 거기에서 더 나아가서 고쳐나가고 발전시키는 방법으로 블로깅이 나쁘지 않은거 같아서.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-10oct/ping-08tue/","title": "🦙 Ping 08/Oct/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "어제는 하루 종일 아는 사람들을 만나고 돌아다녔다.\n한국에서 운전을 하게 되고 재미를 붙이고 살고 있다.\n비가 오는 날이었지만 상쾌해서 북한산 국립공원 근처, 은평한옥마을, 진관사를 다녔다. 차를 타고 이동하면서 편하고 좋았다. 행동반경이 넓어지고 운전하면서 아직은 매순간이 재밌다.\n비가 내려서 구름과 안개가 북한산 자락에 깔려서 운치있었다. 카페에 앉아서 산풍경을 감상했다. 학생때는 자주 학교에서 소풍이나 백일장을 서오릉이나 북한산으로 왔었었는데. 그때도 가끔 생각했지만 비가 내려 세상이 이렇게 젖었을때 애처롭게 어둡기도 하고 깨끗한 습기를 머금은 숲이 상쾌해서 생명을 느끼게 해준다.\n요즘엔 그냥 모아놓은 돈으로 살고, 돈에 대한 걱정을 일부러 안하고 매일 일상은 단순하고 일정하게 유지한다. 매일 해야하는 의무와 루틴들을 만들어서 그안에서 건강하게 살아간다.\n내삶에서 언제 별 의미도 내게 만들어주지 못했던 일들, 관계들에 휩쓸려 다니기 보다는 그냥 일생에 한번이라도 그냥 마음놓고 해봤으면 하는 일을 하며 살고있다.\n조금씩 몇가지씩 내게 중요한것들을 깨닫고, 깨달은 바에 따라 많은걸 바꿔가는 시기.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-03mar/2019-03mar17-ping/","title": "🧆 Ping 17/03/2019",
     
     "tags": ["ping", "keyboard", "mechanical-keyboard", "ebay", "book", "books", "reading", "programming", "emacs"],
     
 "description": "",
 "contents": "Emacs/C++ 개발환경 스크린캐스트 이전 포스팅 에서 만들었던 설정을 스크린캐스트로 찍어서 공유해봤다.\n\u0026ldquo;Let Over Lambda\u0026rdquo; 읽기 Let Over Lambda을 읽기 시작했다. 커먼리습 매크로, 클로져에 대한 이야기를 더 깊이 있게 설명하고, 그런 기능들이 어떻게 리습이랑 리습이 아닌 \u0026ldquo;Blub language\u0026rdquo;이라고 말하고있는 대부분의 언어들과의 차이인지를 설명한다.\n리습의 매크로나 closure을 통해서, 그간 내가 프로그래밍언어 설계를 할때 포함해야하고, 컴파일러가 지원하도록 손수 만들어놓아야 한다고 믿던 것들이 얼마나 쉽게 구현되는지를 보며 충격을 받는다. 재밌고 신선하다.\n다른 리습, Prolog책들 쌓아놓고 안 읽던것들도 조금 더 읽어나가야겠다.1\n커먼리습, CFFI, FreeType2, OpenGL, GLFW OpenGL, FreeType2, GLFW을 CFFI으로 바인딩한 커먼리습 라이브러리들을 갖고 원하는 기능들을 만들어보고있다.\nCFFI/Lisp에서 어떻게 매핑되는지 잘 모르겠을때는 차라리 C++으로 작업하는게 훨씬 낫겠다는 생각이들기도한다. 그래도 계속해서 작은 함수들 만들고 테스트해보고 하면서 확인하며 진행해나가는게 어렵지도 않고, 엄청나게 이 창 저 창 오가며 문맥전환을 하거나 하지도 않아서 작업하고 집중하기 편안하다.\n커먼리습을 익히고 알아가고, 작업해나갈수록 계속 SLIME이나 Sly 같은 환경을 벗어나고 싶지 않게 만드는게 흥미롭다. 커먼리습 언어 자체도 그렇고.\nFutaba 스위치 키보드 기다리기 요런 소리가 나는 키보드.\n스위치 정보: https://deskthority.net/wiki/Futaba_MA_series\n못구할거 같다가 ebay에 매물이 있어서 샀다. 배송이 오래걸릴거 같아 괴롭긴함. 이런 취미가 생겨서 황학동이라도 한번 돌아다녀봐야할거 같다.\nParadigms of Artificial Intelligence Programming: Case Studies in Common Lisp, Artificial Intelligence: A Modern Approach, AI Algorithms, Data Structures, and Idioms in Prolog, Lisp, and Java\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-03mar/cffi-2d-array/","title": "🤜 CFFI으로 CommonLisp 2d array을 Foreign function으로 전달하기",
     
     "tags": ["commonlisp", "common-lisp", "programming", "lisp", "cffi", "ffi", "array"],
     
 "description": "",
 "contents": "https://github.com/ageldama/cffi-2d-array-hello\ncffi:with-foreign-array이 CFFI manual에 없어서 처음에 좀 골치아팠음.\n리습 어레이를 복사해서 매핑해줌.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/2019feb27-ping/","title": "👩‍🦼 Ping 26/02/2019",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "번아웃, 회의감 아무래도 번아웃이 온거 같다. 일을 해야 하는데 아무런 생각이나 의욕도 떠오르지 않는다.\n아무것도 제대로 하지 못할거 같고, 해서 의미도 없을거라는 생각이 강하다.\n일하는것에 회의가 심하다. 실제로는 아무것도 제대로 알지 못하고 그냥 싫으니까 반대에 사람들 사이를 조작해서 악의적으로 행동하고 그렇게 조장하는것에 이제는 삶에서 너무 많이 봐온거 같고, 그런 사이에서 무력하게 지내고 해야한다는게 무엇보다 지친다.\n그리고 그렇게 때문에 해야할 이유도, 굳이 마음을 써야할 이유도 모르겠다.\n그냥 개인적으로 하고 싶던 설정이나 만지작거리면서 시간을 보내봐도 딱히 그게 지나고 나면 하고 싶은것도 없어진다.\n어차피 한국에서 너무 많은 기대를 한걸까 하는 생각이 든다. 어차피 항상 그런식으로 돌아가고 별볼일 없는 시간을 보내게 강요 받는게 전부였었는데, 이번에도 마찬가지였던거 같다는 생각과 내가 보게되는 그런 상황들이 즐겁지는 않다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/counsel-ivy+cpp-ide/","title": "🤱 Ivy/Counsel으로 바꾸기, 기능들 만들기 (w/ C++지원, ++rmsbolt)",
     
     "tags": ["programming", "emacs", "elisp", "counsel", "ivy", "rmsbolt", "c++", "gnu-global", "asm", "disassembly", "reversing"],
     
 "description": "",
 "contents": "최근에 이맥스 설정을 Helm기반에서 Ivy/Counsel으로 전부 바꿨다.\n더 가볍고, 적당히 잘 동작하고, Ripgrep이랑 기본적으로 설정이 가능해서 편함.\n거기에 C-c C-o (ivy-occur) + wgrep이 Helm에선 동작할때가 그때그때 기능에 따라 달라서 짜증나고, 심지어 플러그인을 설정해서 써야하거나 해서 정말 좋아하는 기능인데 우울하게 만들었는데, Ivy이 훨씬 깔끔하게 동작하고 일관성있게 잘 동작함.\n처음에는 Helm에서 하는 기능들을 그대로 옮기려고만 생각하다가, 오히려 Ivy에 맞춰서 내가 익숙해지고, 더 낫게 할 방법들이 있어서 그냥 내가 adopt해서 편안해졌다.\nCMake + compile_commands.json 이전에는 RTags을 사용해서 \u0026lsquo;\u0026lsquo;정말로\u0026rsquo;\u0026rsquo; C++ 프로젝트를 Clang등을 이용해서 파싱하고, 그걸 인덱싱한걸로 정확한 navigation, code completion을 구성해 사용하려고 했었었다. 그리고 타입 정보다 그런거 다 있으니 제대로 굴러가서 꽤 쓸만하고.\n다 좋은데 그냥 이렇게까지 필요한가 싶은 생각이 들어서, 그냥 \u0026lsquo;\u0026lsquo;전통적인 방법\u0026rsquo;\u0026lsquo;에1 가깝게 GNU Global을 이용해서 C/C++ IDE 설정을 만들었다.\n적당히 인덱싱 필요할때해서, 태그 끼리 Jump나 되고 그런 정도지만, 그래도 소스코드 매번 ripgrep하는것보다는 편하니까.\n사실 어차피 타입이나 컴파일 가능 체크는 Flycheck + GCC/Clang으로 가능하게 만들어서 딱히 무거운 인덱서를 계속 돌리지 않아도 되니까.\n여튼 이런것들을 하기 위해서 Elisp + Perl5을 이용해서 CMake/GCC/Clang이 생성하는 compile_commands.json을 파싱하는걸 작성해봤다.2\n펄은 Text::ParseWords의 shellwords을 적당히 Elisp에서 구현한걸 찾지도 못했고3, 구현할바엔 그냥 잘 굴러가는 펄코드를 원라이너로 불러서 써도 될거 같아서.\ncompile_commands.json에 있는 gcc/clang을 호출하는 커맨드라인을 파싱해서, 지정한 Include directory등을 추출해서, 다시 그걸 Flycheck에 지정해서 적절하게 동작하도록 만들고 싶어서 이런 작업들을 했다.4\n그냥 이맥스/Elisp/리눅스/펄에 익숙해지고, 이들 생태계에도 익숙해지면서 어떤걸 선택해서 어떻게 연결해서 사용하면 될거 같다는걸 알게되면서 좋아지는거 같다. 그리고 반대로 어떤 편집기를 사용해도 이런걸 어느정도 알고 설정하고 확장하며 쓰게 될텐데, Lisp처럼 이맥스는 정말 그런 툴킷을 주는쪽에 더 가까운거 같다.5\nIvy와의 연동 Ivy와 연동해서, 빌드한 실행파일을 골라서 realgud 디버거나 테스트케이스 실행이 가능하도록 연동하는걸 작성했다.\nIvy을 사용한 이유는 어떤 실행파일인지 고르고6, 실행인자들도 지정해주고 하면 좋으니까.\n다음과 같이 동작하도록 만들어봤다.\n빌드 디렉토리의 실행파일 목록을, \u0026lsquo;\u0026lsquo;현재 수정하고 있는 파일이름\u0026rsquo;\u0026rsquo; 와 Levenshtein 거리가 가까운 순서로 정렬. 선택한 파일을 compilation-mode7이나 realgud으로 실행/디버그. https://github.com/ageldama/configs/commit/46e7478adb8588b7a948b2ec74cf2ca570fbec00#diff-844fd039f1d7faf1317fa95b88940eb7 이전에도 Helm + Rtags으로 동일한 기능으로 Elisp 구현해서 사용했었는데, 훨씬 Ivy쪽이 작성하기 편한거 같다. 그리고 나도 Elisp등에 익숙해진것도 큰거 같지만.\n++rmsbolt https://github.com/emacsmirror/rmsbolt 연동도 해봤다.\n코드 수정하고 저장하면, 이 모드를 켜놓으면, 자동으로 컴파일러 실행해서 Disassemble 덤프를 보여주고, 현재 포인트의 C/C++에 해당하는 어셈블리를 하일라이팅해서 보여준다.\n이것도 동작하는데 compile_commands.json 파싱해서 컴파일러 적당히 동작하도록 필요한 include directories이나 $CFLAGS 지정해주고 하도록해서, 정말 빌드만 CMake + compile_commands.json만 잘되어 있으면 아무것도 신경 안써도 바로 동작하도록했다.\nhttps://github.com/ageldama/configs/commit/a8f6c9b0c9e5172aaa507e2c765d059ea40b56c8#diff-844fd039f1d7faf1317fa95b88940eb7\n\u0026hellip; 점점 더 Emacs/Elisp 이용해 내가 쓰는데 적합한 환경을 만드는데 익숙해지고 편안한거 같다. 그냥 적당한 패키지 있으면 확장하고, 사용하기 좋게 만들기도 재밌는거 같고.\n그냥 이맥스에서 만족하고 살고, 계속 확장하면 된다는 마인드가 되어가는거 같기도 해서\u0026hellip;\nCtags/Etags/Cscope/Xref\u0026hellip; 다만 Semantic이나 CEDET 은 여전히 쓰고 싶지 않았다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/ageldama/configs/blob/master/emacs/compile-commands-json.el\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nsplit-string-and-unquote도 딱히 마음에 들게 동작하지는 않았고, 찾은 한 Elisp라이브러리는 동작하는것처럼 보였지만, 조금만 파싱할 커맨드라인이 길어지면 스택 오버플로우. 구현을 고쳐서 Merge request할바엔 그냥 안쓰는게 나을거 같았다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlycheck + GCC/Clang은 심지어 그냥 Flycheck에 내장된 체커를 사용하고, 이들이 제대로 동작하게 연동만 해주는 작업.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n완성된 결과품을 쥐어주고, 수정도 못하게 만들어놓기보다는.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n현재 파일이름을 갖고 CMakeLists.txt까지 파싱해서 매칭하면 되겠지만..\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nM-x compile이 좋은게, 한번 실행한 다음에 g 눌러서 변경점을 반영해서 다시 실행하면서 고쳐나가거나, C-u g 눌러서 실행 커맨드를 조금 바꾸거나 하면서 계속 실행하기 좋아서. 원래는 comint-mode 이용해서 직접 실행 버퍼를 구현했었는데, 그것보다 더 편해졌다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/2019-02feb26-ping/","title": "💘 Ping  26/02/2019",
     
     "tags": ["ping", "원숭이섬의비밀", "steam", "steamplay", "발더스게이트", "flatpak", "steamos", "unavowed", "freebsd", "i3gaps", "i3wm", "bluetooth", "emacs", "beos", "os2", "nextstep"],
     
 "description": "",
 "contents": "게임: 발더스게이트EE, \u0026lsquo;원숭이섬의 비밀\u0026rsquo; SE + SteamPlay, 등등 아주 예전에 발더스게이트2을 열심히 했었는데, 스팀에 Enhanced Edition들 올라와있었다. 발더스게이트1, 2 모두. 시간이 될때마다 조금씩 플레이 중.\n새로 UI이나 그래픽 요소들 등등 리마스터 한건지 훨씬 좋아진거 같다.\n원숭이섬의 비밀: Special Edition 이것도 시간날때 플레이. ScummVM 으로 옛날 그래픽으로 다시 해도 좋겠지만, 오히려 애니메이션이나 그래픽 다시 그린게 나는 더 마음에 들어서 이쪽이 좋은거 같다.\nUnavowed. 이런류의 어드벤쳐 꾸준히 만드는 \u0026ldquo;WadjetEyeGames\u0026quot;이 내 취향에 잘 맞는걸 계속 만들고 있는거 같아서 기뻤다.\n스팀플레이, SteamOS, Flatpak 예전 포스팅 에서는 그냥 Pacman으로 직접 패키지로 설치했다가, 이번에는 Flatpak으로 다시 Steam을 설치했다.\n그냥 적당히 잘 굴러가고, 스팀플레이도 잘 동작해서 깔끔한거 같다.\n스팀OS 만든다고 리눅스에서 게임들 동작하게 만들고, 스팀플레이 같은 게임이 직접 리눅스를 지원하지 않아도 실행 가능하게 되서 진짜 너무 편안한거 같다.\n친구를 만나기 오랬만에 친구와 약속을 잡고 만나고 이야기를 하고 걷고 햇볕을 쬐고 시간을 보냈다. 얼마만인지 잘 모르겠다. 예전에는 항상 이렇게 살았던거 같은데, 나이가 들어가고 내 삶이 중요하다고 생각하게 되면서, 더 달라지는거 같다. 즐거웠었다.\nFreeBSD을 데스크탑으로 사용하기 FreeBSD을 예전에 설치해보고 시도해보다가, 그냥 묵혀놓고1 그냥 딱히 쓸일이 없겠구나 싶다가 재미로, 혹은 약간의 기대를 갖고 다시 시도해봤다.\n그냥 정겨운(-거의 외양은 변한게 없는-) installer TUI.\n적당히 잘 동작하고, 걱정하던 무선랜 드라이버도 국가코드만 잘 선택하니까 잘 돌아갔다.\n제일 고생한건 NVidia 그래픽카드 드라이버 같은데, 그것도 사실 그냥 패키지 설치하고 인스트럭션 따라서 주욱 해나갔으면 바로 동작했었을거 같다. 이것도 빠르고 깔끔하게 잘 동작하고.\n어차피 데스크탑 환경은 i3-gaps 같은걸로 직접 설정해서 사용하니까 조금 시작 스크립트 같은것들만 고쳐서 마음에 드는 수준으로 설정 완료.2\n사실 별로 다를것도 없는것들, 좋던점들 바꾸긴 했는데, 어차피 대부분은 원래 약간은 알고 있던것들이고\u0026hellip;\nFreeBSD handbook, ports collection, pkg, 리눅스의 systemd이나 약간씩 다 다른것에 비해 간단한 설정방법 등등.\n딱히 놀랄거 없이 알고 있는대로, 혹은 핸드북이나 구글링해서 설정해나가면 리눅스보다 더 깔끔하고 몇가지 지루한 패턴으로 해결이 가능한 문제들3.\n거기에 사용하는 환경도 리눅스인지, BSD인지 알기 어렵게 zsh, Emacs등등을 사용하고, 더 나아가서 자잘한 도구들도 왠만한건 다 동일하게 있어서. 하루 정도 설정하니 더 설정할게 없었었다.\n사운드 설정, USB 장치들 드라이버, 엄청나게 깔끔하고 걱정할게 별로 없던 Ports collection, Pkg 같은점들 너무 마음 편안하고 쓰기도 편하고, portmaster, portsnap같은 추가적인 도구들이 있어서 좋았었다.\n당분간은 기대하기 어려울만한점들 그래도 몇가지는 서운했음.\n스팀 동작하게 만들어볼까했는데, 너무 무의미한짓일거 같아서 포기.4 블루투스 스택이 별로\u0026hellip; https://forums.freebsd.org/threads/how-to-bluetooth.64797/ 리눅스에서는 그냥 적당히 잘 동작하는 Suspend to RAM/Disk이 후자는 BIOS지원이 필요하다면서 안됨.5 전반적으로 엄청 든든하고 빠른데, 오히려 리눅스에서는 경험 못한 시스템 정지를 한번 경험함.6 리눅스에서도 그렇긴하지만, 조금 더 크고 많은 파일들을 복사하거나 하면, 시스템의 다른 프로세스들은 블록되는 현상은 더 심하고 시스템이 멈춘걸로 보이게 만드는거 같았다. 몇몇은 특별한 일들이 없는 이상 개선이 어려울거 같고, 역시 리눅스보다는 contributor들의 수가 다르긴한가보다 생각.\n결론 굳이 BSD을 계속 써야할것도 모르겠어서 일단 다시 아치리눅스 데스크탑으로 돌아오기로 결정했다.\n그냥 재밌는 경험이었었고, 오히려 재미로, 가상머신이 필요할때 VirtualBox에 설치해서 계속 사용할거 같긴하다.\n중고등학생 때, 그땐 대부분 넥스트스텝, BeOS, OS/2 같은것들도 허얽허억 했고, 레드햇 계열보다는 데비안 계열에 대한 선망이 있어서 데비안 woody 설치하고 사용하고 그랬었을때인거 같다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFreeBSD 환경을 위해 내가 작성한 설정, 스크립트 파일들 \u0026ndash; https://github.com/ageldama/configs/tree/master/i3wm/desktop-freebsd\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n거의 항상 /etc/rc.conf 이나 /boot/loader.conf 수정 정도니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSteam 리눅스용을, FreeBSD에서 가능한 Linux binary compatibility 이용해서 돌리면 가능하겠지만\u0026hellip; 어차피 SteamPlay 같은걸로 돌리면 또 거기에 Wine으로 윈도 게임을 리눅스에서 돌릴건데\u0026hellip; 끔찍할거 같았다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\u0026ldquo;11.13.2.2. Suspend/Resume\u0026rdquo; https://www.freebsd.org/doc/handbook/acpi-overview.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNVidia proprietary driver에서 Oracle VirtualBox으로 Windows XP 돌리면서 다운됨. 모든 조합이 조금 불안해보이기는해서 \u0026lsquo;그럴수도 있지 뭐\u0026rsquo; 이지만, 리눅스에서는 그냥 별 문제가 없었던거니까. 이런 케이스 이외엔 안정적이었다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/internet-sharing-networkmanager-dnsmasq/","title": "💧 NetworkManager + dnsmasq으로 인터넷공유 만들기",
     
     "tags": ["networkmanager", "dnsmasq", "dhcp"],
     
 "description": "",
 "contents": "필요성, 궁금함, 현재 상황 메인 데스크탑을 무선랜으로 인터넷에 연결하고 사용함. 다른 기기들도 모두 기본적으로 무선으로 LAN접속. 다 좋은데, 메인 데스크탑 \u0026lt;-\u0026gt; 라즈베리파이 접속할때 ssh 접속도 느린거 같을때가 있음. 무선랜 접속이 많고, 블루투스 등등 다른 간섭도 많을거고, 어쨌든 조금 물리적으로 거리가 있는 무선공유기까지 갔다 오는거니까. 그래서 사용 안하고 있는 데스크탑의 내장 유선 랜포트로 인터넷연결을 공유하는 Private network을 만들어서 유선으로 연결해보기로 했다. 정말 체감이 빨라질지 궁금했고 직접 수동으로 설정하는게 거의 없거나, 내가 사용하고 있는 NetworkManager에서 쉽게 설정이 가능할거 같았다. - https://wiki.archlinux.org/index.php/NetworkManager#Sharing_internet_connection_over_Ethernet 진행과 추가적인 설정 그냥 nm-applet 사용해서 wired connection에 인터넷 공유를 체크한게 설정 전부. dnsmasq 패키지만 설치하고, 별도로 systemctl으로 enable/start한건 없음. (NetworkManager에서 자동으로 관리) 잘 동작함. ㅎㅎ 추가적으로, Private Network에 접속하는 호스트의 MAC 어드레스에 IP주소를 고정해서 접속이 편하도록 설정했다. MAC주소에 고정IP 할당하기 dnsmasq의 DHCP 설정을 추가한다. /etc/NetworkManager/dnsmasq-shared.d/static-ips.conf 파일을 작성했다. 별도의 재시작 없이, 파일 저장하고, 그냥 유선연결을 끊었다가 다시 연결하면 끝. 나머지는 NetworkManager이 다 자동으로 처리. 설정파일의 내용은 1:\ndhcp-host=aa:bb:cc:dd:ee:ff,10.42.0.123 팁 할당된 IP주소 등을 계속 보려면, ip address 커맨드랑 NetworkManager, dnsmasq DHCP 로그 등은 그냥 sudo journalctl -f 열어놓고 보면 조금 더 동작 이해하기 편함.2 감상 의도한대로 훨씬 부드러운 연결3 생각보다 훨씬 단순한 설정이어서 NetworkManager 좋다. 그냥 처음부터 유무선공유기 남는걸로 브릿징해서 구성해도 괜찮았겠지만, 공유기 놓고 그러기 물리적으로 귀찮았다. https://wiki.archlinux.org/index.php/dnsmasq#DHCP_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n사용하고 있는 배포판/시스템이 systemd이라면.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nssh같은건 터미널에서 타이핑할때도 네트웍 커넥션 속도에 따라서 빠르고 느린게 느껴지니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/2019-02feb07thu-ping/","title": "🦍 Ping 07/02/2019",
     
     "tags": ["ping", "programming", "golang", "ripgrep", "helm", "swoop등의", "occur", "counsel", "ivy", "perl", "awk", "jq", "gnu-parallel", "sqlite3", "sqlite"],
     
 "description": "",
 "contents": "Golang 사랑 회사일로 Golang을 다시 잡고 쓰게됐다.\n예전에도 잠깐 썼었는데1, 이번엔 그냥 더 오래 진지하게 필요에 의해서 쓰게됐다.\n지금 일터에서도 필요에 의해서 작은 프로그램을 작성하고 할 일이 있어서 쓰다가 아예 서비스 코드에 적용을 하려 일하고있다.\n많은걸 더 깊이 생각하고 익히는 좋은 계기로 꾸준하게 사용하고 있고, 만족스럽다. 대부분의 경우에. 그리고 Emacs와 연동도 좋고 언어 자체의 설계나 그런점들도 너무 좋은거 같다.\nGC이 있는 언어를 최근에는 꺼리다가 다시 사용하니까 좋은것 같아. 그냥 문법적은 모호함이 없고 단순함, 머리에 쉽게 기억할만한 규칙들, 혹은 아예 어떤 규칙도 기억할 필요가 없도록 만들거나 하는게 얼마나 설계에 좋은지 깨닫는다.\n진지한 커다란 애플리케이션에서 작은 커맨드라인 도구까지 그냥 만들기 참 좋은 언어인거 같다.\n단순히 코딩을 하고 실행하고, 테스트케이스를 돌려보고, 그런 각 싸이클이 너무 복잡하거나 느리지 않고 밸런스가 정말 잘 맞는 언어와 툴링인거 같아서 사랑스럽다.\n최근에는 유일하게 Go언어에서 싫어하던 $GOPATH도 go111-module으로 해결되고 하는거 같아서 더 좋아졌다.\nPerl, C++, Golang, 커먼리습 같은 언어들이 점점 더 좋아지는거 같다. 공통점은 딱히 Functional하지도, 그런걸 병적으로 추구하지도 않으면서 잘 동작하고, 그렇게 예쁜 코드를 짤 수 있도록 해주지도 않지만, 정말 잘 동작하고 튼튼하고 그래서 가장 생산적인거 같아서.\n이맥스, Helm에서 Ivy+Counsel으로 오랬동안 개인 이맥스 설정을 Helm을 중심으로 설정해놓고 잘 쓰다가, 이번에 Counsel/Ivy 기반으로 모두 바꿨다.2\n좋은점들만 적어보면,\nHelm에서 Swoop등의 내용을 Occur형태의 버퍼로 저장할때, 지원여부가 검색에 따라 잘 안될때가 더 많았었는데, Ivy에서는 무조건 된다. ivy-occur 기능이 무조건 동작이라 정말 편하다.3 ivy-occur에서 또 wgrep으로 바로 수정도 편안하다.4 가볍다. 그리고 별거 아니지만 훨씬 탄탄한 느낌이다. (에러 없이 동작하고, 설정도 깔끔하고) Ripgrep이랑 out-of-box으로 연동되어서 편하다.5 그냥 만족하고 오랬동안 쓸만한거 같아. 거기에 find-file이나 swiper등에서 regexp으로 입력이 되거나, fuzzy-matching이 되거나 하는것들도 내가 익숙한쪽으로 설정이 다 가능해서 편안하다.6\n새로 알게된 모르는것들 그냥 그간 내가 잘 안다고 생각했지만, 사실은 잘 모르는것들에 대해서 생각하기 시작했다.\n예를 들어, SQLite3이라던가 하는걸 이용해서 커맨드라인에서 활용하기, GNU Parallel, Awk, Perl, jq 등의 도구들을 잘 활용하는것들을 얼마나 게으르게 익혀왔었던가 생각해본다.\n문서도 충분히 많고7, 충분히 커맨드라인이나 스크립팅으로 할 수 있는 일들이 강력하게 많은데, 그런것들을 읽거나 깊이 생각하고 중요하게 여기지도 않았었던거 같다.\n결과적으로 내가 매일의 무언가 작업을 할때마다 힘들고 더 안좋은 방법을 선택하게 되는것도 내 탓이었었던거 같다.\n그냥 조금만 그런것들이 그냥 멍청한 과거의 유산이 아니라, 내 오늘과 내일을 더 편안하고 낫게 만들어줄 방법이라는걸 생각하고 대했더라면 후회스러웠다.\n도구에 집착하는 사람이 도구의 노예인가, 아니면 도구에 집착하지도 않아서 도구를 제대로 쓰지도 못하고, 도구를 활용하지 못한채 힘들게 지내거나, 도구를 어떻게 쓸까 전전긍긍하는쪽들이 도구의 노예인가?\n진짜 도구를 다루는 일은 그걸 직면하고 잘 익히고 그 가치를 잘 이해하고 사용하는쪽인것 같다.\nhttps://github.com/pazuzu-io/pazuzu 잘란도 온보딩 마지막에 회사내 프로젝트 인큐베이터에서 Golang으로 작업할일이 있었었다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n새로운 설정 파일=https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2019 / 예전 설정파일=https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://oremacs.com/swiper/#saving-the-current-completion-session-to-a-buffer\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/mhayashi1120/Emacs-wgrep\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHelm은 다른 플러그인을 더 깔거나 해야 했고, 그나마도 Projectile등이랑 또 궁합이 막 안맞는거 같고 그래서 힘들었었다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n앞으로 이맥스에 내가 사용하는 프로그래밍 언어나 기본 키 바인딩, 창-버퍼 조작 방법, 파일 검색이나 프로젝트 검색 같은 워크플로우 같은것들을 정리해서 포스팅하고 공유할까 생각중.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n대부분의 시스템에 Bash이나 jq, GNU Parallel, Awk 같은것들의 Manpage이나 Info문서들이 기본적으로 설치되어있을텐데.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2019-02feb/2019-02feb07thu-gosched-fun/","title": "🟡 Golang Goroutine, Channel, I/O 그리고 Scheduler 이해해보기",
     
     "tags": ["programming", "golang", "concurrency", "asyncio", "scheduler"],
     
 "description": "",
 "contents": "Go언어를 요즘에 진지하게 생각하고 계속해서 자료를 찾아보며 익히고 있다.\n가장 흥미있는 부분은 Goroutine scheduler 구현과 I/O시스템을 어떻게 만들었을까인데, 아직은 소스코드를 뜯어 읽고 하지는 못하지만, 그냥 내가 만들었다면 아마 이렇지 않을까 하는 정도의 추측을 갖고 반대로 예제들을 만들어보며 확인해보고 있다.1\n우선 현재의 추측은 다음과 같다.\nGOMAXPROCS 같은걸 이용해서 실행시간에는 필요한만큼만 최소한으로만 OS Thread을 시작하는듯. 2 너무 많은 스레드가 있어도 어차피 Context switching 비용만 늘어나고 별 의미는 커녕 더 나쁠 수 있으니까. Goroutine들은 Go runtime의 Scheduler이 서로 실행기회를 나눠준다. 실행기회를 다른 goroutine에 yield하는 방법은, I/O operation을 실행하거나 Channel에 Receive/Send할때 위 (2.2)에서 I/O operation이 Async I/O으로 구현되었을거라고 생각. 왜냐하면, 그래야 blocking 안되고, Go scheduler으로 실행이 넘어가고, Go scheduler은 I/O event loop을 통해서 적절하게 다음에 실행할 Goroutine을 결정할 수 있을테니까. 예제 프로그램 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func timer(wg *sync.WaitGroup) { fmt.Println(\u0026#34;timer started\u0026#34;) select { case \u0026lt;-time.After(3 * time.Second): // NOTE: this never happens while it can\u0026#39;t get any chance to run by scheduler wg.Done() } } func printer() { for { // DO NOTHING // NOTE: doing any I/O here can yield to gorountine scheduler } } func main() { var ( wg = sync.WaitGroup{} ) runtime.GOMAXPROCS(1) wg.Add(1) go printer() go timer(\u0026amp;wg) wg.Wait() fmt.Println(\u0026#34;bye\u0026#34;) } 실행결과, 결론, 생각 예상한대로,\n강제로 GOMAXPROCS=1으로 설정하고 실행했고, go printer()에서 I/O실행이나 time.Sleep 같은거 안하고, 그냥 무한루프3 반대로 말해서, 위 func printer()의 루프 안에서 time.Sleep, fmt.Println 중 하나라도 실행을 하도록 하면, Go scheduler이 기회를 얻는다. go timer(..)이 실행기회를 받지 못함. 시작은 되지만, time.After(..)을 통해서 타임아웃하여 종료처리를 못하게됨. Race condition. 현실적으로는 무한루프에서 어떤 I/O을 수행하거나 time.Sleep이라도 한다면 싱글코어만을 활용하는 경우에도 goroutine이 적절하게 스케쥴링될테니 문제가 없겠지만, goroutine들이 어떤 방식으로 스케쥴링되는지 이해하기 좋은 기회였던거 같아.\n결국, Go와 같은 Goroutine, Channel만이 중요한게 아니라, Go runtime이 제공하는 I/O들도 Node.js와 같이 비동기적으로 내부적으로 처리될거고, 이 이벤트루프와 스케쥴러가 잘 연동되어 있을거라 상상할 수 있다.\n이런 Goroutine, Scheduler의 특성을 잘 이해하고 있지 못하다면, 단순히 어떤 고루틴에서 I/O등이 없이, CPU연산만 열심히 하는 무한루프를 만들고 한다면 정상적으로 동작하지 않는 애플리케이션을 만들고 의아할 수 있으리라 생각.\n그리고 더 무섭게도 이 애플리케이션은 다음과 같은 특성을 갖게 될거임:\nPrintln이라도 하나 찍어보면 잘찍히고, 그게 들어가면 또 잘동작하게됨. (I/O연산이니까.) 다른 머신(코어가 더 있거나, GOMAXPROCS이 더 크게 설정될)에서 실행한다면 똑같은 바이너리가 또 제대로 동작함. \u0026hellip;ㅎㅎㅎ\n이미 이런 방식의 CSP 동시성은 과거 Clojure의 core.async을 통해 익혀서 익숙. 그리고 이걸 뜯어서 이해 하는것도 나쁘지 않을거 같긴하다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://golang.org/pkg/runtime/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n그냥 x += 1 같은 순수하게 CPU만 사용하는 연산들도 마찬가지로 Scheduler에 yield하지 못한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/","title": "🧡 ASDF으로 간단한 의존성 연결과 로딩하기",
     
     "tags": ["lisp", "programming", "commonlisp", "common-lisp", "asdf", "quicklisp"],
     
 "description": "",
 "contents": "System? 이런게 왜 필요하지? require있잖아 대부분의 유명한 프로그래밍언어들이 커먼리습의 System 에 대응하는 기능이 명확하게 없으니까, 다른 프로그래밍 하거나 하는 방법으로 이야기를 하지는 않아야겠다.1\nhttps://lispcookbook.github.io/cl-cookbook/systems.html 에서 마음에 드는 설명을 찾을수 있다.\nA system is a collection of Lisp files that together constitute an application or a library, and that should therefore be managed as a whole. A system definition describes which source files make up the system, what the dependencies among them are, and the order they should be compiled and loaded in.\n즉,\n커먼리습의 네임스페이스, Packages 은 그냥 심볼들을 묶는 데이터타입이고, 함수나 변수 같은 심볼들이 특정한 타입에 따라 정리되어있을뿐이다.2 다른 말로, 어떤 패키지 X은 한개의 소스파일에 대응하지 않을수도 있고, 심지어 한개의 소스파일 xyz.lisp 이 X, Y, Z 3개의 패키지를 선언할수도 있는거니까. (역으로 하나의 패키지를 여러개의 소스파일으로 구성도 할수있고.) 커먼리습은 특성상 현재 로드된 함수 등의 원래 소스코드와 직접적인 연관을 갖지 않는다.3 결국 다른 언어들처럼 단순하게 패키지 이름등으로 import, require한다고 그걸 적절한 매칭하는 파일/경로이름으로 변환하는 과정이 없고4, 그렇게 하기도 난감하다.5 그런데 다음과 같이 의아할 수 있겠다.\n그러면 CLHS에 명시된 *modules*, require, provide은 뭔가? load은 그렇다치고, 컴파일은 그냥 Makefile 쓰면 안되나? 커먼리습의 패키지(Packages) 이랑은 다른건가? A-1. *modules*, require, provide 결론부터 말하면, 이젠 *modules*, require, provide은 CLHS에는 있지만 이젠 쓸일이 없다.6\n*modules*, require은 현대에는 그냥 ASDF인것처럼 동작한다. 하지만 편의를 위해 제공하는것뿐이지 딱히 정확하지도 않고, 계속해서 이것들을 사용할 이유도, 그래서도 안될거 같다.\n이런 기능들 자체가 커먼리습에 시스템 이란 개념이 제대로 정립되기 이전에 나온것들일거고, 굳이 사용할 이유가 없어진거 같아서 그런거 같다.\n그렇지만, 여전히 load이나 *feature* 같은 System Construction 관련 항목들은 여전히 유용하다.\nA-2. load을 그대로 써도 된다만\u0026hellip; Makefile만은\u0026hellip; 위의 패키지 구성하기 에 따라서 제대로 구성하려면,\nload을 이용해서 패키지를 선언하는 소스파일부터 패키지의 내용을 채워넣는 파일들을 의존관계의 순서에 따라서 하나씩 로딩하는 스크립트를 짜서 제대로 로딩하기만 하면 된다.\n그런데, 이걸 단순히 내 손으로 하기도 어렵겠고(귀찮고), 어떤 시스템 하나를 로딩할 때, 그것에 의존하는 또 다른 시스템에 대해서도 이런 로딩 절차를 선행해주기는 끔찍할거 같다.7\nA-3. 패키지랑은 다른것. 이미 위에 이야기를 했지만, 시스템은 패키지들의 묶음로 생각할 수 있다.\n일반적으로, zxc이란 시스템을 만든다면, 아마 zxc이란 패키지는 적어도 하나 있을거고, zxc의 하위 패키지들도 이 시스템에 넣을것 같다.\n그래서, asdf 같은 것들이 생기고 필요해짐. 뭐, 위와 같은 이유들로 시스템이란 개념을 만들어서 프로젝트 단위의 빌드나 의존성들을 커먼리습에서는 관리한다.8\n이 포스팅에서는 ASDF 에 대해서만 이야기한다.\n하지만, 어차피 소스코드를 조직하고 빌드하고 이미지로 로딩하는 방식이고, 표준에서 정한것이 아니고 커뮤니티의 de facto인거니, 다른 대안들도 있다.\nASDF? Quicklisp? ASDF은 시스템을 defsystem 정의하고, 이렇게 작성한 .asd 파일을 찾고 load, compile, test등의 작업을 적용할 수 있게 해주는 operation들을 적용해주는 부분이 있다.\n그리고 조금 헷갈리지만, 현대에는 오픈소스 리습 라이브러리를 다운로드까지 받아 한번에 로딩할 수 있게 해주는 Quicklisp도 있는데, ASDF와 유사해보이지만9 엄밀하게는 ASDF을 지원해 이런 기능을 구현한것이고 아예 별개이므로 혼동하지말자.\n그리고 이 글에서는 Quicklisp을 이용하는 방법이 아니라, ASDF으로 시스템을 구성하고 로딩하고 하는 기초를 이야기하려고 한다.\n그리고 ASDF에 대한 더 좋은 문서로 https://lisp-lang.org/learn/writing-libraries 을 읽어보기도 권한다.\n간단한 프로젝트 만들어서 준비 프로젝트를 처음 만드는 방법은 몇가지 있지만, 나는 선호하는 툴인 quickproject을 Quicklisp을 통해 로딩해서 프로젝트를 생성한다.10\n1 2 CL-USER\u0026gt; (ql:quickload :quickproject) CL-USER\u0026gt; (quickproject:make-project #P\u0026#34;~/P/cl-adder\u0026#34;) 위와 같이 실행하면, ~/P/cl-adder 디렉토리에 cl-adder 이란 이름으로 새로운 빈 프로젝트를 만든다.\n대강의 프로젝트가 생성되면 다음과 같은 형태를 갖는다.11\nhttps://github.com/ageldama/cl-adder\n기본 규칙들 생성한 골격을 설명하면:\ncl-adder.asd defsystem으로 내가 새로 만든 프로젝트의 시스템을 선언하고있다. 다른 시스템에 대한 의존성을 지정할수도 있는데, 여기엔 의존할게 없으니 없다. 더 중요한건 로딩할 리습 소스코드 파일들의 목록을 :components 으로 나열하고 있다.12 package.lisp defpackage으로 시스템에서 정의하는 패키지들을 선언. (defpackage와 커먼리습의 Packages 대해서는 http://clhs.lisp.se/Body/11_.htm 이나 커먼리습 서적들을 참고하면 좋을거 같다.) 각 패키지별로 public으로 노출할 심볼들이나 패키지 내에서 참조할 다른 패키지를 나열. 시스템에서 정의할 패키지들을 defpackage으로 계속 나열해나가기. cl-adder.lisp 실제 변수나 함수 같은 패키지에 속할 심볼들, 그리고 내부 구현들을 여기에 코딩. 패키지 선언은 이미 package.lisp에서 다 된걸로 생각하고, 여기서는 어떤 패키지에 속할 심볼인지에 따라서, in-package을 이용해서, 그 이후에 따라오는 소스코드 라인에서 정의하는 defvar, defun등은 해당 패키지에 속하도록. 다른말로, 여러개의 패키지가 있다면 in-package을 번갈아가며 지정해서, 하나의 .lisp 소스코드에서 여러 패키지에 속하는 내용들을 다 정의할 수 있다. 사용하기 위 소스에서는 cl-adder:add이란 함수를 구현하고 export한다.\n이젠 이 시스템을 의존성으로 사용하는 다른 시스템을 만들어보겠다.13\n다른 중간 과정을 모두 설명을 생략하고, 참조하는 한 라인만이 중요한거 같다. https://github.com/ageldama/cl-use-adder/blob/master/cl-use-adder.asd\n여기에서,\n1 2 3 4 (asdf:defsystem #:cl-use-adder ... :depends-on (\u0026#34;cl-adder\u0026#34;) ... depends-on으로 참조하는 시스템의 이름을 적어준게 전부다.\n나머지는, cl-use-adder 시스템의 package.lisp에서 (defpackage ... :use)을 이용해서 패키지의 심볼들을 import할수있겠지만, 이건 그냥 코드에서 cl-adder:add으로 참조하느냐 add으로 참조하느냐의 차이만을 만들고, 실제 의존관계를 표현하는것은 아니다.\n그런데, 이걸 어떻게 로딩한다고? 이렇게 2개의 cl-adder, cl-use-adder 시스템을 만들고 의존관계를 만들어봤다. 그런데, 이 2개의 시스템을 커먼리습 이미지에 어떻게 불러오는지 설명하지않았다.\n어쩌면 누군가는 시도를 해보고 실패하고 짜증이났을지도 모르겠다. 미안하다\n예를 들어, 다음을 실행하면 그냥 실패할것이다.\n(asdf:load-system :cl-use-adder) 혹은 (asdf:load-system :cl-adder)\n가장 간단한 방법은 symbolic link을 이용하는것이다.\n다음을 실행해보자.\nmkdir ~/common-lisp ln -s $SOME_PATH/cl-adder.asd ~/common-lisp ln -s $SOME_ANOTHER_PATH/cl-use-adder.asd ~/common-lisp 그리고 실행하던 커먼리습 이미지를 (quit)하거나 새로 시작해서,\n(asdf:load-system cl-use-adder)을 실행하면, 의존성인 cl-adder을 포함해서 로딩할것이다.\n더 자세한 내용들은 https://common-lisp.net/project/asdf/asdf.html#Controlling-where-ASDF-searches-for-systems 여기에서 설명하고 있으며, 설정 파일 등을 이용하여 하위 디렉토리를 검색하여 자동으로 .asd 파일을 검색하도록 하는 방법도 있다.\n그냥 legacy, asdf:*central-registry* 쓰기 여기서 설명하는건 예전의 방식이고, 현재의 ASDF3은 위에 설명한 설정파일에 명시하는걸 권장합니다.\n단순하기는한데, 가능하면 위에 설명한 심볼릭링크나 설정파일을 이용하는걸 권장한다. ASDF2 버젼에서도 이미 앞으로 deprecated할 방법이라고 설명했었던거 같다. 가능하면 사용하지말자.\n하지만, 몇몇 편의를 위해서 이렇게 사용하는 경우도 있긴한데, 나쁜짓인거 같긴하다.\n마무리 생각 ASDF은 단순히 로딩만 하는데 사용하는것이 아니라, 다음과 같은 일들을 하는데 사용하는게 보통인거 같다.\n시스템의 테스트suites을 실행하기 시스템의 컴파일 뭐 로딩하려면 필요하기도 하고. 시스템을 로딩한 이미지/실행파일의 생성14 https://github.com/ageldama/cl-use-adder/blob/master/cl-use-adder-adder-app.asd https://github.com/ageldama/cl-use-adder/blob/master/build-adder-app.lisp 위에서처럼 (defsystem ... :build-operation :build-pathname :entry-point), ..(asdf:operate :build-op :cl-use-adder-adder-app)와 같이. 그리고 커먼리습 오픈소스 커뮤니티의 나름대로 표준이기 때문에 잘 이해하고 사용하는게 좋을거 같다.\n또한, 다른 커먼리습의 부분들과 마찬가지로 ASDF자체도 단순하게 커먼리습 이미지에서 실행하는 함수들일뿐이고 모든 데이터에 접근할수있다. 예를 들어, 다음과 같이 로딩된 시스템의 정보를 Inspect해볼수있다.\n(inspect (asdf:find-system :asdf))15\n그리고 이런 시스템 모델 이외에, 내 프로젝트의 특성에 따라서 더 적절한 방식으로 .asd 파일을 찾아서 로딩하게 만들수도 있다.\nasdf:*system-definition-search-functions* 리스트에 string -\u0026gt; pathname-OR-nil이 타입인 함수를 만들어서 추가하면, 내가 원하는곳에서 주어진 이름의 시스템을 로딩하도록 할수있을것 같다.\n다른 커먼리습과 마찬가지로 뭔가 내 마음대로 할수있는 유연한 도구들, 툴킷을 제공하는 느낌의 프레임웍인것 같다. 그러면서도 세세하고, 매뉴얼을 읽고 이해하는 재미와 이점도 충분히 있는.\n사실 Java 9의 Jigsaw 같은 개념이 비슷하다고 할수도 있겠지만, 솔직히 둘은 다른거 같다. 그리고 파이썬, 루비, 자바스크립트 등등에서 수많은 프로그래밍 언어들이 이야기하는 패키지 가 이에 해당하는거지만, 커먼리습의 시스템 와의 가장 큰 차이는 명확하게 실행시간에 first-class 객체로 시스템 자체에 접근하고 설명할 수 있는점이 커먼리습과 나머지와의 차이인거 같다. 물론 나머지도 확장 패키지를 불러서 그렇게 접근이 가능하긴하다만 커먼리습은 자체의 특성 때문에 이렇게 될수밖에 없었겠지.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n다른 패키지를 상속해 사용하거나, 해당 패키지 내부에서만 참조가 가능한 심볼이나, 외부에서 사용할 수 있도록 노출된 심볼이라거나 하는 등으로.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n물론 실제로는 (커먼리습 구현체에 따라 다르겠지만) 함수나 심볼에 대해서, 원래의 소스코드 pathname을 property등으로 설정해놓고 디버깅이나 소스코드 navigation을 위해 제공하지만.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n우리가 흔히 알고 있는 파이썬의 site-packages 같은 규칙이나(https://docs.python.org/3/reference/import.html, https://nodejs.org/api/modules.html), 자바의 기본 클래스로더의 클래스파일 이름, 경로명 등으로 적절히 로딩하는 방식 같이 동작하지 않는다. ASDF 같은것 없이 기본적으로는.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n왜냐하면, 파일을 로딩하는것뿐이고, 실제로 모든 커먼리습 이미지 안에서의 의존은 이미지 안에 이미 존재하는 심볼들이라는 가정이니까. 굳이 복잡하게 참조시에 뭐가 일어나고 하는걸 생각하지 않는다. https://llvm.org/docs/LinkTimeOptimization.html 같은게 구현되기 어려운 이유일거 같긴하다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n혹여 다른 언어나 Scheme 등에서 사용하던 관성과 친숙함으로 이들을 사용하고 싶다고 하더라도 정말 말리고 싶다. 그냥 asdf 을 쓰시라.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n왜냐하면, 내가 작성했거나 조금 이해하기 좋은 시스템이 의존이라면 로딩 순서를 지키기 좋겠지만, 그냥 내가 잘 모르고 소스코드가 수십개 거나 그런 의존성이 한두개가 아닌 상황이 되면 결국 몇백개의 파일들을 손으로 그 순서를 지정해줘야할테니까. 현대에 조금 많은 의존성을 가질 웹프레임웍이나 그런 시스템을 이렇게 로딩하는걸 상상해보자.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n그리고 이런 시스템들을 로딩한 \u0026ldquo;내 이미지\u0026ldquo;와 \u0026ldquo;World\u0026ldquo;이란 더 큰 단위로 부르기도함.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.cliki.net/asdf-install 예전에는 Quicklisp와 유사한 이런 ASDF extension이 있었지만 지금은 별로 효용이 없다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nQuicklisp을 세팅해놓는게 필요. 자세한 방법은 https://www.quicklisp.org/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ncl-adder.lisp, package.lisp을 제외하고는, 그것도 1~2줄을 제외하고 처음 생성한 기본 그대로 커밋해놓았다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n그리고 :serial t이 지정되어 있으므로, 파일들은 나열한 순서대로 로딩될것이다. https://common-lisp.net/project/asdf/asdf.html#Serial-dependencies\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n테스팅을 추가하고 싶다면, cl-adder 시스템에 cl-adder.tests 같은 테스팅 시스템을 추가해서, 커먼리습용 테스팅 프레임웍을 이용해 테스트를 작성하기는 하겠지만 여기서는 생략했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n실행파일을 만들거나 이미지를 저장하는건 커먼리습 컴파일러마다 방식이 다르고, 이런걸 정리해주는 다양한 도구들이 있는데, 내게 편안한건 그냥 ASDF을 이용하는것 같다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSLIME이나 Sly같은 IDE을 사용한다면, (asdf:find-system :asdf)한 다음에 C-c I을 입력해서 Interactive Inspector을 사용할 수 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-11nov/03sat-ping/","title": "🩻 Ping 03/11/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "작위를 수여받았다 받아본 생일선물 중에 가장 귀여운거였다.\ntweet 1058052532839231488\n씨디리핑, 음악듣기 지난달부터 갖고 있던 씨디, 듣고 싶던 앨범들 다시 모으면서 리핑한 씨디들.\n조금 더 모으고 싶은 아티스트나 앨범들이 있는데 구하기 어려울거 같아서 걱정.\ntweet 1058666194616541184\n주말에 남는 시간에 씨디 리핑하고 음악 들으며 여유부리기.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/20sat-ping/","title": "🧐 Ping 20/10/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "날씨가 너무 좋은 가을.\ntweet 1053557185534251008\n만년필 만년필용 가죽 파우치를 찾았다. 들고 다니기 조금 더 편안해진거 같아.\ntweet 1053557157940015104\n회사분에게 고마운 선물로 딥펜을 받았다.\ntweet 1053557478925918208\n남이 필요한 행복에 대해 가끔 날이 좋으면 예전처럼 누군가와 함께 좋은 공기를 마시며 산책도 하고 숲에 가고 싶어진다. 특히 요즘 같은 선선한 계절에는.\n그런데, 꼭 그래야만 나는 행복함을 느끼나 생각해본다. 그냥 방안에 좋아하는 오디오로 라디오를 틀어놓고 침대에 뭍혀서 지내는것도 좋고 그냥 적당한 책을 재밌게 읽고 많은 생각을 할 수 있거나 좋아하는 펜으로 글을 써도 행복한거 같아.\n결국 꼭 내 어떤 행복들은 누군가가 필요하진 않은거 같다.\n그리고 그 반대인것도 있겠지 과거엔, 그리고 지금도 종종 다음과 같은 생각에 사로잡힌다.\nXYZ 같은걸 다 익히면/잘하면 행복해지고 부유하고 유명해지겠지?\n그런데 그걸 내가 아무리 잘알게 되더라도 그걸 적어도 다른 사람이 알거나, 그걸로 가치를 창출해내지 못한다면 무의미하다는 생각을한다.\nC++, 어셈블리로 아무리 최강의 게임엔진을 내가 만들려고 해도, 가끔은 자바로 마인크래프트를 만들었더라면 돈을 더 벌었을거 같다. 뭔가를 잘 아는것과 가치창출은 다른거 같아.1\n양극단에 이상하게 적용하는 사람들이 있는거 같다. 가치창출만 강조하는 사람들과, 가치창출을 하기 위해서는 어떤 기술등을 숭배해야한다고 말하는 사람들. 둘 다 별로 가치창출을 하는것 같지는 않다. 예를 들어, 적정한 가치창출을 하기 위한 정도도 제대로 지원이나 드라이브를 못하면서 그런거 다 의미없다고 말하기만 하거나, 현재도 앞으로도 아무런 가치도 없고, 심지어 시장에 무의미할 정도로 그런 기술을 적당히 쓰는 사람들만 있고 그 수준도 별로 높지 않은데 굳이 계속 그쪽만 고집하며 이상하게 변질되는 사람들.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/10wed-thought/","title": "🧇 생각 10/10/2018",
     
     "tags": ["ping", "thought", "programming", "doom", "john-carmack"],
     
 "description": "",
 "contents": "연구소에서 종종 휴식시간에 PS4 게임을 하면서 지낸다. 그냥 별로 게임을 위해서 너무 많은 시간을 보내는걸 원래도 좋아하진 않았지만 독일에 살며 취미로 다시 시작한 이후로 재미를 붙이고 하고 있었다.\n그리고 최근에 재밌게 하고 있던 DOOM 2016을 다른 게임들보다 내가 좋아하는걸 동료들이 눈치채고 가끔은 둠 이야기를 한다.\n최근에 그래서인지 John Carmack 이야기도 종종 나온다. 소프트웨어 엔지니어들이니까. 그러다가 한 동료가 Carmack의 에세이 하나의 링크를 보내줬었다.1\n많은 다양한 생각들을 추려낸 블로그포스트. 그리고 가끔 지나가듯이 다른 주제를 이야기하다 이 에세이에 담긴 만트라 에 대해서 다시 말하며 생각을 나눠본다. 그리고 더 그렇게하고 싶다.\n공감이 가장 가는 부분들은\n\u0026hellip;there are clearly better and worse ways of doing things but it’s frustratingly difficult to quantify.\n\u0026hellip;these are all conventions that help software engineering in the large when you’re dealing with mistakes that people make. But they’re not fundamental about what the computer’s doing.\n\u0026hellip;programmers are making mistakes all the time and constantly.\n\u0026hellip;I would like to be able to enable even more restrictive subsets of languages and restrict programmers even more because we make mistakes constantly.\n사실 다음처럼 말하면서 폼을 잡거나 꼰대를 부리기도 좋고, 사실 맞는 얘기겠지만 해본 사람들은 이게 어떤 차이를 갖는지 알게된다.\n\u0026ldquo;프로그래밍언어 거 그거 어차피 다 똑같은거야. if-else있고 루프되고\u0026rdquo;2\n\u0026hellip;말이야 맞는거 같지만, 차이가 있다는걸 우리는 알고있다. :-)\n차이를 알아야 하는 이유 일터에서의 어떤 논의에서 종종 _말 짜맞추기_를 하고 있는 경우를 경험한다. 나도 그렇고, 주변 사람들도 그렇고.\n내가 이야기하는 말 짜맞추기란,\n처음의 좋은 아이디어에 대해서 문제점을 찾았을때, 1. 그 아이디어의 원래 의도나 좋은 차이를 만드는 부분을 놓친채, 그저 뭔가 그 아이디어처럼 다 되는거 같고, 비슷해보이도록 꿰메어놓은 대안들 이런게 필요한 부분이 있긴 한거 같아. 그런 이런게 필요한 경우는 차이가 아무런 의미가 없을때 혹은 차이의 가치를 이해하지 못하거나 그럴 필요가 없는 사람들에게 떠먹여줄 대강의 핑계나 변명, 혹은 적당한 말들을 쥐어줘야할때인거 같다.3\n하지만 내가 싫어하는 부분은 그런 비슷한 무언가를 말들을 꿰메서 입맛에 맞게 만들었지만, 실제로는 원래 추구하려던 가치를 전혀 얻을 수 없도록 만신창이로 덕지덕지 그럴싸하게만 만든 말들을 들을때다.\n대부분의 돈벌이, 그것도 아주 허접하게 포장해서 제대로 돈도 벌지 못할거 같은, 그렇지만 신비로운 의사결정 단계를 거치며 뭔가 돈이 될거 같은것들은 몽창, 그리고 소비자가 좋아한다고 착각할만한것들을 모두 쏟아부은것들이 이런 모양으로 출시되는거 같아.4\nhttps://blogs.uw.edu/ajko/2012/08/22/john-carmack-discusses-the-art-and-science-of-software-engineering/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n언젠가 이거 말씀하신 수많은 아재중 한분은 회사에서 VB6인가로 월급벌이를 하고 계셨었다. 그리고 난 그 사람이 다른 언어는 만지지도 못할거라는걸, 그리고 만져도 끔찍한 그냥 다른 언어로 작성한 VB6 코드를 만들거라는걸 확신한다. 그리고 \u0026ldquo;대기업\u0026rdquo;-워너비라 대기업인줄 알고 그렇게 행동하던 그 아재는, \u0026ldquo;대기업\u0026quot;도 아닌 어정쩡한 기업에 다니다가 (법정관리를 몇번 겪다가) 지금은 뭘하고 있을지 상상도 하고 싶지 않다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n슬프게도 우리 사회는 이런게 너무 많이 필요하다. 그리고 종종 나쁘지 않을수도 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n이런 제품, 솔루션, 서비스들은 모든게 다 되는거 같고, 심지어 바라지 않는것들까지도 다 되고, 카탈로그만 보면 경쟁제품이랑 크게 다르지 않은것처럼 보이지만, \u0026hellip;이상하리만치 아무도 쓰지않고, 한번이라도 그걸 경험해보면 왜 다들 그러는지 잘 알수있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/10wed-steamplay-on-linux/","title": "👜 SteamPlay On Linux",
     
     "tags": ["steam", "steamplay", "gaming", "linux"],
     
 "description": "",
 "contents": "집에 있는 데스크탑에서 윈도10 그냥 사서 설치하고, 거기에 스팀 설치해서 게임이나 하는데 사용했었음\n거기에 대부분의 작업은 그냥 리눅스에서 하는게 훨씬 편하고 해서 Virtualbox에 아치리눅스 게스트 만들어놓고 거기에 접속해서 작업했었었다.1\n그러다가 SteamPlay이란걸 알게됐고, 모든 게임이 다 지원되는건 아니더라도 그냥 앞으로 나올 게임들중에 리눅스를 지원하거나 Wine을 통해서 실행할 수 있으면 이걸 쓰는게 더 낫고 윈도가 싫었다.2\n여튼, 좀 설치하고 써보니:\n모든 게임을 지원하지 않는다. 1. 적당히 지원될거라고 생각하던 게임들도 그냥 됐고, SteamPlay지원 안해도 돌려볼랜다 체크해봤자 제대로 안굴러감. 게임패드나 그런것 지원은 윈도보다 편안함. 그냥 USB 꽂으면 바로 동작. 처음엔 Flatpak같은걸로 설치해서 깔끔하게 해보려다가 그냥 Pacman으로 Runtime/Native 설치해서 오히려 속편함. NVidia Proprietary Driver 설치했으면, 조금 더 구글링해서 고쳐줘야할게 생김. 하프라이프2이나 그런것만 돌려봤는데 전혀 리눅스라서 따로 신경쓸건 없었다. 폴아웃3이나 그런게 동작 안하는건 너무 슬펐다.\n그렇다고 윈도측에 Git, Perl 같은걸 설치를 안하던건 아니어서 그게 더 혼돈과 파괘.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n윈도10 hibernation 사용해도 부팅하는데 10분씩 걸리고 아무것도 되는게 없고 짜증나서. 거기에 비해서 리눅스 부팅 바로되고 원하는대로 만들 수 있고, 사용하기도 나한테는 더 편안하고 쓸만한 애플리케이션들도 너무 많아서.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/06sat-cd-ripping/","title": "👇 CD Ripping!",
     
     "tags": ["cdrip", "linux"],
     
 "description": "",
 "contents": "요즘에 HiFiBerry DAC+으로 라디오, 음악을 들으며 귀가 즐거워서..\n갖고 있는 씨디가 별로 없는데, 이유는.\n음악을 듣는걸 게을리했었고, 딱히 음반으로 들었던건, 테잎 시대에 좀 사다가, 1. 씨디 시대엔 음원을 구하거나 사는게 더 많아지고, 2. 씨디를 듣지 않게됨. 그러다가 그냥 음질이 조금이라도 더 낫게 들을려고 CD ripping이 답이라는 결론을 얻었다.\n어차피 음원 사는거랑 비슷한 가격이 됨. 음원을 어차피 내가 만드는거라 원하는 음질으로 떠서 보관하면됨. 그리고 뭣해서 잃어버려도 다시 떠도됨. 결국 대장정을 시작했다..\n준비물들을 모았다. CD-ROM 드라이브를 어차피 구해도 SATA방식으로 구해야할거 같고, 그냥 굳이 내장형으로 붙이기 싫어서, USB방식 ODD으로 구매. USB이외에 전원이 따로 있어야 제대로 돌아갈테니, 전원이 빵빵하게 공급되는 USB허브를 구매. USB메모리스틱을 샀다. HiFiBerry 기계에 저장소로 붙여주려고. 그런데 생각해보니 용량이 부족해져서 결국엔 NAS을 조립하게 될거 같아. abcde 그냥 cdparanoia 이랑 FLAC 정도로 세팅을 하려고 했다.1\n뭘로 씨디를 떠야 편할까 고민하며 몇개 골라봤다.\n참고한 페이지 https://wiki.archlinux.org/index.php/Optical_disc_drive#Audio_CD2\n이것저것 보다가, 그냥 이름이 가장 미친거 같은 \u0026ldquo;abcde\u0026quot;을 골랐다.3\n그리고 세팅. https://github.com/ageldama/configs/blob/master/dot-abcde.conf\n처음에 CD넣고 abcde 실행하고 자동으로 CDDB fetch해서 트랙이름이랑 그런것들 자동으로 만들어주고, 원하는거 고르면됨. 정히 CDDB에서 못찾으면, Vim등으로 바로 아티스트, 앨범, 트랙이름 편집할 수 있게 해주는점에서 반했다. 예전 그러니까 90년대 중후반에 CD뜨고, MP3 처음 나왔을때 친구들이랑 신기해서 인코딩하고 그럴때랑 비교해보면 씨디 한장 리핑하기 시간이 정말 얼마 안걸린다. 심지어 인코딩 시간도 얼마나 걸린건지 알수없게 리핑한 직후 거의 바로 인코딩된것처럼 보일 정도. 매우 음질이나 사용하는것들 만족스럽다. tweet 1048431950745063424 감상 계속해서 이짓을 하고 싶어서, 과거에 좋아하던 음반들을 중고로 질렀다.\n결국엔 저장용량 확보와 안전한 저장을 위한 NAS 구축할거 같음.\n그리고 음악파일을 제대로 정리하기 위해 DB구조를 설계하게 될거 같다.\n고마워요 http://xiph.org!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nArchWiki이랑 GentooWiki 없었으면 나는 어떻게 살았었을까 싶다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n나중에 https://github.com/JoeLametta/whipper으로 갈아타야할까 고민중. 음질이 더 나으려나.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/05fri-ping/","title": "👰‍♀️ Ping 05/10/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "Lamy2000 사용하면서 tweet 1048150207110688768\ntweet 1048059130429100033\n잉크는 Lamy 잉크를 사서 쓰자. 다른 잉크보다 훨씬 번짐도 적고, 필기감도 좋다. 약간 더 비싸지만 어쩔 수 없다. 손에 힘을 더 빼야한다. 데스크탑 피씨 리눅스 설치 HDD 데이터 디스크로 쓰던거 용량 큰쪽에 그냥 백업하고 날린 다음에 리눅스를 통으로 설치.\nSteam 게임이나 가끔하느라 윈도 host에 리눅스 guest으로 VM 설정해서 주로 써왔는데, 그냥 리눅스를 host으로 쓰기로 결정.\nFlatpak으로 나와서 배포판이나 데스크탑 환경에 상관없이 설치가 가능해져서 그냥 설치하고 써보기로 했다.\n스팀플레이 사용하며 감상은 나중에 계속 적어볼게.\n그리고 무엇보다 리눅스 데스크탑 완전 편하다. 좋아!\nCD ripping하기 준비 음악CD 갖고 있는것들 FLAC으로 ripping해서 HiFiBerry DAC 만든걸로 듣기 위해,\n전원이 공급되는 USB허브 USB으로 접속 가능한 ODD 드라이브 음악파일을 별도 전원 없이 Raspberry Pi에 접근 가능하도록 USB 메모리스틱 ..을 질렀다. 스크립팅하고 자동으로 걸어놓으면 rip하도록 해봐야겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/rpi3-hifiberry-dacplus-config/","title": "⚫ HiFiBerry DAC+ + Raspberry Pi 3 설정",
     
     "tags": ["raspberrypi", "hifiberry", "linux", "audio"],
     
 "description": "",
 "contents": "https://www.hifiberry.com/ 요거 Raspberry Pi 3에 세팅한 모험에 대한 이야기.\nWIFI잡기 # /etc/wpa_supplicant/wpa_supplicant.conf ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev #update_config=1 country=GB network={ ssid=\u0026#34;iptime\u0026#34; psk=\u0026#34;xxxxxxxxxx\u0026#34; key_mgmt=WPA-PSK } wpa_passphrase 안쓰고 그냥 plaintext으로 써도 동작. 내 공유기랑은 country=GB 이 아니라, KR, US 등으로 되어 있으면 안되어서 해멤. 그리고 ip link set wlan0 {up|down} 정도로 wlan0 인터페이스를 up/down하면됨. 사운드 드라이버 설정 내장 사운드카드 드라이버는 modprobe blacklist에 추가해서 끄자. /boot/config.txt에 HiFiBerry DAC+ 드라이버 오버레이를 지정해야함. 내장 사운드 드라이버 끄기 다음처럼 modprobe blacklist에 추가해서 로딩 못하게 막음.\n$ cat /etc/modprobe.d/snd.conf blacklist snd_bcm2835 HiFiBerry+ DAC 드라이버 오버레이 /boot/config.txt 파일에 다음과 같이 끝 부분에 추가:\ndtparam=i2s=on dtoverlay=hifiberry-dacplus 조금 헤맸던 부분은 hifiberry-dacplus을 그냥 hifiberry 으로 지정해서 다른 모델을 위한 오버레이를 로딩해서 동작을 안했었음. 드라이버가 정상적으로 로딩되면, 부팅할때나 사운드 출력시 DAC 보드에 LED이 들어오니까 참고. ALSA 설정 /etc/asound.conf:\npcm.hifiberry { type softvol slave.pcm \u0026#34;plughw:0\u0026#34; control.name \u0026#34;Master\u0026#34; control.card 0 } pcm.!default { type plug slave.pcm \u0026#34;hifiberry\u0026#34; } 위와 같이 대충 세팅해줘야 사운드 볼륨 믹서를 사용가능.\n팁: 중요한 명령들 aplay -l : 현재 설정된 사운드카드 목록을 확인할 수 있음. amixer cset numid=3 2 : 이거 내장 사운드카드의 출력을 HDMI이 아니라, Builtin Headphone Jack으로 출력하도록.1 후기 사운드도 마음에 들고, 나는 그냥 SSH 터미널용 음악재상 애플리케이션들만으로 좋은데2, RuneAudio 같은걸로 세팅해도 좋았을거 같다. 처음에 Raspbian 이미지에서 시작하지않고, 아예 RuneAudio 이미지로 다시 OS부터 설치해야해서 이건 생략. HiFiBerry DAC 설정하면 안써도되는듯.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMplayer, Cmus, Midnight Commander\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-10oct/03wed-ping/","title": "💣 Ping 03/10/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "HiFiBerry + Raspberry Pi 3 tweet 1047432827866767360\n요것임.\nhttps://www.hifiberry.com/products/dacplus/ http://eleparts.co.kr/goods/view?no=3700883 정말 예전, 한 3년전쯤에 사서 한국집에 묵혀두고, 그때는 세팅에 실패해서 안되는건가\u0026hellip; 이러고 포기하고 있다가 다시 시도해봤다.\n조금 삽질을 몇번하다가, 그리고 정 안되면 똑같은 부품 다시 주문해서라도 어쩐지 만들어보고 싶다는 알수 없는 의지가 발동해서 세팅에 성공. 1\n어쨌든 FreeBSD을 설치해서 써볼까하다가 드라이버 지원이 필요한게 안되서 포기.2\n결론은,\n라디오, MP3 걸어놓고 듣기에 좋다. 음질은 확실히 이어폰으로 들어보면 같은곡에 대해서 훨씬 깨끗하고 노이즈 없이 재생하는거 같다 RuneAudio, Mopidy 같은걸로 Web UI 세팅해서 쓸수도 있는거 같은데, 그냥 난 SSH으로만 들어가서 쓰기에 나쁘지 않아서 거기까니 삽질은 포기. 마음먹고 PulseAudio 서버로 써서 윈도, 리눅스에서 사운드 출력을 이걸로 할수있게도 가능한데 일단은 여기까진 안가기로.3 4 GnuPG 재밌게 쓰기 딱히 쓸얘기는 없는데, 그냥 GnuPG을 더 많이 쓰게 된거 같아.\n그냥 안전하게 호스트간에 예민할 수 있는 데이터 전달하는데, 또 전달하는 방법에서 혹시나 문제가 없도록 하는데도 좋아서 그런거 같아.\n넷플릭스 미드 다시 보기: 모던패밀리, 브루클린99 요즘에 계속 피곤하고 시간도 마땅치않아서 넷플릭스 못봤었는데 짬짬이 다시 보기 재밌는거 같아.\n그냥 골치가 아프거나 더 심란해지지 않아도 되서 현실 감각을 꺼놓아도 되고 그래서.\n날씨, 가을, 사람들 날씨도 좋고 가장 행복한 계절인거 같아. 왠일인지 베를린에 있을때 친구도 이메일 연락이 오랬만에 오고, 또 아르바이트로 한국어 번역을 한 앱개발하는 친구도 연락이 와서 새로운 번역을 몇몇 제공했다.5\n반대로는 쿨한척이나 하면서 사실은 그냥 쿨하지도 않고 정말 찌질한것들에 비하면.\n정말 좋은 사람들, 아무런 이유 없이 선하게 행동하고 남을 지지해주는 사람들, 그리고 사람살이를 자기가 적극적으로 더 엿같게 만들면서 자기가 그렇게 된건 남탓만 열심히하는 사람들.\n요건 별도 포스팅에서 정리.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://wiki.freebsd.org/FreeBSD/arm/Raspberry%20Pi WIFI이 필요한데, 그냥 내 방에서 무선으로 실행하고, 무선브릿지해줄 장치나 공유기 붙이고 싶지 않아서. 그래서 그냥 무난하게 리눅스로. 거기에 HiFI DAC용 드라이버 지원은 더 불확실해서.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://wiki.archlinux.org/index.php/PulseAudio/Examples#PulseAudio_over_network 이런것도 가능해서.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://shishworks.blogspot.com/2010/02/your-windows-sound-remoliveincode.html 요렇게 윈도에서 사운드를 캡처해서 HiFiBerry 쪽으로 넘길수있음.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\u0026ldquo;atWork 시간 추적\u0026rdquo; https://itunes.apple.com/kr/app/atwork-%EC%8B%9C%EA%B0%84-%EC%B6%94%EC%A0%81/id857189697?mt=8\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/cquery-vs-cmake-ide/","title": "⏺️ CQuery + LSP vs CMake-IDE + RTags",
     
     "tags": ["programming", "c++", "lsp", "emacs", "cmake"],
     
 "description": "",
 "contents": "LSP + CQuery을 써보려고 했는데, 결국 CMake-IDE + RTags 조합으로 원래대로 쓰게될거 같아. :\n_build/ 와 같이 CMake, Ninja, Makefile등의 파일들을 별도의 디렉토리로 만들어서 필드하고 싶은데, 제대로 지원을 못한다. 1. 그냥 프로젝트 소스코드랑 같이 generate하고 gcc등의 중간 파일이 모두 같이 남아서 지저분해져서 싫어함. 아직은 별로 내 마음에 꼭 들게 만들기는 어려울거 같아서. 그래도 인상적이었던 부분들:\nflycheck에 전용으로 연동되어 있는 점. company-lsp이 생각보다 훨씬 부드럽고 자동완성 잘되는거. 미래에는 그냥 LSP기반만 남을거 같아서, 이것도 \u0026ldquo;helm-rg의 모험\u0026quot;처럼 아직은 완전히 전환은 못할거 같긴하다.\nhelm-xref 같은거 잘되는건 부러웠음\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/23sun-todos/","title": "🏫 해보기 23/09/2018",
     
     "tags": ["todos"],
     
 "description": "",
 "contents": "LSP 갖고놀기 Language Server Protocol : https://langserver.org/1\nES6: https://github.com/sourcegraph/javascript-typescript-langserver 다른건 FlyCheck + Eslint으로 만족스러운데, 코드네비게이션만 좀. C/C++: https://github.com/cquery-project/cquery https://github.com/MaskRay/ccls ES6 기능들 다시 한번 주욱 읽어보기 http://es6-features.org/\n딱히 뭣도 몰라서 한번 주욱 읽어보려고. 더 알고 싶지는 않다만\u0026hellip;\ntweet 1039770698187563009\n\u0026hellip;이런 언어지만.\n대안으로서 ReasonML? https://reasonml.github.io/ https://github.com/ocaml/merlin ..예전에 좋아하던 OCaml 다시 실용적으로 써도 재밌을거 같기도하고.\nhttps://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99 이거아님.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/23sun-ping/","title": "🥟 Ping 23/09/2018",
     
     "tags": ["ping", "kino", "film", "movie"],
     
 "description": "",
 "contents": "영화: \u0026lt;멀홀랜드 드라이브\u0026gt; 씁쓸. 그리고 영화 다보고 해석들 읽고 다시 생각하고 장면들에서 느끼던 이상함점들이 왜 그랬었구나 맞춰보니 더 씁쓸. 1\n그리고 살면서 사랑이나 그런 환상을 갖는것들처럼 그런 완전한 꿈을 생각하듯이 달콤한 전반부의 내용들이 이해됨.\n추석 연휴에 서울에 있기 어차피 고향도, 친척들도 거의 다 서울에 살아서 평생 명절마다 서울에서 보내는게 너무 익숙하다. 그리고 이맘때가 나는 서울에서 좋은거 같아.\n그냥 적당히 조용하고 차소음도 사라지고 (심지어 우리집은 큰길에서 한참 멀리있음에도) 공기도 훨씬 좋아진다. 밤거리도 한적해지고. 이런 분위기를 좋아해서.\n영화든 책이든 조금 딴짓 많이하기 코딩이나 프로그래밍 딱히 잘하는것도 아닌데 매번 그것만 바라보고 살면서 놓치는게 많은거 같아. 연휴에는 책이랑 영화 보고 싶던것들이나 열심히 하면서 보내고 싶다. 더 잉여력을 충전해야겠다.\nEmacs VSCode, Vim 같은게 좋아보이기는 하는데 역시 이맥스가 가장 편안한거 같아. 설정이나 그런게 제대로 내게 맞춰져 있지 않으면 별로 쓸만하지 않은데, 그 설정을 바꾸는게 EmacsLisp을 조금만 익히면 설정을 고치고 재밌게 쓰기 가장 좋은 편집기인거 같아서.\n이외에도 이맥스를 굳이 계속 쓰려는 이유는:\n현재 키맵, 상태, 사용 가능한 방법들을 평가하면서 찾기 좋다. C-h k, C-h b, C-h f 등등 현재 변수나 키바인딩 등을 확인하기 너무 좋게 되어있다. Info 페이지나 공식 이맥스, Elisp 매뉴얼만으로 너무 익히고 레퍼런스로 쓰기도 좋다. 그리고 C-h f (describe-function)이나 C-h v 같은 것들으로 확인도 하고. 그렇지만 역시 복잡하게 만드는건, \u0026lt;이상한 용어들\u0026gt;인거 같아. 예를 들어, electric-indent-mode 이 대체 뭘하는건지, transient-mode 등은 또 뭔지 익숙해지고 알아가면서 내게 편안하게 설정하지 않으면 뭔가 뒷통수를 제대로 맞게 되는거 같아.\nES6, Golang, LSP 일으로는 ES6을 쓰면서 뭔가 재미있다. 그리고 요즘의 오픈소스, 다이나믹 언어들의 편집, linting방식 자체가 정말 만족스럽기도 하다.2\n그런데 역시 이런 flycheck, eslint등등 언어별로 짝을 맞춰주기 어렵고 복잡하고, 한계도 있다.\n그리고 더 나아가서 어떤 언어들은 정말 컴파일을 하거나 거의 컴파일에 가까운 방식으로 소스 트리와 관련된 헤더 파일 경로, 라이브러리 설정 등을 모두 보고서야 결정할수있는 구조도 있어서 더 골치 아파진다.3\nhttps://langserver.org/\nGolang도 LSP방식을 공식으로 지원하려고 하는거 같고[^2], C++, Python, ES6 등도 이렇게 정리할 수 있으면 좋을거 같긴하다. 물론 어디까지나 너무 괴상하지 않을 정도로만.4\n예를 들면, \u0026ldquo;베티\u0026rdquo; 이 심각할 정도로 밝고, 좋은 사람인걸로 나오고, 뭔가 행동들 자체가 인공적이라는 느낌이 들었었다. 그리고 매순간 그렇기도 했지만 나중에 오디션에서 사람들이 너무 강조하며 좋은 연기라고 말해줄때, 정말이라고 강조할때, 그게 더 이상했었다. 그런데 전반부의 의미를 생각하면 너무 당연하다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlycheck이나 ALE을 이용해서 편집하는 동안 자동으로 linting이랑 문법체크를 eslint이나 각각의 언어에 따라서 적절한 체커를 호출해서 보여주는데, 이것만으로 꽤 쓸만하다. 실제로 컴파일이나 실행을 다 하기 이전에 꽤 괜찮다. 가벼운 편집 플로우를 그대로 유지할수있게 해주고.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCMake-IDE, rdm, irony-mode등등 약간씩 차이가 있는, 거의 비슷한 방식의 접근이 있는데, LSP방식으로 조금 정리하는 CQuery을 설정해 사용해보려고함.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n솔직히 Python, ES6은 현재 Flycheck등의 연동만으로 나는 적당히 만족스럽다. 어차피 다른 formatter이나 그런 연동을 나는 적당히 해놓은 사용하니 편안해서. 다만 Navigation같은게 안되기는 하지만.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/22sat-ping/","title": "😆 Ping 22/09/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "새 만년필 : Pilot Kaküno! tweet 1043371766318424064\n필기감은 같은 모델, 각 제품별로 조금씩 다른듯. 가격이 저렴해서 만년필 취미를 권하고 싶은 3개를 사서 회사 다른팀이나 같은 연구소 사람들에게 선물했다.\n게임 : 둠2016, 쉐도우 오브 더 툼레이더 가끔 시간이 날때, 예전에는 길을 못찾아서 많이 진행을 못했었던, 둠 2016 을 다시 하고 있다. 지금은 꽤 많이 진행해서 \u0026ldquo;내가 바로 둠가이다. 10점 만점에 12점인 사나이!\u0026rdquo; 모드로 플레이 할수있게 됐다.\n둠 이터널 나오면 바로 지르게 될거 같아.\n또, 라라쨔응의 모험을 함께하며 기다리던 신작이 나와서 한국어판을 질렀다. 배송이 왔는데 언제 플스에 넣고 플레이하게될지 잘 모르겠다.\n이맥스, Evil의 귀환 이맥스에서 종종 많은걸 반복적으로 편집하거나 할때 \u0026ldquo;이맥스 키보드 매크로\u0026quot;를 써도 되지만, 역시 내 손에는 Vim방식의 키보드 매크로가 손에 편해서 그렇게 되는거 같고, 단순 반복적인 편집질일때도 Vi키가 필요해서 부활시켰다.\n자잘하게 js2-mode 일때 electric-indent-mode 을 꺼버려서 인덴트가 깨지게 만드는 이맥스의 트롤짓을 고쳐놓았다.\nhttps://github.com/ageldama/configs/commit/5383cc9ad2ff19cbea71dde0b933a846fb0cca63#diff-b3c8ee08f838413b684f0fd746ecbdd5R5\nRipgrep 대신 다시 The Silver Searcher으로, Helm-Rg실망 원래 grep 대신에 써오던 The Silver Searcher 보다, Ripgrep 이 빨라서 helm-rg을 즐겨썼었는데,\n\u0026ldquo;helm검색 버퍼를 별도의 버퍼로 저장하고 편집하기\u0026rdquo; 를 원하는데 \u0026hellip; 이게 완전 좋은 이유는:\nhelm-ag , helm-do-grep이 지원하는 helm 세션에서 C-x C-s 누르면, 별도의 정적 버퍼로 열리고, 거기에서 다른 helm처럼 선택해서 이동하면 helm창처럼 사라지지않고, 바로 편집도 가능하고 (C-c C-c 등의 이맥스의 일반적인 방식처럼) g 누르면 편집되서 빠진것들 refresh 가능해지고 하는 그래서 그냥 조금 느려도 helm-ag 으로 다시 바꿈.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/lamy2000-monami-ink/","title": "👩‍👩‍👧‍👧 Lamy 2000 + 모나미 병잉크",
     
     "tags": ["fountainpen", "ink"],
     
 "description": "",
 "contents": "라미2000 사고, 모나미 병잉크 처음으로 사서 충전을 겨우했다. 카트리지방식만 계속 써오다가 처음에는 엄청 어떻게 피스톤 방식으로 충전하나 설명서를 봐도 잘 모르겠고, 언제나처럼 좋아하는 물건을 샀을때 처음의 느낌 그대로 내가 잘못해서 망가뜨리지는 않을까 걱정하며 손을 떨며 충전을 했다.\ntweet 1040804232339742720\n일단 필기감은 기존에 써오던 사파리, Lx이랑 너무 달랐다. 둘 다 이제는 내손에 맞춰서 닙이 부드러워진것도 같아서 정말 부드럽고 날카롭게 글을 쓰다가 닙을 종이에서 뗄때 짝 달라붙어있다가 떨어지는 쫀득한 느낌이 있다면, 2000은 그냥 주욱 주욱 글이 써져서 좋았다.\n다음에 보듯이 몰스킨 노트의 종이에서 엄청 번지고 그런건 잉크탓을 하고 싶다.\ntweet 1040886255075057665\n아직은 종종 라미2000의 필기감이 이상하게 느껴질때가 있는데, 그래도 계속 쓰다보면 더 나아질거 같아. 닙도 내게 길들여지고 하다보면.\n모나미 병잉크는 너무 한번에 많이 산거 아닌가 싶기도 하고.\n만년필 덕질을 하면서 글쓰기의 재미가 다시 살아나는거 같아서 재밌긴해.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/2018-09sep15sat-my-choices-linux/","title": "🥃 어째서 아치리눅스를 쓰며 데스크탑환경을 안쓰는지",
     
     "tags": ["linux", "IT꼰대", "i3wm", "archlinux"],
     
 "description": "",
 "contents": "나는 데스크탑 환경을 사용 안한지 꽤 오래된것 같아.\n예전엔 이런식이었던거 같아:\n왠만하면, 그냥 세팅하는데 시간낭비하지말고 그냥 제공되는 Gnome, KDE 같이 예쁜거 쓰자.\n\u0026hellip;였었는데, 어느날 ASUS 넷북에 낮은 CPU파워으로 리눅스를 설정하고, 이런 \u0026ldquo;가벼운 데스크탑 환경\u0026quot;을 직접 꾸며서 사용하면서, 오히려 맥북보다 더 편하고 계속 쓰고 싶게 만들고, 내가 더 빠져서 사랑하며 사용하는걸 본 이후로 집과 직장의 데스크탑도 모두 바꾸게됐다.\n그리고 가장 마우스 사용으로부터 오는 잡다한 스트레스나 그런것들도 없고 가장 내게 익숙하고 편안한 환경을 만들어서 행복하게 쓸수있는거 같아.\n정말 \u0026ldquo;우분투\u0026quot;에 만족스러운가? 매번 새로운 패키지를 설치하기 위해서 PPA을 기다리고, 그나마도 버젼이 한참 내가 필요한 버젼의 패키지와 다르거나, 아니면 내가 사용하는지도 알수없는 패키지들이 엄청나게 메모리를 소모하고, 심지어 내 마음에 들거나, 편안하지도 않은 데스크탑환경 정말 우분투가 내게 가장 User friendly 한 환경인걸까? ..내 생각엔 이 질문은 사용자층에 따라서 답이 다르고, 달라야한다. 분명히 우분투나 페도라 같은 \u0026ldquo;사용자편의성\u0026quot;에 집중한 배포판들은 가치가 있다. 그리고 리눅스 데스크탑의 저변을 넓히고 진지하게 폭넓은 사람들이 사용할 환경으로 만들어가는 노력들이 위대하다고 생각한다.\n하지만, 리눅스나 유닉스 시스템을 도구에서 해방되어 더 자유롭게 쓰고 싶거나 깊이 사용해야만하는 사용자라면, 특히나 소프트웨어 엔지니어라면, 진지하게 한번 고민해보기를 권한다.\n그렇다면 어떤 대안들이 가능한가 도구를 배워야한다는게 어쨌든 bottom line이라는걸 인식하기. 거짓말을 안하려면, 사실 GUI환경이나 도구들은 그런 익히는 단계가 상대적으로 매우 단순하고 쉽다. 하지만, 그럼에도 계속해서 배울것도, 어떤 \u0026ldquo;이건 정말 이렇게만 해야하나\u0026rdquo; 하는 의문이 들때 답해주기 어렵다. GUI에서 Automation, Scripting이 가능한 환경들도 있지만, 아무리 그래도 그냥 쉘을 통해 자동화하거나 하는것보다 쉽거나 확실하지도 않다. Desktop environment, Code editor, Shell, Linux distro\u0026hellip; 이런 취향의 선택은 충분히 많이 가능한거 같다. Desktop evironment Gnome, KDE 등등의 데스크탑 환경을 안쓰거나 직접 구성해 내게 적합한 Window manager와 다른 작은 도구들을 조합해 만들수있다.\nWindow manager은 Tiling window manager이나 윈도우 레이아웃을 자동적으로 내 필요에 맞춰서 배열해주거나, 재배열해주는것들을 취향에 맞춰서 선택해 사용하기를 권한다. 마우스로 창을 옮기거나 재배치하거나 하는것들이 귀찮고 지겹다면 매우 추천한다.\n처음에 키보드 숏컷을 잘 익히고, 원하는 키들을 배치하면서 내게 맞는 환경을 만들어가야한다.\n생각해보면, lightdm이니 gdm이니 로그인 한번할때 그냥 조금 그래픽스러운 화면에서 패스워드 좀 입력해보자고 메모리를 로그인해있는 내내 얼마나 낭비하는지 생각해봤는지?\n\u0026ldquo;내 xinitrc을 봐줘\u0026rdquo; 그냥 내 xinitrc와 i3wm 설정을 공유하며 내가 어떻게 사용하는지 이야기 하는게 가장 빠를거 같아.\n데스크탑환경은 쓰지않고, 그냥 X윈도를 기본으로 사용함. 거기에 \u0026ldquo;display manager\u0026quot;이라는 부팅한 다음 로그인 프롬프트를 보여주는 lightdm, gdm같은걸 사용하지 않는다. 그냥 systemd에 의해서 리눅스 텍스트 콘솔에서 로그인한다. 로그인하면, X윈도가 떠있지 않으면 띄우겠냐고 5초간 기둘리고 띄우는 시작 스크립트를 만들어 사용한다. (zsh용) https://github.com/ageldama/configs/blob/master/i3wm/zlogin xinitrc에는 맨 마지막에 exec i3wm으로 윈도 매니저를 시작하기전에 필요한 X윈도 설정, 시작할 프로그램들을 실행. ibus을 이용해 한국어 IME 시작 fcitx, nabi등등 다른 한국어 입력기가 취향이라면 바꿀수도. gnome-keyring을 이용해 ssh keyring관리 매번 ssh passphrase 입력 안하고 gnome-keyring이 기억줌. 처음 ssh passphrase 입력할때 팝업 떠서 입력하면 됨. xmodmap: CapsLock -\u0026gt; Control으로 키바꾸기 compton: display compositing manager Eye candy! https://wiki.archlinux.org/index.php/compton 3D 가속이 가능할때, 조금 화면전환 등등에 그럴싸하게 예쁘게 보이고, Chrome등 웹브라우져에서 화면 가속이됨. redshift: blue light filter 경위도 설정에 따라서 해지는 시각에 화면의 파란색을 적절하게 조정해준다. 이후에 이야기할 systemd --user 서비스로 등록해서 대체 가능. dunst: notification daemon 흔히 말하는 Toast 형식으로, 리눅스 데스크탑 환경의 표준 데스크탑 노티를 표시해준다. 참고: https://wiki.archlinux.org/index.php/Desktop_notifications systemd --user 서비스로 대체 가능. pulseaudio: audio daemon PulseAudio 방식으로 오디오 입출력을 가능하도록 데몬 시작. systemd --user 서비스로 대체 가능. ..조금 _많아보인다_만 막상 짜보면 별로 많은것도 아님. (정말)\n이미 꽤 현대적인 데스크탑 환경의 기능들이 다 구현이 되어있고, 거기에 그런것들이 리눅스/유닉스 환경에서는 굳이 엄청나게 무거운 방식으로만 구현되는게 아니라 작고 가볍게 구현된것들을 조합해 내게 맞도록 가볍고도 깔끔하고, 가장 강력하게 사용할수있어서 나는 이 방식을 선호한다.\nFile manager 파일매니저에서 하는 일들 어차피 midnight commander 같은걸로 충분히 편안한거 같다.\n그리고 이런 가볍고 안정적이고 목적에 부합하는 파일관리자는 리눅스에 충분히 많은거 같고, 또 가장 안정적이고 확실한 쉘에서 처리하는것도 방법인거 같다.\n파일 관리를 위해 다른 가벼운 데스크탑 GUI환경이 필요한 경우는 별로 없지 않나.\n취향에 따라서 파일관리자를 선택하는것도 좋은거 같아: https://wiki.archlinux.org/index.php/Category:File_managers\n\u0026ldquo;매일매일 기다려\u0026rdquo; 매일매일 하는 일상적인 작업들이나 필요한것들에 대해서 몇개씩 정리해보자.\n모니터를 여러개 연결하기 다른 예쁜 \u0026ldquo;디스플레이서 설정\u0026rdquo; 애플리케이션을 써도 좋지만, 나는 xrandr 커맨드 사용법을 익히기를 권장한다.\n내가 원하는 레이아웃, 위치에 지정이 가능해지고, 특별히 복잡하지도 않아서 처음 모니터 연결했을때 해메일 필요가 줄어든다.\nhttps://github.com/ageldama/configs/blob/bc1d7c0482a3eac517eabfced2d1e01ea00014eb/xrandr/on-vga-0-xrandr.sh\n무선랜, 네트웍 연결 이건 취향에 따라 다른데, 여러가지 대안이 가능한거 같다.\nNetwork Manager 사실 CLI툴이나 Standalone GUI 도구 등도 많고, 가장 무선랜 설정하기 편리해서 나는 이걸 사용. 대부분의 DE들이 이걸 기본으로 사용함. https://wiki.archlinux.org/index.php/NetworkManager#Front-ends Netctl 아치리눅스 기본인데, 설정도 조금 거시기하고, WIFI 전환도 조금 마음에 안들게 동작함. Wicd 무선랜만 지원하는거 같음. 별로 내 취향은 아니고 경량으로 구현한점은 마음에 듦. 키보드 배열 다른말이 별로 필요없을거 같다.\n원하는 키 이벤트를 xev등으로 찾아내고. xmodmap으로 적절히 키맵을 수정하고, 이걸 ~/.xinitrc에 등록해서 설정하도록 하면됨. 예: https://wiki.archlinux.org/index.php/xmodmap \u0026ldquo;상태표시줄\u0026rdquo; / \u0026ldquo;시스템트레이\u0026rdquo; 이건 나는 i3blocks 사용함. 취향에 따라, 기본적인 i3status이나 기타 등등 정말 많은 이런 프로젝트들이 있으니 적당히 선택해 쓰면됨.\nibus 한국어 IME이나 DropBox 같은 애플리케이션들은 \u0026ldquo;시스템트레이\u0026quot;에 아이콘을 등록하는데, 보통 이런 i3blocks 같은것들의 기본설정은 오른쪽 끝에 이런 아이콘들을 등록해줌.\n시계부터 네트웍 상태, 볼륨, 디스크, 메모리, CPU 사용량 등 커스터마이징해서 필요한 정보들을 표시할 수 있음.\n\u0026ldquo;시작 메뉴\u0026rdquo; 나는 i3wm을 통해 Super+D 키를 rofi에 바인딩해놓고 사용한다.\nhttps://github.com/ageldama/configs/blob/master/i3wm/macbook-air-2012mid/i3-config#L39\n적당히 원하는 커맨드를 찾아서 실행도 fuzzy matching으로 해줘서 편리하다.\n뭐 어차피 i3wm에선 Super+Return 눌러서 터미널 열고 뭔가 거기서 다하게되지만.\n화면보호기 i3lock, xscreensaver을 추천한다.\ni3lock은 정말 fork버젼에 따라 다르고, 직접 xautolock등이랑 연계해서 타임아웃이 있을때 화면보호기가 켜지도록 해야한다.\nxscreensaver은 설정도 가능하고, 다양한 스크린세이버를 구현해놓았다. 그냥 systemd --user으로 등록해서 자동적으로 실행되도록 하거나, 특정한 키에 xscreensaver-command -lock 커맨드로 즉시 화면을 잠글수있습니다.\n오디오 볼륨 조절 pavucontrol이나 그런 믹서 조절이 가능한 GUI 애플리케이션이나 스크립팅 가능한 pamixer등을 설치해 쓰기를 권한다.\n또 필요에 따라서 i3wm등에 단축키를 등록해서 볼륨 조절도 가능하니, 참고.\nhttps://github.com/ageldama/configs/blob/master/i3wm/macbook-air-2012mid/i3-config#L154\n블루투스 이건 조금 내 취향이 제일 이상한거 같은데, 나는 bluez을 설치하고, 블루투스 데몬을 systemd으로 띄워놓고, 그 다음에 bluetoothctl 을 이용해서 CLI에서 스크립팅하거나해서 연결한다.\n그런데 다른 GUI툴들이 standalone으로 DE이랑 관계없이 나와있으니 선택해 설치해 쓰기를 바란다.\n프린터 난 그냥 CUPS을 설치하고 네트웍 프린터로 잡거나 하는게 전부인거 같아.\nCUPS 설치한 다음에 보통 http://localhost:631 으로 웹브라우져로 접근하면 바로 프린터 찾고 설정이 가능해서 딱히 불편한게 없음.\n기타 애플리케이션 mplayer, vlc 으로 동영상을 보기 편안한거 같다. 다른 소프트웨어들만큼 친절하고, 추가적인 자막용 문자셋, 폰트 설정을 해야하지만 그래도 가장 확실하고 편안하게 동영상을 보는 방법인거 같다.\n이밖에 이미지뷰어나 evince PDF 뷰어, Calibre 같은 전자책 처리 소프트웨어 같은것들도 내겐 모두 리눅스에서 사용하는게 가장 편안하고 가장 강력하고 제한도 없는거 같아서 선호한다.\n외부 저장매체, 안드로이드 등등 autofs 같은걸 사용해서 자동화해도 좋은거 같아.\n대부분의 데스크탑환경들이 그런 방식으로 자동화를 하니까. 그리고 MTP장치(안드로이드 등)도 mtpfs, simple-mtp 같은 애플리케이션들이 fuse을 통해서 마운팅 가능하도록 해주니까 참고해서 활용해도 좋은거 같다.\nSuspend, Hibernate 랩탑에 적용하려면, suspend, hibernate이 있을때 특정한 이벤트를 hook해서 스크린세이버를 켜거나 하면 될거 같다.\nsystemd을 사용한다면, 이런 hook을 이용해서 스크린세이버를 시작하거나 해서 화면을 잠그는게 가능하다. (다시 lid을 열었을때 화면이 잠겨있지않다면, 랩탑을 잃어버리거나 뺏겼을때 난감할테니까.)\nhttps://github.com/ageldama/configs/blob/master/i3wm/i3lock%40.service\ni3lock을 사용하는 예이지만, xscreensaver-command -lock 등의 커맨드로 바꿔서 다른 스크린세이버로 바꾸기도 좋고, 아래에 주석으로 어떻게 설치하고 적용하는지도 잘 설명되어있다.\nTIP: 내 눈에 더 좋도록 폰트 추가하기, 바꾸기 https://github.com/ProgrammingFonts/ProgrammingFonts\n코딩할때 폰트나 기타 한국어를 위한 보기 편하고 예쁜 폰트들이 오픈소스로 많이 공개되어있다.\n이런것들 PPA으로 공개되기만 기다리지말고,\n~/.local/share/fonts 디렉토리로 복사 fc-cache 실행 이렇게하면 대부분의 애플리케이션에서 바로 적용 가능해지거나, 애플리케이션을 재시작하면 적용할수있으니까 가능한한 내 취향의 폰트를 자유롭게쓰자.\nLinux distro ArchLinux, Gentoo 같은 내게 모든 제어권을 주면서 너무 극단적이지 않은 실용적인 배포판을 사용하면 좋은거 같다.\nUbuntu, Debian, Fedora, CentOS 같은 배포판들 모두 각각의 특징이 있고 좋아하지만, 특히 아치리눅스를 권하는 이유는 다음과 같다.\n적당히 편리한 Prebuilt binary을 설치하기 좋은 Pacman 패키지 매니져. 딱히 특별히 dpkg + APT, 혹은 RPM + Yum 조합보다 불편한적 없음. 오히려 어떤 파일이 어떤 패키지에 속하나 등등 dpkg으로 순식간에 복잡해지는것들이 잘 정리되어있어서 편하다. 대부분은 패키지의 최신버젼이 준비되는대로 올라오고, Debian, Ubuntu처럼 2년 정도 기다리거나 PPA을 찾아헤메이지 않아도 된다. Gentoo처럼 모든걸 EBUILD으로 설치할 필요 없이, 대부분은 Pacman으로 바이너리 패키지로 설치하고, 정말 소스코드로 최신으로 설치하거나, 컴파일 옵션을 지정하고 싶은건, AUR 에서 찾아서 설치가 가능하고, AUR 찾아서 설치하는것도 Yaourt, Packer 같은 툴들을 이용해서 그냥 Pacman 설치하듯이 하면 된다. 자기 자신에게 물어보자, 자신이 작성한 소프트웨어의 가장 괜찮고, 가장 안정적인 버젼은 무엇인가?\n대부분은 가장 마지막 버젼 일거다.\n그런데 어째서 오픈소스 소프트웨어 패키징은 1~2년간 복잡한 검증 과정을 거친 다음에야 겨우 기능적으로나 보안상 안전해지기를 기대하는게 이상하지않나? 아치리눅스나 젠투의 패키지 철학은 그냥 최신을 설치해준다. 그리고 가끔 깨지기도 하지만, 대부분은 가장 확실하고 잘 동작하는 소프트웨어를 설치해준다.\n커뮤니티, 계속해서 \u0026ldquo;내 스타일으로\u0026rdquo; 살아가기 r/unixporn 에 가서 다른 이상한 사람들은 어떻게 자기 환경을 꾸미고 설정해 사용하는지, 그 사람들의 스크린샷과 코멘트, 그리고 무엇보다 설정 파일을 찾아 읽고 자기 환경에 적용해보자.\n정리하며 오늘도 좋은 꼰대질이었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-09sep/2018-09sep15sat-ping/","title": "🍐 Ping 15/09/2018",
     
     "tags": ["ping"],
     
 "description": "",
 "contents": "새 만년필 : LAMY 2000, 해피해킹, 기계식 키보드 새 만년필을 샀는데, 조금 저렴한 폴리카보네이트 버젼의 LAMY 2000을 샀다. 기존에 LAMY Lx, 사파리는 행복하게 써왔었는데, 카트리지를 사용해 충전하는 방식이 아니고 또 가격대도 조금은 높은 만년필을 질렀다.\n아직 병잉크는 받지 못해서 충전해서 사용은 못해봤다. 기대된다.\n처음 만년필질을 시작할때는,\n뭐 그냥 저렴한 저가형 브랜드 실용적인 목적으로만 사서 써야지, 그러니 사파리랑 Lx정도까진 뭐\u0026hellip;\n..이런 마인드였었다가 점점 만년필 자체로 글을 쓰는 감각에 중독되는거 같아. 기계식키보드도 그런거 같고.\n글을 쓰는 행위의 목적을 위해서 사용한다고 생각하지만, 반대로 사실은 그 행위 자체가 즐겁고 편안해져서, 그 감각을 즐기며 글을 쓰고 있거나, 계속해서 키보드를 타이핑하는 행위에 빠져들며 계속 생산적인 활동을 하려고 나를 등떠미는게 너무 솔직하게 강하게 느껴진다. 그리고 편안하고 좋다.\n정말 싫어하는 뭣같은 견해도 아닌 견해들 혐오하는 견해와 사람들은, 정말 제대로 뭐하나라도 깊이 경험하거나 한것도 아니고, 아니면 아예 경험이 없으면서, 마치 그것에 대해서 다 안다는듯이 말하는 꼰대와 영꼰대들의 견해를 들을때 정말 대꾸해주기도 짜증난다.\n정말 아무런 생각이나 그런거 없이 너무 얕게 자신의 별볼일 없음을 어떻게든 감추려고, 그리고 그런 감추려드는 허접한 말과 행동들이 다 너무 훤히 드러나보이며 같잖아 보인다는 생각을 하지도 못하는거 같은 유치한 사람들을 볼때 싫다.\n좋아하는 스피커 오랬만에 좋아하는 스피커로 혼자 편안하게 노래 틀어놓고 들으면서 감성질하는듯. 일주일간 체력, 시간 모두 방전되서 그냥 집에와 쓰러져 잠을 보충하기에 바쁘다가 이렇게 글을 쓰고 밀린 일기도 쓰면서 생각해오던것들, 갖고 있는 생각들 정리해 내리는게 정말 좋다.\n날씨, 잠 날씨가 선선해지고 내가 좋아하는 멋진 하늘들이 계속된 며칠이었었다. 밤에 잘때도 잠도 잘오고. 그리고 무엇보다 너무 피로하고 잠을 허기를 채우듯이 자야했어서 더 잠이 달콤했다.\n그리고 이렇게 잠을 조금이라도 더 자면서 어릴때, 아마 그때는 몸이 성장하니 잠이 더 필요했었겠지, 정말 쓰러져 몇시간이라도 자던 때가 떠올랐다. 그땐 평생 이렇게 잠을 많이자면서 이렇게 졸림과 싸워야할까 생각했었는데, 오히려 잠이 오지 않아서 괴로운 때보다는 행복한 고민이었었구나 생각했다.\n어쨌든 휴식을 조금이라도 더 취하고 잠을 자니 토요일이 되니 머리가 그나마 조금이라도 더 움직이는거 같아. 일주일 동안 멍하고 뭔가 아무런 생각이나 사고가 정상적이지 않았던거 같았었는데.\n어떤 도구를 잘 사용하는 방법들에 대한 생각 자신이 무슨 행위를 하건 그게 얼마나 많은 방어벽으로서, 어려운지, 얼마나 인간만의 위대한 행위인지를 주장하며 방어할 필요도 없는거 같다.\n많은 사람들이 도구를 경시하려고 하지만, 내 생각엔 전혀 반대로 도구에 우리 자신이 길들여지는것만이 도구에서 가장 자유로운 형태가 아닐까 생각한다.\n어차피 어떤 도구를 쓰건, 목적을 완수하고 싶어서 사용하는데, 도구를 경시하고 그 도구를 익히는것은 마치 별로 중요한일이 아니고 시간낭비일뿐이라고 말해서는 안되는거 같다. 차라리 도구를 잘 익히고 그 도구를 능숙하고 최대한 활용해서 가장 잘 빠르게 일을 완수하는게 가장 도구를 활용 잘하고 도구를 이용하며 자유로워지는것 아닐까.\n그 도구가 만년필, 건강한 몸과 충분한 휴식으로 잘 돌아가는 머리, 해피해킹이나 기계식 키보드, 스피커, 프로그래밍언어, 코드 편집기, 버젼관리 소프트웨어, 운영체제, 쉘 등등 수많은것들이 있고, 또 그런것들을 알아가는 단순하고 멍청해보이기까지한 노력들이 일견 그 도구에 집착하는것 같아보이지만, 가장 그 도구에서 자유로운것이리라 생각했다.\n프로그래밍언어 프로그래밍언어에 대한 생각은 더 편협해진거 같기도하다. 그냥 매일 손에 잡는 도구들 이외엔 더 잡기 싫어질때가 많다. 예를 들면, 파이썬, 펄5, 쉘, C++정도가 그나마 현실에서 내가 계속해서 쓸만한거 같은 언어들인거 같다.\n자바스크립트, 특히 Node.js은 좋은점은 이정도로 만들려면 나름 빠른 I/O 성능면이나 컴팩트한 점 같은걸 얻으려면 C++이나 했어야 했을것들을 쉽게 만들수있는점은 정말 좋은거 같지만. 그리고 정말 많은 모듈들이 이제는 많아서 쓰기 좋다만, 여전히 멀티코어 활용하기 복잡해지는 문제나 끔찍한 프레임웍이나 라이브러리 파편화 문제 같은거, 메모리 제한 같은걸보면 딱히 계속 써야할까 생각이 많이든다.\n여튼 최근에 관심을 많이 갖는 좋아진 라이브러리를 보면서, 결국엔 프로토타이핑, 테스팅도 그 라이브러리의 다른 언어로 바인딩을 써서 더 복잡해지지않고, 그냥 그 라이브러리의 특성을 정확하게 보려면 그냥 C++을 써야하니, 또 그리고 다른 가비지컬렉터나 그런것들이 끼어들면서 생기는것들을 무시하고 싶으니 C++을 쓰게되고, 그렇게 나쁜거 같지도 않다는 생각이든다.\n다른 언어를 사용했었더라면, 예를 들어 커먼리습이나 파이썬이라도, 그 언어에 속한 바인딩을 고르고 그 또 다른 특성을 이해하고 확실히하기 위한 시간을 낭비했으리라 생각한다.\n그리고 나날이 새로운 언어들을 접하고 사용하면서 느끼는건, 그냥 C/C++에서 사용하던 gdb같은 디버거로 뜯어보거나 memory leak detector, strace등등의 수많은 도구들이 이미 너무 다른 언어들의 생태계랑 비교도 안되게 다 구비되어있는거 같아서, 오히려 다른 언어들은 C/C++이 복잡하다고 선전하지만, 가장 tooling이 잘되어있고, 역설적으로 가장 그 semantic을 기계가 잘 이해하도록 IDE등이랑 연동하기 잘되어있는게 C/C++이 아닌가 생각한다.\n그게 아니라 반댓쪽 극단으로 그냥 편집기에서 편집기능만 쓰고 주욱 필요한 스크립트를 작성하기에는 파이썬이나 펄, 자바스크립트 정도 이외에는 딱히 쓰고 싶지도 않은거 같아.\n인프라 클라우드서비스 다른 IDE이나 언어들을 마케팅하는 용어들은 마치 더이상 소프트웨어 엔지니어 없이도 애플리케이션을 만들수있을것처럼 광고하지만 그렇지 못하듯이, 인프라스트럭쳐를 위한 클라우드서비스들도 비슷한거 같아.\n마치 DevOps작업이나 시스템엔지니어로서의 업무가 완전히 사라질거 같지만 그렇지않은거같아.\n물론 Infrastructure as code 같은건 확실히 가능해지고 시간을 다른데 사용하는건 정말 멋진거 같아. 하지만 그렇다고 완전히 이런 고민들을 다 떠넘기려하거나, 모든걸 그 서비스에서 제공하는데에만 의존하려고하고, 그냥 완벽한 silver bullet 으로 무의식중에 생각하게되고 그런 관성은 위험한거 같아.\n아직은 모든 필요한 인프라가 구현되어 서비스되는것도 아니고 오히려 그 클라우드서비스에서 제공하는것들만으로 아키텍처나 디자인패턴을 우겨맞추려다보면 또 새로운 형태의 abomination이 탄생하는거 같은거 같아서 경계해야겠다 생각했다.\n서울생활 조금은 혼돈으로 지저분하고 관리도 안되고 그저 어떤 미덕은 보이지않고 그저 돈에 대한 욕심으로 말도 안되는 금액에 말도 안되게 더럽고 낡은, 재건축으로 값이 오르기를 기대하며 그런걸 강요하는, 돈에 환장한 도시.\n지금와서 다시 겪어보니 정말 밥맛 떨어지게 돈독이 오른 얼굴의 도시라는 생각도든다.\n조금이라도 지금 계절에 해가 나른하게 지려고 할때 한강병을 달릴때는 강철색으로 어두운 강물에 비추는 빛들을 보며, 그 우울하고 없는 사람에게 더러운 기분밖엔 주지않는 그 모습을 보면서, 아주 어릴적 한강 옆에 살던 그때, 막연히 먹먹하던 마음 같은 기분이었었다.\n그냥 나는 이곳에 만족한다고 생각하다가도, 문득 일산이나 고양시에 주말에 좋은 햇살인날에 나가서 석양을 맞다보면 긴장과 스트레스가 풀리며 기분이 좋아지는걸보면 나도 모르게 질려가고 있는걸지도 모르겠다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-07jul/2018-07jul-nvim-evil-and-emacs/","title": "👇 NeoVim, Evil-mode and Emacs의 모험",
     
     "tags": ["neovim", "vim", "nvim", "evil-mode", "emacs"],
     
 "description": "",
 "contents": "\u0026ldquo;내적모순\u0026rdquo; 이맥스에서 Evil을 쓰면서 몇가지 짜증나는게 있어왔다.\nEvil 자체의 문서화가 조금 거시기하다. 거기에 Which-Key같은 키바인딩을 실시간으로 확인할 수 있는 방법도 제대로 안먹히게 된거라, 이맥스에서 쩔어주는 기능인 자기 자신을 확인하며 단축키 안외우기 같은게 다 무의미해짐. 공식 사이트 들어가도 문서는 없다. 그냥 Vim 온라인 help을 보거나 하라는 친절인거 같다. Magit, Edb, 등등 대부분의 이맥스의 다른 Major mode들이랑은 정말 충돌하는 경우가 너무 많음. https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018#L421 위의 링크만 봐도, 내가 얼마나 충돌이 나는 모드들을 경험했는지 알수있다. 그럼에도 포기할수없는 나의 영도자 좋은점, 그래도 고집을 갖고 계속 써야겠다고 생각하던 부분은:\nLeader key 을 활용한 키바인딩이 편리하다. General 같은걸 써서, SPC a 같은 키를 Spacemacs처럼 바인딩해서 편리한 나를 위한 환경을 세팅하기 좋다. 이런 Leader키는 Vim의 NORMAL모드에서 동작하도록 만들기 편리하다. \u0026ndash; 어차피 INSERT모드가 아니니까, Space키와 같이 원하는 키를 그렇게 사용하기 유리하지. \u0026hellip;그러다가 어정쩡한 상태가 계속됐었던거 같다.\n결국 이런 내적모순을 견디지 못하고, 그리고 매일 급할때마다 이맥스와 Vim키바인딩간에 꼬이는 손가락이 미웠다. 그래서 그냥 어차피 Vim 키바인딩 쓸거면 Vim을 쓰면 되지않나 싶어서, 설정 파일을 조금 고치고, NeoVim에 도전해보기로 했다.\nNeoVim은 그냥 Vim보다 조금 더 가볍고 만족스러웠다. 자잘한 버그도 보이지 않았고 그냥 계속해서 쓸만하다. 어차피 이맥스를 써도 나는 이맥스와 Vim 둘 다 설치해놓고 상황에 따라서 터미널에서 바로 편집할만한건 Vim을 켜서 진행하는데, alias vim=nvim이 되버렸다. 내가 만든 설정 https://github.com/ageldama/configs/blob/master/nvim/init.vim 이맥스처럼 Vim도 조금 더 끈덕지게 책도 읽고, 공식 문서도 읽으면서 더 공부할까 생각이들었다.\n그리고 다시 돌아온 탕아 그런데, 역시 결론은 다음과 같다.\nVim은 빠르고 가볍게 세팅하고, 텍스트 편집을 빨리할만한 정도로 좋은거 같아. NVim 세팅하고 갖고 놀면서, 나름 이맥스에서 내가 좋아하고 필요한 패키지들을 설치하고, 비슷하게 만들고 더 나은것도 있었지만. Fzf을 통해서 Ag등의 연동이 이맥스만큼 깔끔하지는 않고, helm-swoop 이 너무 그리웠다. 무엇보다도, 어차피 다 고쳐서 세팅할수있겠지만, 이맥스만큼 Elisp만큼 속시원하게 내가 원하는 방향으로 세팅할수는 없었다. VimScript이나 그런게 너무 괴로웠다. 이맥스도 그런식으로 설정하지만, Evil을 기본으로 설정할 필요는 없고, 필요에 의해서만 켜고 편집 모드에서만 쓸수있게 만들자. https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018#L88 그리고 Leader키 같은거 대신에 good-ole-emacs-key-chord을 이용하자. 어차피 세팅은 거지같아도 동작하는건 비슷하니까. https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018#L320 이맥스 키바인딩으로 돌아와서 그냥 글을 쓰기도 괜춘해진거 같아.\n그리고 Elisp에 대해서 아직도 이상한 부분은 많지만, 그래도 Elisp을 이용해서 끄적거리고 원하는 기능을 만들어나가기 좋은게 이맥스를 계속해서 좋아하게 만드는 이유인거 같다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2018-05may/2018-05may-emacs-cmake-ide-screencast/","title": "🫰 Emacs + CMake-IDE Screencast",
     
     "tags": ["workflow", "editor", "emacs", "cmake", "cmake-ide", "ide", "ninja", "rtags", "rdm", "screencast", "gdb", "reversing", "disassembly", "disassemble"],
     
 "description": "",
 "contents": " 이건 무엇인가 Emacs Configurations: https://github.com/ageldama/configs/tree/master/emacs/cmake-ide\n이맥스에서 C++ 개발 편하게 하려고 이것저것 알아보다가 결국엔 CMake-IDE + RTags 조합이 제일 괜찮다는 결론에 도달해서 만들어본 설정이다.\n원래 사용하는 환경이 Evil은 아니었는데, Spacemacs 을 조금 쓰다가 편한거 같아서 Evil으로 옮겨탔다.\n지금은 그냥 Spacemacs은 다운도 잘되고 너무 무겁고 설정을 레이어 방식 으로 할게 아니면 짜증나게 하는 부분도 많고, 그렇다고 레이어가 완전히 내가 그냥 커스텀으로 만들어서 바로바로 머지하는 구조도 아니고 중앙에서 관리하는 방식으로만 되는거 같아서, 옆으로 치우고, 바닐라 이맥스에 Spacemacs스럽게 직접 설정해서 가볍게 사용하고 있다. :-)\n참고로 내가 사용하는 CMake-IDE 제외한 기본 이맥스 설정은 https://github.com/ageldama/configs/blob/master/emacs/dot-emacs-2018\n이맥스 기본 설정에 대한 이야기는 다른 포스트에서 하는게 더 나을거 같다.\nC++ 환경을 만들기 위한 여정 우선, C++ 자체 소스코드 파일을 파싱하고 하는 방식으로는 여러가지 이유로 자동완성이나 코드 네비게이션이 잘 동작하기 어렵다. 이 접근방식은 기존 ctags 등과 같은 소스코드를 정적으로 읽어서 파싱하고, 그에 맞는 태그 들을 나열해서 찾아가는건데, 소스코드를 읽어나가는데는 어느정도 도움은 되도, 실제로 그게 정확하게 어디에서 참조하는지, 어떤 인자 타입들을 갖는지 등등 진짜 IDE의 기능들을 구현하기는 어렵다.\n또, 이맥스의 경우 CEDET, Semantic, EDE 등등 오래된 다양한 접근방법들이 있었지만, 현대 C++을 잘 지원하는거 같지도 않고, 현대의 이맥스 생태계의 Company, Flycheck등등등이랑 친하게 잘 지낼거 같지도 않고, 설정도 오히려 더 끔찍스러워서 생략.\n일단 내가 필요한(하다고 생각하는) IDE 기능들 자동완성 : C++은 타입이 있으니, 모든 변수에 대해서, 심지어 auto으로 선언한 변수에 대해서도 type infer해서 자동완성을 제공해줄수있음. 타입 정보 : Eldoc 써서 현재 커서의 타입 정보나 파라미터 정보 같은거 깨알같이 알려주면 너무 좋을거 같다. 체크, linting : 코드 작성하면서, 실제 컴파일 에러나 linter을 이용해서 찾아낼수있는 수준의 에러를 찾아주면 좋겠다. 자동 소스코드 포매팅 : 코드는 대충 안예쁘게 작성해도 나중에 저장할때나 내가 원할때 지정한 가이드라인에 따라서 자동으로 포매팅해주면 좋겠다. 네비게이션 : 이것도 당연히 가능. 선언이랑 구현 사이를 오가는 나는 전선위의. 프로젝트 파일간 전환 : 이건 딱히 설정 안해도 이미 Projectile만으로 충분한거 같다. 디버깅 : 이것도 사실 실행파일 고르는것만 자동으로 해주면 이맥스 내장 GUD 정도 쓰면 충분히 좋다. 디스어셈블리 : 요건 가끔 컴파일러가 생성해준 코드가 어떤지 궁금할때만 보는데, 그래도 붙여보면 재밌을거 같아서. LLVM, Clang, RTags, compile_commands.json \u0026hellip;그런 문제들로, 아예 C++ 소스코드를 정말 컴파일러가 분석하듯이 읽어서 IDE 기능들을 제공해준다. (좀 더 솔직하게 말하면, 언제나 오픈소스가 그렇듯, 그렇게 IDE을 구현할 수 있는 기반되는 기능들을 구현해놓았다.)\n우선, LLVM 기반으로 Clang-Tools에서 쓸만한 외부 도구들은 Clang-Tidy, Clang-Format이 있는데, 각각 소스코드 정적분석해서 linting해주고, 소스코드를 자동으로 포매팅해주는 도구인데, 이걸로는 자동완성이나 그런 기능들을 기대할수는 없음.\n그래서 LLVM/Clang을 이용해서 RTags이란게 있음. 소스코드 파싱, 분석 등등 다 LLVM/Clang이 잘해주고(완전한 컴파일러니까 ㅋㅋ), 그걸 갖고서 자동완성, 네비게이션을 위한 데이터베이스를 자체적으로 만들어서 소켓을 통해 제공하는 서버(rdm)와 이걸 이용하는 커맨드라인 클라이언트(rc)으로 크게 구성되어있음.\n이런 유사한 접근 방식으로, Clang을 이용한, Irony-mode이 있는데, 조금 자동완성도 그때그때 가끔 잘안되고, 어차피 Irony에서 제공하는 기능들은 RTags이랑 다른 이맥스 패키지들을 통해서 다 구현이 가능해서, 나는 RTags만 쓰고있다.\n여튼 신비롭게 알아서 기반되는 데이터를 다 모아주는건 좋은데, RTags 이게 제대로 동작하려면, compile_commands.json 이란 파일이 필요해지는데,\nCFLAGS, LIBS, LDFLAGS 등등 흔히 C/C++ 컴파일러에 우리가 전달하는 인자들을 알아야, 실제로 컴파일러가 소스코드를 분석하듯이 할수있다. cpp C Preprocessor에 대해서도 그렇고, libc++, STL 같은 기본적인 라이브러리는 물론, 외부 의존성 라이브러리의 헤더 파일을 찾아야 타입 등을 알수있으니까. compile_commands.json 파일은 다른 configure, automake 등등에서 복잡한거 다 제하고, 최종적으로 C/C++ 컴파일러에 전달할 인자들만 정리해놓은 파일이다. 이걸 갖고 주어진 소스코드를 LLVM/Clang을 거쳐서 소스코드 분석이 가능해진다. 대충 요런 형식이다: https://clang.llvm.org/docs/JSONCompilationDatabase.html 그런데, Autoconf, CMake등을 거치면 이미 이런걸 매번 내손으로 적어주기도 힘들고, 빌드하는 환경에 따라서 그때그때 다르다. 쨔잔! https://cmake.org/cmake/help/v3.5/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html CMake은 자동으로 지원해준다. 1. 가끔 이걸 gcc/g++등의 커맨드를 가로채는 proxy 스크립트를 작성해서, 이게 실행될때마다 기록해서 생성하는 경우도 있는데, 이건 너무 슬프니 그러지않기로하자\u0026hellip; 결론은, RTags을 쓰려면, compile_commands.json을 생성해줘야함. 그런데 CMake을 빌드 생성기로 쓰면, 자동으로 생성해준다. 뱀!🐍 CMake-IDE, RTags https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L57\n57라인의 use-package 하나랑 시스템에 RTags만 설치되어 있다면, 바로 이맥스에서 C++ 자동완성, 네비게이션을 위한 환경설정이 끝난다. (사실 CMake-IDE이 해주는건 compile_commands.json을 찾아서 rdm에 전달해 실행하거나 등등의 잡다한 일들이 있는데, 이걸 자동으로 해준다.)\nRTags은 ArchLinux/Homebrew 등에서는 아예 패키징되어있으니 그걸 사용해도 편하다.\nhttps://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L123\nRTags을 설정했고, CMake-IDE만 설정하면 끝. 이제 정말로 CMakeLists.txt 파일이 있는 프로젝트 디렉토리에 속한 소스코드 파일을 열고, M-x rtags-... 등의 명령을 통해서 바로 rtags의 강렼한 기능을 맛볼수있다. (아직 자동완성 프론트엔드는 설정 안됐으니 잘안될지도)\n여튼 https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L273 여기에 나오는 cmake-ide-... 이나 rtags-... 같은 커맨드들은 이제 대부분 바로 실행이 가능해졌다. (나머지는 취향에 맞게 키바인딩을 만들거나, 조금 더 내 워크플로우에 맞춰 elisp을 작성해주거나 정도.)\n조금 더 Clang-Tidy, Clang-Format 위의 원하는 기능들 에서 소스코드 자동 포매팅이나 체크가 가능한데, 나는 clang-tidy 연동은 그냥 이맥스랑 하지 않았다. 원하는 경우엔 Flycheck + Clang-Tidy을 통해서 구현이 가능하다만, 그냥 Clang 기본 Flycheck Checker만 사용하고, 필요하면 쉘스크립트 작성해 쓰는게 더 나은거 같다. (반응속도나 너무 많은 결과 등등)\nProjectile 설명생략. 자동으로 잘 굴러감. https://github.com/bbatsov/projectile\n자동완성, 타입정보 툴팁, 실시간 코드체크 내 취향에 따라, 자동완성은 Company, 타입정보 툴팁은 Eldoc, 실시간 체크는 Flycheck을 사용했다. (세가지 모두 이맥스에서는 다른 대안들이 있고, 대부분 RTags이랑 연동이 가능하다.)\n자동완성 Company 일단 Company 로딩 https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L34 그리고 C-c \\으로 자동완성 팝업 강제로 부르는걸 추가했다. 쩜 찍었을때만이 아니라 필요할때 바로 띄울수있도록. c++-mode-hook등에 당연히 자동완성 되도록 add-hook해주고. rtags 로딩할때도, company이랑 연동되도록 company-backends에 연결해주고, rtags-completions-enabled 켜서 자동완성 기능을 위한 데이터베이스 만들고, add-hook해서 rtags이랑 연동되도록. 타입정보 툴팁 Eldoc https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L76 뭔가 좀 코드 많긴한데, 결론적으로는, 현재 커서의 심볼에 대해서rtags-get-summary-text 한 결과를 알록달록 예쁘게 칠해주고(rtags-eldoc-function, fontify-string) 그걸 eldoc이랑 연결해주었다. https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L108 실시간 코드체크 Flycheck https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L15 CMake-IDE이 아마도 Flycheck 내장인 c/c++-clang checker이 제대로 동작하도록 해주는거 같다. : http://www.flycheck.org/en/latest/languages.html#c-c 프로그램 실행, 디버깅 그 다음에 조금 귀차니즘 해결을 위해 다음과 같이 Helm을 이용해봤다.\n문제 이맥스에서 내가 빌드한 실행파일을 실행하거나 gdb으로 디버깅하는건 이미 제공됨. M-x gdb M-x shell-command ..등등등 그런데, 그 빌드한 실행파일의 경로를 쳐주기 너무 괴롭다. 또, CMake을 이용해서 빌드했기 때문에 make install/ninja install 하기 이전엔 빌드 디렉토리 어딘가에 있을건데\u0026hellip; 방안 우선, CMake-IDE은 빌드 디렉토리가 어디인지 알고있다 그 빌드 디렉토리에서 실행파일을 검색해보면 실행파일 목록 찾을수있다. 그렇게 찾은 실행화일들의 목록에서 현재 내가 열어놓은 소스코드 파일의 이름과 가장 유사한 실행파일 이름을 가장 우선순위가 높은 후보로 올려줘서, Helm을 통해 고르면 됨. https://en.wikipedia.org/wiki/Levenshtein_distance https://www.emacswiki.org/emacs/LevenshteinDistance 끝: https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L143 조금 뭔가 엄청 많이 작성해놓기는 했는데, 위의 내용들을 구현해서, 그냥 실행하길 원하는 파일이름이랑 가장 가까운 소스코드 파일 열어놓고 , d이나 , x 누르면 알아서 파일 찾아서 골라줌. 그게 마음에 안들면 파일을 다른걸로 고를수도 있고, (소스코드랑 실행화일 이름이랑 아예 다를수도 있으니) 실행 인자를 내손으로 직접 줄수도있고. 키바인딩 원래는 Spacemacs 환경에서 이 C++환경을 만들다가, 나중에 General.el이라는 Spacemacs처럼 Evil모드에서 Leader/Prefix-key을 이용한 키바인딩을 설정하기 좋은 프레임웍으로 갈아탔다. 지금은 완전히 바닐라 이맥스에 설정해서 가볍게 쓴다.\nSpacemacs용 설정: https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L266 General.e용 설정: https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L303 디스어셈블리 사실 이거 안만들어도 그냥 gdb에서 disassemble이 더 나은거 같다. (소스코드랑 연계를 잘 보여주고, 디스어셈블리 안에서 원하는 심볼따라 찾아가기도 좋게 정리해줘서\u0026hellip;)\n그래도 이미 objdump을 이용한 disaster.el이 있고, 적당히 예쁘게 색깔 칠해줘서 보기 멋져보여서 작성해봤다.\n이것도 위의 실행파일 찾아내기 와 같이 object file을 현재 소스코드의 이름을 기반으로, 빌드 디렉토리에서 찾아주고, 그걸 디스어셈블하는 방식으로 구현했다.\n관련 elisp 및 설정 https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/cmake-ide.el#L228 disaster.el의 관련 이슈: https://github.com/jart/disaster/issues/19 프로젝트별 설정 파일이 필요하다 https://github.com/ageldama/configs/blob/master/emacs/cmake-ide/dot-dir-locals.el\n위 파일을 그냥 복사해서, C++ 프로젝트 최상위 디렉토리에 .dir-locals.el 파일으로 놓아줘야함.\nCMake-IDE이 cmake을 실행할때, 디버그 모드로 설정하도록, https://cmake.org/cmake/help/v3.0/variable/CMAKE_BUILD_TYPE.html (이건 취향) cmake이 Ninja을 위한 빌드파일을 생성하도록 -GNinja 다른 빌드시스템을 써야한다면 참고: https://cmake.org/cmake/help/v3.0/manual/cmake-generators.7.html 그리고 cmake-ide-build-dir 설정이랑 flycheck-clang-tidy-build-path을 모두 동일한 빌드 디렉토리로 설정. 사실 flycheck-clang-tidy-build-path은 flycheck에서 clang-tidy backend을 안쓴다면 생략가능. 하지만, cmake-ide-build-dir은 어쨌든 지정해주는게 잘돌아감. _build말고 아마 다른걸로 바꿔도 잘돌아갈거임. (예: build) Tip: 처음 C++ 프로젝트 열었을때? 위의 .dir-locals.el 파일을 프로젝트 최상위 디렉토리로 복사. 기존 CMake build 디렉토리가 있다면 제거. 아무 C++ 소스파일이나 우선 이맥스에서 열고, 빌드 파일 생성: M-x cmake-ide-run-cmake 빌드: M-x cmake-ide-compile 이제 RTags등 잘 동작해야함. 잘안되면, C++ 소스파일 닫았다가 다시 열어보면 잘됨. 마무리 어째서 남들이 신기하고 신나는 신바람 이맥스로 IDE만들기! 같은 포스팅 쓰면 길어지는지 이제야 알겠다. 나는 이미 이맥스랑 이맥스 생태계에 친하니까 당연한거지만\u0026hellip; 다른 C++ 개발환경들에서 내가 싫어하는점들은 없고, 그냥 빠르게 코딩, 빌드하고 해나갈 내게 맞는 환경을 만들기 위해서 고민하고 만들었었는데, 매우 만족스럽다. 싫었던점: 너무 무거운 GUI, 마우스로 뭔가 움직여줘야함, 너무 못생긴 GUI, 상용, 그나마 기능들도 거지같거나 아예 C++ 자동완성부터가 거지같음 등등 C++ 언어만 놓고 생각해보면, 파싱하고 의미 이해하고 등등 이상해서 그렇지, 타입시스템이나 역사만 놓고보면 툴링이 이상하지도 않고, 자동완성이나 분석 등이 당연히 잘되어있어야 하는거 같은데, 현대적인 그런 IDE을 만들기 위한 툴링은 RTags을 제외하고 너무 적지 않았었나 싶어서 신기할 지경이었었다. 이렇게 조립해놓고 보니까 완전 튼튼하고 기능도 좋아서 신바람. "},
 {
     "permalink": "https://ageldama.github.io/posts/2018-04apr/2018-04apr-golang-windows-vscode/","title": "🥂 Golang Windows에서 Vscode이랑 행복하게 쓰기",
     
     "tags": ["golang", "windows", "vscode", "mingw"],
     
 "description": "",
 "contents": "Golang 윈도 데탑에서 그냥 끄적거리기 괜찮은거 같아. 그냥 편집기도 윈도에선 이맥스나 Vim 다 골치아파서 VsCode 쓰니까 설정도 따로 없고. (물론 리눅스에선 이맥스 그냥 쓰지만\u0026hellip;)\n여튼 그런데 윈도에서 기본적으로 C컴파일러 설치되어 있어야 제대로 굴러가서, Mingw64 설치하고, $MINGW64/bin 디렉토리 $PATH에 걸어주니 잘됨.\nVsCode에서 디버거도 잘 붙고 만족스럽다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-10-22-blogging/","title": "🐸 2017년 10월 22일, 블로깅 귀찮아",
     
     "tags": ["rants", "blogging"],
     
 "description": "",
 "contents": "과연 블로깅이 이렇게나 힘들어야 하는 일인가 생각해봄.\n요즘엔 정말 각자의 개소리를 쉽게 올리는 트위터나 페북 같은게 혁명적이라는 생각이 든다. 특히 예전에 각종 웹애플리케이션으로 쓰레기 같은 위지윅 에디터 같은거니 지원하고 막상 어떤 글을 하나 올리기 진짜 끔찍한 경험을 주던것들을 돌이켜보면 더욱 더.\n어차피 사람들은 그런거 아무리 쥐어줘봤자 귀찮을뿐이고 한번 쳐다도 안보고 각자 자기 하고 싶은 거지 같은 방법을 찾아내어 잘도 이상한 글들 생산해내는걸 더 좋아한다.\n그리고 그런면에서 그냥 이미지, 동영상, 링크, 남에 글 인용 정도나 되는 트위터 같은거야말로 배설하기 진짜 좋은 도구이지 않은가 싶었다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-07-11-private-docker-registry-howto/","title": "🚨 HOWTO: Private Docker Registry?",
     
     "tags": ["docker", "registry"],
     
 "description": "",
 "contents": "말보다 예제 깃헙 Project \u0026ndash; https://github.com/ageldama/private-docker-registry-howto\n내 피씨에서 작업하던거 서버에 바로 올려보고 싶은데, 회사에 레지스트리가 없을때, 혹은 레지스트리를 개발서버에 올리지도 못하고 어쨌든 개발서버에 도커 이미지 옮기고 싶을때 ..이런 이상한 상황에서도 쓸만하도록 고민해봄. "},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-07-11-myself/","title": "👨‍👧 2017년 7월 11일, 요즘 나는",
     
     "tags": ["myself", "2017"],
     
 "description": "",
 "contents": "한국에 와서 다시 일을 다니고 있음. 백엔드 소프트웨어 엔지니어로 과거에 이미 다른 사람들이 만들어놓은걸 마음에 들지 않는 모양을 조금씩 고쳐가고 그럭저럭 출퇴근.\n장마도 오고 엄청나게 덥다. 묘하게 독일에서 똑같은 8시간 근무인데 한국에서는 출퇴근이 엄청나게 힘들다는 생각이 들었다. 그리고 실제로 집밖에서 생활하는 시간을 생각하면 하루 8시간 수면을 하기도 빠듯해서 정말 이상하구나 생각이든다. 거기에 독일에서 생활할때는 나혼자 생활해서 밥이며 청소 같은것들도 내가 혼자해야 했었던걸 생각해도 이상할 정도로 한국에서의 생활은 시간이 쪼들린다.\n여하튼 재미있는건 요즘엔 Python, Flask, SQLAlchemy으로 나름대로 재미있게 작업하고 나름대로 능률적으로 작업을 하고 TDD 잘 적용해서 문제 없게 편안하게 작업하는 방법들을 익힌거 같다.\n그리고 이전 Zalando SE에서도 많이 써왔던 Vagrant, Docker등을 그냥 혼자서라도 개발환경에서 사용하고 편안하다.\n파이썬으로 웹개발, 백엔드 개발이나 그런 워크플로우나 프레임웍을 이용해 프로젝트 구조를 잡는거나, Pytest이용해서 TDD하고 하는것들, 이맥스에서 더 재미있게 작업하는 요즘이나 Virtualenv등이랑 더 친하게 지내는 방법 같은것들부터 docker, vagrant, oh-my-zsh 편하게 쓰는 팁들 조금씩 정리하면서 블로깅을 해나가야겠다.\n..그리고 오늘은 정말 덥다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-02-26-aync-rxjava-and-monad/","title": "#️⃣ 예전 모나드를 이용한 비동기코드의 정리에 대한 아이디어를 다시 생각해보기",
     
     "tags": ["async", "monad", "haskell", "io", "asyncio", "await", "async", "nodejs", "es6", "rxjava", "python", "programming"],
     
 "description": "",
 "contents": "예전 내가 썼던 블로그가 갑자기 떠올랐다. http://ageldama.blogspot.de/2012/03/nodejs-haskell-io-monad.html\n내용은,\n콜백헬 싫다. 그런데, 하스켈의 IO Monad처럼 imperative code을 작성할 수 있으면, 3. 이것들끼리의 제어권을 주고 받는걸 event loop측에서 제어하면서도, 4. 각각의 statements끼리 그냥 주욱 흐름대로 작성한것과 다르지 않게 짜기 쉽다. 굳이 이 얘기 왜 하냐하면, 사실 요즘에 RxJava2 보고, Python3에서 asyncio 같은거 보면서 이런거, 그러니까 결국엔 모나드스러운 체이닝을 구현하고, 그걸로 콜백들을 풀어서 잘 해결하고 있는거 같은 인상이 들어서.\n결론? 내 아이디어 부심. 그리고 조금 더 잘 생각하고 실제로 어떻게 구현할지 고민해봤다면 좋았을거라는, 나 자신의 능력 한탄하기.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-02-25-sbcl-osx-multithread/","title": "👐 SBCL을 OSX에서 실행할때 멀티쓰레딩 켜기.",
     
     "tags": ["lisp", "commonlisp", "sbcl", "threading", "common-lisp", "programming"],
     
 "description": "",
 "contents": "SBCL은 멀티쓰레딩을 잘 지원하는 커먼리습 컴파일러이지만, 공식사이트에서 제공하는 리눅스 바이너리가 아니라 OSX 바이너리는 멀티쓰레딩이 꺼져서 컴파일되어있다.\nhttp://www.sbcl.org/manual/#Threading\n요건 자기 리습에서 *features* 을 평가해서, 리스트에 :threading, :sb-thread 같은 키워드를 포함하는지 확인해보면 알 수 있다.\n어쨌든 지원하지 않을 경우에, 컴파일을 다시 해야하는데, 우선 준비물은 GNU CLISP 같은 여기저기서 잘굴러가고 적당히 설치해서 부트스크래핑에 이용 가능한 커먼리습 컴파일러를 준비한다.\n다음 포스트를 참고해서 작업해봤다.:\nhttp://haminhvuong-blog.tumblr.com/post/22109095116/compile-sbcl-with-multi-thread-enabled-on-os-x\ncreate customize-target-features.lisp with content\n1 2 3 4 5 6 7 8 (lambda (features) (flet ((enable (x) (pushnew x features)) (disable (x) (setf features (remove x features)))) ;; Threading support, available only on x86/x86-64 Linux, x86Solaris ;; and x86 Mac OS X (experimental). (enable :sb-thread))) 그리고 다음의 커맨드들로 빌드하고 설치 끝.\n1 2 # time sh make.sh --with-sb-thread --prefix=/Users/jhyun/local/sbcl-1.3.14-amd64-osx+thread # sh install.sh SBCL 소스의 INSTALL 파일을 한번 읽어보는것도 좋음.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-29-myself-nowadays/","title": "♏ 2017년 1월, 요즘 나는.",
     
     "tags": ["myself", "2017"],
     
 "description": "",
 "contents": "요즘엔 그냥 독일 생활, 도르트문트에 조금씩 더 적응해서 사는게 편안해졌다.\n식기세척기, 세탁기, 커피머신, 팀사람들, 출퇴근길, 놀러가는 동네, 구경가는 전자제품상가.\n그냥 어느정도 이제는 독일어를 하나도 못하지만, 적어도 팀 사람들과는 정도 붙이고 재밌게 잘지내가고 있는거 같다.\n커피를 캡슐커피 기계가 있어서 적당히 입맛을 붙이고 마셔보고있다. 괜찮다. 토스트랑 꿀이랑 사다가 가볍게 먹고 해결하고 살고있다.\n비자도 4년짜리 블루카드도 됐고, 마음이 편안해졌다.\n책은 열한계단 을 읽고 많은 생각을 해봤다. 체체파리의 비법, 시녀이야기, 그리고 테드 챙의 당신 인생의 이야기 을 읽어볼까 생각하고 있다.\n어차피 킨들에 책들은 많으니까 천천히 한권씩 읽어나가고 있다.\nReal World OCaml 을 잡고 읽고 있다. 2003년 전후로 Ocaml에 관심이 많았었는데, (국내에 nML이란 구현체도 있었었고) 그 이후에 커먼리습에 빠져있다가, 다시 살펴보고, First-class modules 같은거 등등 살펴보는것도 재미있을거 같다는 생각이 들어서다. 그리고 실용적으로도 현재 일터에서 인터프리터, 컴파일러를 설계하고 만드는 일을 하고 있는데, 그때 쓸 가능성으로도 괜찮을거 같다는 생각이 들어서다. 하스켈이나 그런것도 좋기는 하겠지만 취향상 이쪽이 더 나을거 같아서.\n그리고 Erlang and OTP in Action 은 읽다가 OCaml 때문에 잠깐 미뤄두고있다. 개인적인 생각으로는 앞으로 JVM기반들은 여전하겠지만, 그만큼 Go, Rust, 그리고 ErlangVM 기반이 실용적인 영역에서 JVM, Rails, Node.js등을 대체해나갈거 같다는 생각이든다.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-22-aio-rx-and-erlang/","title": "👨‍🦱 Erlang에 더 관심을 기울여야 할 시점인거 같다",
     
     "tags": ["erlang", "jvm", "java", "rxjava", "nodejs", "concurrency", "async", "io", "programming"],
     
 "description": "",
 "contents": "그냥 최근의 자바나 node.js, 특히 자바의 RxJava 같은걸 보다보면, 1 뭔가 언어적으로 지원하지 않는걸 뜯어내서 동작하게 만들고 너무 골치가 아프게 만들어지는건 아닌가 생각도 든다. (사실상 콜백. ㅎㅎ)\n그리고 지금 한창 JDBC이라던지 이런 입출력과 관련된 부분에서 비동기 방식을 지원하려고 많은 변화가 있을만한 시점인거 같다.\n예상은 아마 몇년간은 이런 혼란이 자바쪽에는 계속 있을거 같다는 생각이다. (async/await 같은 키워드가 추가되고 하려면 자바에 몇년이 더 걸릴지는 아무도 모를거 같다. lambda이 추가되는데 얼마나 오래걸렸었는지 추억해보자..)\n그런데, \u0026ldquo;아몰랑 닥치고 얼랭씁십다\u0026rdquo; 이런 얘기를 하고 싶은건 아닌데, 그래도 사실 자바로 이런걸 하고 있다보면, 얼랭에서 이미 잘 해결한 문제를 왜 이렇게 고민하고 있어야하고, 왜 이렇게 저수준의 작업을 매번 프로젝트를 만들때마다 해야할까 싶다.\n이미 erlang-vm이 입출력에 관련된건 비동기로 잘 처리해줌. 거기에 이미 메시지 주고 받고, 다른 프로세스들이랑 별로 어떻게 동기식일지 비동기일지에 따라 완전 달라질것도 적다.. 더욱이 프로세스별로 gc이라서 JVM처럼 가비지컬렉션때마다 stop-the-world도 걱정 적음. 회사에서 자바로 하는 프로젝트들은 이미 많이 쓰고있어서.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-22-java-immutables-classic-problem/","title": "👴 Java Immutables와 친숙한 오래된 문제들",
     
     "tags": ["java", "constructor", "immutables", "setter", "getter", "accessor", "programming"],
     
 "description": "",
 "contents": "https://immutables.github.io/ 요즘 이걸 살짝 봤는데, 재미있었다.\n그런데 일단 깊이보거나 써보기 전에 드는 걱정은,\n이거 기존의 몇몇 프레임웍이나 라이브러리들이랑은 친하게 지내기 어렵지 않을까. 왜냐하면, 대부분의 POJO에 연관된 생성단계에서, default constructor 와 setter-methods을 갖고, 값을 세팅하는 경우가 대부분인데, 예를들면, 대부분의 ORM 프레임웍들이나 POJO으로 JSON등을 Deserialization해서 직접 객체를 생성할 책임을 프레임웍이나 라이브러리가 가져가는 경우에 대부분. \u0026hellip;그러면 결국 말짱황인거 같다.. 아무리 accessor 메서드들 boilerplate으로 생성하는거 막아주는게 좋다고 해도, 솔직히 그냥 한번 IDE에서 생성하고 평범하고 조금 멍청하게 만들어놓고 쓰는게 더 낫겠다는 생각이든다.\n그리고 어차피 그런 \u0026ldquo;POJO스럽게 동작\u0026rdquo; 하는게 더 그런 메서드들 공짜로 얻는거보다는 훨씬 더 이득일거 같다. 어차피 어세서들 조금 보기 거추장스럽고, 만들기도 짜증나도 가끔은 더 멍청한게 속편한게 자바인거 같다. 1\n그렇다고, 뭔가 더 낫게 만들려는 생각이나 노력, 혹은 뭔가 멍청하게 하고 있다는 자각을 포기해야한다는 말로 받아들이면 안됨. 반면에 답답한 방법이지만, 다 고려해봤을때 오히려 더 멍청한 방법이 훨씬 속편한게 자바인거라는게 재밌는거일뿐.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-22-emacs-ace-window/","title": "🚶‍♂️‍➡️ Emacs에서 window 전환을 편하게, ace-window",
     
     "tags": ["emacs", "window", "ace-window"],
     
 "description": "",
 "contents": "이맥스에서 코딩하거나 마크다운이나 Org으로 글을 쓰고 정리하는데, 그간 그냥 그럭저럭 나는 이맥스를 나한테 맞춰서 사용하고 있다고 생각하고 있었던거 같다. 1\n그런데, 항상 뭔가 불편한데, 그냥 바쁘다는 이유로 깊이 생각은 안하고 대충 대충 때우면서 사용해왔었던게 있었다. 바로 window 끼리 전환하는 방법.\nC-x 2 이나 C-x 3으로 창을 분할해놓고 쓰는게 보통인데, 이때 나는 그냥 아무 생각없이 C-x o만을 이용해서 다음 윈도우 으로 이동만해왔었다.\n그런데, 창이 3개 이상이 되고, 현재 창의 다음 창 이 아니라, 이전 창 으로 이동하고 싶으면?\n\u0026hellip;그렇다, 한바퀴 돌때까지 그 키를 계속 눌렀었다;;; 부끄럽지만 그래왔었다.\n그러다가 2을 조금 해보고, ace-window 을 쓰는게 제일 나은거 같았다.\nwindmove이 기본적으로 emacs 내장이고 대부분은 마음에 들지만, Vim의 C-w \u0026lt;방향키\u0026gt; 처럼 동작하니까. 내 최애 mode인 Org에서 ㅈㄴ 짜증나게 충돌남. 적당히 창 분할이나 그런것들에 대해서도 해결이 되고, Icicle 같은거 써서 이걸 해결하는것도 있긴한데, 별로 난\u0026hellip; 다른 방법들도 많지만, 그냥 이게 제일 단순해보였다. 끝. ..이맥스의 세계는 역시 넓고, 선택의 폭은 끝이없다는 생각이 들었다. -,.-\n결과로 내 emacs 환경설정에서 관련 라인\n..markdown-mode에서 또 M-p이 충돌나니까 약간 추가 설정만.\nhttps://github.com/ageldama/configs/blob/master/emacs/init2.el\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://emacs.stackexchange.com/questions/3458/how-to-switch-between-windows-quickly\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-02-source-hilite-testing/","title": "🆗 Jekyll + Rouge 소스코드 하일라이팅 테스트",
     
     "tags": ["jekyll", "rouge", "blog", "blogging"],
     
 "description": "",
 "contents": "Rouge 이거 적용해보기.\nhttps://github.com/ageldama/hello-adder-cl-asdf/blob/master/src/adders.lisp\n;;; Actual Implementations here. (in-package :hello-adder) (defun make-adder (n) (lambda (x) (+ n x))) (defun 1+er () (make-adder 1)) https://github.com/ageldama/ageldama-gh-jekyll/commit/334ead4b31b305b82e85ae2c6a6e0a219ecc9e66 이렇게 작업해봤음.\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-02-travis-ci-jekyll-gh/","title": "🍄‍🟫 Github.io 블로그 TraviCI으로 빌드해서 배포하기",
     
     "tags": ["github", "jekyll", "travis-ci", "blog", "blogging"],
     
 "description": "",
 "contents": ".. 여기 에 불만을 적었듯이, 여러가지로 그냥은 만족하기 어려운 부분이 있었다.\n그런데, Travis-CI을 통해서 빌드해서 배포한다는 분이 계셨다. https://twitter.com/Realignist/status/815554589889994752\n..난 생각 못해본 방법. ㅎㅎ 1\n그래서 도전.\n우선 Jekyll 소스용 저장소로 분리하고, 배포하는 페이지들은 원래의 저장소에 git-push 하도록 했다. https://github.com/felixrieseberg/travis-jekyll-git 여기 참고해서 삽질. 결과물은 https://github.com/ageldama/ageldama-gh-jekyll ..진행하면서 처음에 좀 짜증났던거,\nGemfile 에 설치할 의존성들 지정하고, bundle update. 그리고 그것만으로는 안되고, .travis.yml 파일에 gem설치를 지정해야했다. https://github.com/ageldama/ageldama-gh-jekyll/blob/master/.travis.yml#L5 Travis-CI 작업의 세팅에서 git_target 환경변수에 URL지정할때\u0026hellip; github.com/ageldama/ageldama-gh-jekyll.git 처럼 https:// 스킴 부분 빼고, 또 뒤에 .git 깜빡하면 당연히 git-push 안됨. ㅋ 솔직히 내가 뭘 제대로 하겠습니까.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-01-github-jekyll/","title": "⛽ Github.io의 Jekyll 버젼이랑 차이?",
     
     "tags": ["github", "jekyll", "blog", "blogging"],
     
 "description": "",
 "contents": "다 만족스럽고 좋은데, 로컬에서 Jekyll 실행해서 미리보기한 결과랑 Github에 올려서 렌더링한거랑 마크다운 결과가 조금 달라서 짜증난다.\n아마 마크다운 렌더러 버젼 차이 때문일거 같은데 ㅜ.ㅜ\n% jekyll -v jekyll 3.3.1 "},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-01-getting-started-with-emacs/","title": "🙍‍♂️ Emacs이랑 친해지기",
     
     "tags": ["emacs"],
     
 "description": "",
 "contents": " \u0026ldquo;이맥스를 어떻게 배우면 좋은지 모르겠다. 여러번 도전해봤지만 항상 별로였다.\u0026rdquo;\n..어느날 한 동료가 물어봤다. (그렇다 나는 일터에서도 이맥스를 켜놓고 계속 쓴다.)\n솔직히 기본적으로 매일 Org-mode으로 계획, 일정 등등 정리하고 계속 개인적으로 정리하면서 쓰고, 파이썬, Go, Clojure 같은거 할때도 편집하고 테스트하기도 편하니까 선호하는 편인거 같다. (자바랑 스칼라은 물론 그냥 IntelliJ 쓴다.)\n여튼 그날 간단히 짝프로그래밍하듯이 같이 앉아서 몇가지 이야기를 하고, 내 설정 파일 1 이나 어떻게 접근하는게 좋은지에 대해서 잠깐 이야기를 했었다. 그걸 블로깅으로 써보고 싶다.\n어떤 편집기를 쓰건, 어떤 언어를 쓰건 개인의 자유고 각각의 장단점이 있다고 생각한다. 그리고 Atom, Vim 같은 에디터 모두 확장하며, 충분히 자신의 필요에 알맞게 강력하고 편리하게 쓸 수 있고, 오히려 이맥스보다 어떤 부분들은 더 현대적인 점도 많은거 같다. 2\n![평범한 이맥스 유져]({{ site.url }}/assets/2017-Jan/emacs_user.jpg)\nTOC {:toc} 이맥스가 결국 emacslisp 실행기라는걸 인정하는게 훨씬 낫다. 실망스럽겠지만, 이맥스를 쓰려면, 그냥 리습을 어느 정도 어떤 문법과 semantic으로 동작하고, 그게 어떻게 이맥스를 구성하는지를 이해하고 약간은 사용할줄 알아야한다.\n솔직히 나는 elisp의 많은 동작이나 세세한 몇몇의 차잇점들은 잘 모르겠다. 그런데 딱히 사용하는데 아직까진 큰 지장은 느끼지 못했던거 같다. (내가 직접 이맥스 확장 패키지를 만들거나 하지는 않았으니까.)\n그리고 결국 emacslisp을 어느 정도는 익히는게 도움이 된다. 물론 어느 정도 이맥스에 익숙해진 다음에 공부해볼것을 권한다.\nhttps://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html: 이맥스에 붙여넣어서 한줄씩 따라하면서 실행하면되는 형식이다. https://www.gnu.org/software/emacs/manual/html_node/eintr/: 이맥스리습의 공식 문서인데, 처음의 몇몇 챕터를 대충 읽으면서 리습 언어에 대해 처음이라면 괜찮을수도 있다. 다만, 모든걸 한번에 이해할거라고 생각하진말고, 한번에 이해가 안되더라도 그냥 넘어가고, 나중에 다시 이해가 쌓이고 다시 읽어가면서 이해해도 괜찮다. (..한마디로, 이해하기 개떡 같다고 때려치진말자.) ..어차피 이맥스에서 모든 단축키나 메뉴의 기능들은 대응하는 elisp 함수들일뿐이고, 설정값들은 모두 elisp 변수들이다.\n현재 실행중인 리습시스템 자체가 이맥스 프로세스라고 생각하는게 속편하다. 근데 왜 굳이 이따구로 만들어놓은걸 쓰냐고?\n리습시스템이어서 좋은점: 자기 설명적인 시스템, discoverability. 현재 동작하고 있는 시스템이어서, Smalltalk, Python, 커먼리습, Clojure REPL처럼 이맥스 편집기 자체에 대해서 찾아보고, 어떻게 동작하는지 테스트해보고, 어떤 값을 갖는지 살펴보고 바꾸고 해보기 편하다.\n어떤 마법의 설정값을 지정하고 편집기를 다시 시작하고, 도무지 매뉴얼이나 소스코드를 찾아보지 않는 이상 어떤 설정이나 기능이 있는지 알 수 없는 다른 소프트웨어들과 다르게, 이맥스는 어떤 기능을 갖고 있고, 어떤 기능이 어떤 설명이나 어떤 단축키, 혹은 어떤 설정변수와 연결을 갖는지 바로바로 편집기 안에서 찾아볼 수 있다. 3\n처음부터 단축키는 외우지말자. 처음에 시작할때, 몇가지 정말 중요한 것들, 그러니까 이맥스를 종료하기 이나 파일열기, 저장하기, 혹은 창분할, 다른 분할창으로 포커스 이동 같은 키들은 꼭 익혀두고 시작하는게 속편하다. 그리고 무엇보다, M-x ...\u0026lt;RET\u0026gt; 이 뭔지는 알고 시작해야한다.\n하지만 나머지 다른 키들, 그러니까 Yank, Paste, Kill ring, Macro 같은것들은 처음부터 익히지 않아도 좋은거 같다. 다음의 것들만 조금 익혀놓고, 이맥스를 탐험할 준비가 어느 정도 갖추면 좋겠다. 4\nELPA, 수많은 확장들\u0026hellip; 이맥스에서 릴리즈24부터였었나(불확실;) ELPA이 공식 이맥스에 포함되고, 리눅스 배포판들의 패키징시스템이나 Homebrew처럼 원격 공식저장소 바로 패키지를 선택하고 설치할 수 있는 기능이 생겼다.\nhttps://www.emacswiki.org/emacs/InstallingPackages 여기를 읽어보면 사용법을 알 수 있다.\n그런데 문제는, 너무 많은 패키지가 있어서 뭐부터 설치해야할지 모르겠다는점이다. ㅎㅎ\n솔직히 처음부터 패키지 설치와 설정을 권하고 싶지 않다. 예를 들어 같은 기능을 하는 패키지들이 여러가지 별개의 방식으로 존재하기도 하고, 설정이나 그런것들도 그렇고. 5\n처음에는 그냥 기본적인 편집기로서 설정을 충실하게 해놓고, 그 다음에 자신의 필요에 따라서 패키지를 골라보기를 권한다.\n그리고 구글에서 \u0026ldquo;dot-emacs\u0026rdquo; 정도로 검색해보면 수많은 다른 사람들의 설정을 찾아 볼 수 있다. https://dotfiles.github.io/ 여기도 마찬가지고.\n다만 역시나 처음부터 너무 많은 설정을 맞추려고 하지는 않았으면 좋겠다. 금방 지치기 쉬우니까.\n(뜬금없이) GNU프로젝트. 어쨌든 GNU 프로젝트니까, 대부분의 경우 문서화가 엄청 잘되있다.\nC-h i 눌러서 Info pages 을 이맥스 안에서 바로 살펴볼 수 있다.\n리눅스 배포판이라면 패키지 선택에 따라 다르겠지만, 보통 이맥스 매뉴얼과 튜토리얼 관련 문서들도 함께 설치하면, GNU Info pages으로 이맥스 매뉴얼들을 바로 읽어볼 수 있다. Info pages 읽는것에 익숙해져도 꽤 편안하다. \u0026lt;TAB\u0026gt;이랑 엔터키만 잘 눌러서 읽어나가면 되니까. 웹에서 검색해서 문서들 찾아봐도 좋고,\nEmacsWiki도 좋은 문서들이 많다.\n한국어 문서랑 영문 문서랑 항목들 차이가 많으니까, 영문에 익숙하고 그쪽에서 찾아보는게 낫다. 부록: 튜토리얼에서 알려주진 않는 생존법 단축키 표기법을 익숙하게 읽자.\nhttps://www.emacswiki.org/emacs/EmacsKeyNotation https://www.gnu.org/software/emacs/manual/html_node/emacs/User-Input.html#User-Input 정말 중요하다 뭔가 설명이 많고 그걸 읽어도 이상한 기호들로만 보이면;; (이미 말했듯이) 단축키를 익혀도 좋지만, 몰라도 좋다.\n다만 그 기능 을 구현하는 elisp 함수의 이름이라도 제대로 기억하거나, 그 키워드 는 확실하게 기억해두면 언제든지 원할때 찾을 수 있다. 예를 들어, C-h k C-x 1을 쳐보자, 해당 chords(C-x 1)의 설명과 실제로 그 코드가 실행하는 elisp 함수를 알 수 있다. (delete-other-windows) 심지어, F10키를 눌러서, 메뉴 어디에서 찾을 수 있는지도. :-) 반대로 C-h f delete-other-windows \u0026lt;RET\u0026gt;으로 함수를 기준으로 찾아들어가도, 어떤 키에 이 함수가 바인딩 되어있는지 알수있다. ..결국 이맥스에서 사용하는 용어(예: 버퍼buffer, region 등등에만 익숙하고, 함수나 변수, 단축키를 찾아가는 방법을 익혀놓으면 일일이 외우지 않아도 언제든지 찾아볼 수 있다.) C-h t: 커서 움직이기, 편집하기, 저장-불러오기. 지루하고, 꼭 진행하지 않아도 좋지만, 그래도 한번 익혀놓으면 대강 어떤 방식으로 편집하고, 컨벤션 같은걸 감을 잡을 수 있으니까 읽고 따라해보는걸 추천.\nC-h ?: 어디서부터 시작할지도 모르겠을때. 사실 도움말이랑 이맥스 설정변수, 함수, 어떤 키가 어떻게 동작하는지 궁금할때 이걸 열어보면 좋다. (사실 나중되면 C-h a 같은걸로 특정한 키워드의 변수나 함수를 바로 찾아보게 되지만, 처음에 어떤 그런 기능들이 있는지 살펴보기 좋다.)\nC-x o, C-x 1, C-x 0: Window 이라고 이맥스에서 표현하는 분할한 pane으로 포커스를 이동하거나 현재 pane만 남기고 감추거나, 현재 pane을 감추는 키들을 익숙하게 쓰는게 좋다. (도움말을 찾아서 읽으려고 해도, 이 방식이 익숙해지지 않으면 읽기 불편하다.)\n부록: 내가 쓰는 이맥스 패키지들 소개 내가 사용하는 패키지들을 소개하고, 어떻게 이맥스를 실제 작업흐름에 적용해 쓰는지 소개하고 싶었다. 개인적으로 훨씬 더 나은 패키지도 있을거고 설정이나 사용법은 취향에 따라 더 달라질 수 있을거 같다. 다만 처음 이맥스를 접하는 사람에게 이런것들이 이맥스에서 가능하다는걸 소개하는 의도로 해보겠다.\nProjectile Atom 에디터에서 제공하는 프로젝트 폴더 기능을 구현해준다. 프로젝트 폴더는 Git등의 저장소로 감지되거나, 프로젝트 최상위 디렉토리에 .projectile 빈 파일을 만들어놓으면 그 디렉토리부터 이하를 하나의 프로젝트로 인식하고 동작한다. 파일 빨리 열기나 프로젝트내 파일 이동, Git 연동 같은 부분들이 너무 편하다. Magit Git 커맨드를 직접 치지 않아도 된다. ..솔직히 Git 커맨드들 잘모르지만, 대부분의 git 작업을 정말 단순하게 할 수 있게 도와준다. Helm 소스코드에서 키워드나 참조에 따라 자동완성이 아니라, 이맥스 안에서 윈도 이름이나 파일 이름 자동완성등을 개선해주는 \u0026ldquo;프레임웍\u0026rdquo;. ..이런 성격의 패키지들이 몇개 있다. 그런데 나는 helm이 제일 편했다. helm-ag: https://github.com/ggreer/the_silver_searcher 소스코드를 빨리 내용 검색하는 the-silver-searcher 이랑 helm이랑 연동해준다. Projectile이랑도 연동이 되어 있어서 편함. helm-projectile: projectile 쓰니까 깔아봤음. Elpy 단순히 M-x python-mode이나 M-x run-python은 이맥스에 기본 내장. 그런거 말고 rope을 이용한 리팩토링, jedi 백엔드를 통한 자동완성(autocomplete, company등이랑 연동되서), flycheck 연동으로 PEP8이나 실시간 문법검사, virtualenv 연동 등등등 진짜 파이썬 개발하면서 파이썬 생태계의 쉘도구들을 잘 엮어서 정말 괜찮은 개발환경으로 만들어준다. 여기서 소개하지는 않았지만, Go-language이나 Ruby, 혹은 Clojure, CommonLisp을 작업할때 나는 꽤 즐겁게 이맥스에서 편집하고 편안하고 생산적으로 작업할 수 있었다.\n자신의 언어나 이맥스 작업흐름을 찾아보고 싶다면, https://www.youtube.com/에서 \u0026ldquo;emacs screencast\u0026rdquo; 혹은 이맥스와 자신의 주요 사용 언어나 환경을 키워드로 검색해 살펴보기를 추천한다.\n\u0026ldquo;모드\u0026rdquo; 이맥스는 여러가지 형식의 파일들을, 혹은 파일이 아닌 _버퍼_들을 각각의 _모드(modes)_을 통해서 구현함. 6\n그리고, 설정에 따라서 한 버퍼에 대해서 한 _Major mode_와 _Minor modes_으로 구분해볼 수 있을거 같다.\n예를 들어, 현재 내가 편집하는 파일이 파이썬 소스라면, 주요모드는 파이썬 모드일것이다. 하지만, 괄호나 여러가지 주요 기능들을 거기에 더 추가하고 싶어서 설정한 나머지 기능들은 minor-modes으로 그 버퍼에 적용되어있다.\n자세한 내용은 역시 공식 매뉴얼을 ㄱㄱ\n다만, 현재 버퍼에 적용된 모드들과 기능들을 보고 싶다면, C-h m으로. 각각의 적용된 모드들에 대해서 정리되어 있어서 보기 더 편하다.\n걱정하지않기. \u0026quot;Don't Panic! It's mostly harmless.\u0026quot; 솔직히 익히는데 상대적으로 시간도 많이 걸리고, 예쁘지도, 뭔가 투박해보이고 거추장스러워 보이는 에디터다.\n하지만, Vim을 익히고 사용해본 사람은 쉽게 이해할만한 부분이라고 생각하는점은, 익히고 익숙해지고 또 그 이후에 내게 맞춰서 편집기를 설정하고 하는만큼 편안하고 강력해진다는걸 말하고 싶다.\n그리고 그래도 딱히 추천하고 싶은 생각은 없다. 괴상한 취미가 없다면. 아톰이나 좋은 에디터는 충분히 많으니까. :-)\n그래도 해보고 싶다면, 겁내지 말고 차근차근 하나씩 설정해보고, 필요한 패키지들을 검색해보고 설치하고 설정해보면서 내게 잘 맞는 방법을 찾아보라고 말하고 싶다. 괜찮다. \u0026hellip;대부분은 크게 해가 되지 않는다. 7\nhttps://github.com/ageldama/configs/blob/master/emacs/init2.el 딱히 깔끔하게 정리해놓고, 주석도 착실하게 달아놓지 않아서 지저분하다. 처음 설정할 때, use-package.el 같은걸 특정한 위치에 git clone 을 직접해줘야 하는거 등 세팅할때도 설명이 더 필요하다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n사실 나는 Vim, Emacs 둘 다 쓰고, 그냥 터미널에서 뭔가 고치거나 그때 그때에 따라서 이맥스에 설정된거 거치지 않고, 그냥 Vim에서 빨리 고칠 수 있을만한건 거기에서 편집하고 쓰는거 같다. 그리고 Atom도 설치해놓고, 다른 소스 같은거 읽을때 주로 사용하는거 같다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n사실 이맥스를 익히는건, 내 생각엔 단축키나 편집키를 외우는것보다 동작하는 방식과 그걸 실시간으로 내가 찾아볼 수 있는 방법을 익히는쪽에 더 가깝고, 그편이 훨씬 재미있고 유용하다고 생각한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n(알고 있겠지만) Emacs을 위한 Vi 혹은 Vim 편집기의 편집키들을 그대로 사용할 수 있는 패키지들이 많이 있다. 이맥스 편집기능들이나 편집키들을 굳이 많이 외우지 않아도, 짧고 익숙한 Vi/Vim 방식을 써도 좋다.\nviper-mode은 아예 이맥스 기본 배포판에 포함되어있지만 개인적으로는 별로다. 나는 evil-mode을 사용한다. 어차피 이맥스랑 Vim 모두 익숙하고, 평소에는 이맥스 키바인딩으로 괜찮은데, 반복적인 편집이나 Vim으로 편집하는게 더 빠를거 같을때는 Evil-mode을 켜고 작업한다. \u0026#160;\u0026#x21a9;\u0026#xfe0e; 예를 들어,\nhelm vs ivy vs ido: https://www.reddit.com/r/emacs/comments/3o36sc/what_do_you_prefer_ido_or_helm/ 나는 helm 사용함. ㅎㅎ flycheck vs flymake flycheck이 더 예뻐서 좋아함. autocomplete vs company 이건 비밀. ..그런데 flycheck/flymake이나 autocomplete/company 같은건 어떤 프로그래밍언어 integration에서 잘지원하는걸 그냥 쓰게 되는 경향이 있는거 같다. (대부분은 둘 다 지원하긴하지만. ㅎㅎ) \u0026#160;\u0026#x21a9;\u0026#xfe0e; M-x tetris\u0026lt;RET\u0026gt; 테트리스 게임이나 magit, eshell 같은 기능들도 모두 버퍼이고, 이 버퍼의 해당 모드들으로 elisp을 통해 구현해놓은 기능들이다. 꼭 어떤 문법의 프로그램 소스코드만이 모드라고 하기는 어려운거 같다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n실제로 MS윈도 환경에서 이맥스가 잘 동작하게 하려면 리눅스나 맥OS에서보다 더 설정에 신경을 써야하고 짜증난다. 그리고 내가 주로 사용하는 언어가 자바라면 그냥 이클립스나 IntelliJ을 쓰는게 더 편할때도 많은거 같다. 그리고 비주얼스튜디오이거나. 그럼에도 마우스를 쓰기 귀찮아 죽겠거나, 이미 익숙해질대로 익숙해져서 이맥스와 Vim, 쉘프롬프트가 좋다면 어쩔수없다. 그리고 파이썬, 대부분의 리습계열 언어들, 루비, go, rust, erlang, elixir 등등의 오픈소스이거나 한 언어들은 오히려 편한 IDE으로서 동작하는 편집기가 흔치는 않은거 같다. (개인적으로) \u0026hellip;하지만 가장 중요한건 개인적인 생각이라는점이고, 자기가 편하다고 느끼고 쓸만하다고 생각하는걸 써야하는거 같다. ..다만 현재 자기가 쓰는것에서 뭔가 더 찾아보고 싶거나, 심심하거나 하다면 익혀보길 추천한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},
 {
     "permalink": "https://ageldama.github.io/posts/2017/2017-01-01-welcome-to-jekyll/","title": "🛫 Welcome to Jekyll!",
     
     "tags": ["blog blogging jekyll"],
     
 "description": "",
 "contents": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.\nTo add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.\nJekyll also offers powerful support for code snippets:\n{% highlight ruby %} def print_hi(name) puts \u0026ldquo;Hi, #{name}\u0026rdquo; end print_hi(\u0026lsquo;Tom\u0026rsquo;) #=\u0026gt; prints \u0026lsquo;Hi, Tom\u0026rsquo; to STDOUT. {% endhighlight %}\nCheck out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.\n"},
 {
     "permalink": "https://ageldama.github.io/archive/","title": "🎋 Posts Archive",
     
     "tags": [],
     
 "description": "",
 "contents": ""},
 {
     "permalink": "https://ageldama.github.io/posts/archive/","title": "🎋 Posts Archive",
     
     "tags": [],
     
 "description": "",
 "contents": ""}]
