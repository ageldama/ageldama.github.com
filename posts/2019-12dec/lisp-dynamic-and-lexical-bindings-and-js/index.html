<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let - 아겔로그</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="다음의 간단한 코드를 읽어보자.
1 2 3 4 5 6 7 8 9 10 11 12 var x = &#34;lexical&#34;; function maker() { return function() { return x; }; } { var x = &#34;dynamic&#34;; assert(maker()() == &#34;???&#34;); } maker()() 의 결과는 &#39;dynamic&#39; 이다.
심지어, 맨 마지막에 있는 {..} 블록을 넘어가서도 x 의 값은 여전이 &#39;dynamic&#39; 이다.
자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난 느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도 속하지 않는 느낌이고, 이번에 새로 추가된 let 도 이해하기가 어려운게 아니라 그냥 제대로 망가져 있는거 같다." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://ageldama.github.io/posts/2019-12dec/lisp-dynamic-and-lexical-bindings-and-js/">
  <meta property="og:site_name" content="아겔로그">
  <meta property="og:title" content="Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let">
  <meta property="og:description" content="다음의 간단한 코드를 읽어보자.
1 2 3 4 5 6 7 8 9 10 11 12 var x = &#34;lexical&#34;; function maker() { return function() { return x; }; } { var x = &#34;dynamic&#34;; assert(maker()() == &#34;???&#34;); } maker()() 의 결과는 &#39;dynamic&#39; 이다.
심지어, 맨 마지막에 있는 {..} 블록을 넘어가서도 x 의 값은 여전이 &#39;dynamic&#39; 이다.
자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난 느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도 속하지 않는 느낌이고, 이번에 새로 추가된 let 도 이해하기가 어려운게 아니라 그냥 제대로 망가져 있는거 같다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-12-30T00:00:00+09:00">
    <meta property="article:modified_time" content="2019-12-30T00:00:00+09:00">
    <meta property="article:tag" content="Lisp">
    <meta property="article:tag" content="Scheme">
    <meta property="article:tag" content="Common-Lisp">
    <meta property="article:tag" content="Emacs-Lisp">
    <meta property="article:tag" content="Guile">
    <meta property="article:tag" content="Clojure">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let">
  <meta name="twitter:description" content="다음의 간단한 코드를 읽어보자.
1 2 3 4 5 6 7 8 9 10 11 12 var x = &#34;lexical&#34;; function maker() { return function() { return x; }; } { var x = &#34;dynamic&#34;; assert(maker()() == &#34;???&#34;); } maker()() 의 결과는 &#39;dynamic&#39; 이다.
심지어, 맨 마지막에 있는 {..} 블록을 넘어가서도 x 의 값은 여전이 &#39;dynamic&#39; 이다.
자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난 느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도 속하지 않는 느낌이고, 이번에 새로 추가된 let 도 이해하기가 어려운게 아니라 그냥 제대로 망가져 있는거 같다.">

	
		<script src="https://ageldama.github.io/js/jquery-3.7.1.slim.min.js"></script>
		<script src="https://ageldama.github.io/js/DarkMode.js"></script>
	        

        
            
            
                
                    
                        <link rel="stylesheet" href="/css/gopherish.30a8863f637ad6b905d4cfd2bb3891ac99a97381caa99f85b4e2ba9705811847.css" integrity="sha256-MKiGP2N61rkF1M/SuziRrJmpc4HKqZ&#43;FtOK6lwWBGEc=" crossorigin="anonymous">
                    
                
            
        
	
	
</head>
<body>
        <div class="content"><header>
    <div class="main ">
        <a class="site-title "
           href="https://ageldama.github.io/">아겔로그</a>
    </div>
    
    <nav>
        <a class="dark-mode-toggle"
           onclick="javascript:DarkMode.toggle()"
           href="#"></a>
        <script>
         $(function(){
             DarkMode.init();
         });
        </script>

        
            <a href="/posts/archive/">Archive🗃️</a>
        
            <a href="/tags/">Tags🏷️</a>
        
            <a href="/index.xml">RSS&lt;/&gt;</a>
        
            <a href="/myself/">Contact📨</a>
        

	
    </nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let</h1>
			<div class="meta"> 🗓️ 2019_Dec_30</div>
		</div>
		

		<section class="body">
			
<p>
다음의 간단한 코드를 읽어보자.</p>
<div class="src src-js">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;lexical&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">maker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;dynamic&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">assert</span><span class="p">(</span><span class="nx">maker</span><span class="p">()()</span> <span class="o">==</span> <span class="s2">&#34;???&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
<code>maker()()</code> 의 결과는 <code>&#39;dynamic&#39;</code> 이다.</p>
<p>
심지어, 맨 마지막에 있는 <code>{..}</code> 블록을 넘어가서도 <code>x</code> 의 값은 여전이
<code>&#39;dynamic&#39;</code> 이다.</p>
<p>
자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난
느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도
속하지 않는 느낌이고, 이번에 새로 추가된 <code>let</code> 도 이해하기가 어려운게
아니라 그냥 제대로 망가져 있는거 같다.</p>
<p>
그나마, <code>let</code> 키워드를 이용하면, lexical binding으로서나마 제대로
동작하기 시작한다.</p>
<div class="src src-js">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">assert</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;assert&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;lexical&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">maker</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;dynamic&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">assert</span><span class="p">(</span><span class="nx">maker</span><span class="p">()()</span> <span class="o">==</span> <span class="s2">&#34;lexical&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">assert</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="s2">&#34;dynamic&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="s2">&#34;lexical&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
그러면, lexical binding와 dynamic binding이 뭐길래 나는 이렇게
괴로워 하는가.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
dynamic binding &amp; lexical binding
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
  커먼리습으로 예시 코드를 짜봤다:<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup></p>
<div class="src src-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl">  <span class="c1">;; every `defvar&#39;, `defparameter&#39; is dynamic binding.</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defvar</span> <span class="vg">*x*</span> <span class="no">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">f-dynamic</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="vg">*x*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">y</span> <span class="ss">&#39;lexical</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nb">defun</span> <span class="nv">f-lexical</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="nv">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">run</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="vg">*x*</span> <span class="ss">&#39;dynamic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="nv">y</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">; silence the: &#34;style-warning: The variable Y</span>
</span></span><span class="line"><span class="cl">                                          <span class="c1">; is defined but never used.&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">l</span> <span class="p">(</span><span class="nb">multiple-value-list</span> <span class="p">(</span><span class="nf">values</span> <span class="p">(</span><span class="nv">f-dynamic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">(</span><span class="nv">f-lexical</span><span class="p">)))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nf">pprint</span> <span class="nv">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">l</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">dynamic</span> <span class="nv">lexical</span><span class="p">))))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">run</span><span class="p">)</span> <span class="c1">; 실행</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
dynamic binding와 global variable
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p><code>defvar</code> 으로 global-scope에 만든 변수, <code>*x*</code> 을 되돌리는 함수를 만드는
  함수, <code>f-dynamic</code> 이고, 이를 호출 하는 시점에 <code>let</code> 으로 이를 덮어
  씌운다. 그리고 결과도 덮어 씌운 값으로 나온다.</p>
<p>
  이는 마치 다음이 괜찮은 코드라는 의미:</p>
<div class="src src-python">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;no-dynamic&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;dynamic!&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="k">assert</span> <span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dynamic!&#39;</span> <span class="c1"># 실패한다. </span>
</span></span><span class="line"><span class="cl">      <span class="c1"># 여전히 f()안에서는, x == &#39;no-dynamic&#39;이다.</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
  그런데, 커먼리습에서는 이게 된다.</p>
<p>
  심지어, 커먼리습의 대부분의 함수, 매크로는 이렇게 쓰는게 일반적인
  idiom이다:</p>
<div class="src src-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defvar</span> <span class="vg">*some-stream*</span> <span class="vg">*standard-output*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">print-sth</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nf">format</span> <span class="vg">*some-stream*</span> <span class="s">&#34;~a~%&#34;</span> <span class="nv">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">print-sth</span> <span class="mi">42</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="vg">*some-stream*</span> <span class="vg">*standard-error*</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">print-sth</span> <span class="ss">:error!!!!</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
  다른 언어였었다면:</p>
<ol>
<li><code>*some-stream*</code> 을 <code>print-sth</code> 이 종속하므로, <sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup></li>
<li>파라미터로 받거나, (default value이 지정되어 있는 optional
parameter이라던가)</li>
<li>builder pattern 같은 것을 사용해서 스트림을 지정하고, 그에
따라 동작하는 메서드로 <code>print-sth</code> 을 정리해야 했겠지</li>
</ol>
<p>위에 말한 방법들 모두 커먼리습에서 쉽게 가능하고 많이 사용하는
  방법이지만, 그래도 이런 방식으로 context 객체나 어떤 모듈에서 널리
  공유하는 상태를 적용할 때 이렇게 <strong>dynamic binding</strong> 을 이용한다.</p>
<p>
  그리고 이렇게 적용하는 것도 <code>defvar</code>, <code>defparameter</code>, <code>let</code> 으로
  간단하고 일상적이다.</p>
<p>
  전역변수와 같은 모양이지만, 전역변수랑 동일하게 생각하기는 조금
  다르다. 언제나 문맥에 따라서 파라미터로 사용하기 위해서 있는 것이고,
  또 그렇게 쓰도록 권장하니까.<sup class="footnote-reference"><a id="footnote-reference-3" href="#footnote-3">3</a></sup></p>
<p>
  JS에서 <code>var</code>, <code>let</code> 모두 이렇게 만들기는 잘 모르겠다. 쉽지는 않을거
  같다.</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
lexical binding
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>위 예제 코드에서 <code>f-lexical</code> 은 그 함수가 선언되는 시점, <code>defun
   f-lexical</code> 시점의 <code>y</code> 을 언제나 갖고 있고, dynamic binding와는
   다르게, <code>let</code> 을 통해 변경할 수 없다.</p>
<p>
   또, 어떤 변수가 lexically하게 가장 가까운 scope에서 선언된 내용을
   사용한다.</p>
<div class="src src-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;f</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nb">defun</span> <span class="nv">f</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nf">pprint</span> <span class="nv">x</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">run</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;run-1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;run-2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nf">pprint</span> <span class="nv">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nv">f</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">#|
</span></span></span><span class="line"><span class="cl"><span class="cm">  CL-USER&gt; (run)
</span></span></span><span class="line"><span class="cl"><span class="cm">  RUN-2
</span></span></span><span class="line"><span class="cl"><span class="cm">  F
</span></span></span><span class="line"><span class="cl"><span class="cm">  |#</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   같은 함수, 호출스택 안에서는 단순하게 가장 가까운 <code>let</code> 의 선언으로
   덮어씌운 <code>x</code> 을 사용하지만, dynamic binding와는 다르게, <code>f</code> 을
   호출해서 스택프레임이 달라지면 덮어 씌우지 못한다.</p>
<p>
   이해하기 단순, 간단하다.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
closure와 lexical binding
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>사실, lexical scope만 제대로 있어도 여러모로 편안해진다.</p>
<ol>
<li>블록의 단계별로 같은 이름인 변수의 덮어쓰기, 요즘 흔히 말하는
shadowing.</li>
<li>그리고 요즘 많이 알려진 closure으로 감싸는 환경environment, 그
변수를 감싸서 갖고 있는 것도, <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">lexical closure</a> 이다.</li>
</ol>
<p>
  JS은 closure을 지원하기는 했지만, <code>let</code> 이전에는 제대로 lexical
  binding을 지원했다고 할 수는 없다. (맨 처음 섹션에서 보였듯이)</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
추가: Emacs-Lisp, Scheme, Clojure에서 lexical/dynamic bindings
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>오늘 포스팅은 딱히 엄청난 결론을 이끌어내지는 못해서 그냥 Lisp계열
  언어들의 예제들을 나열이나 해보려고 한다.</p>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Scheme
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>Scheme에서는 lexical binding만 지원한다.</p>
<p>
   하지만, dynamic binding은 <a href="https://srfi.schemers.org/srfi-39/srfi-39.html">SRFI-39</a> 으로 라이브러리/함수로서
   추가적으로 지원한다.</p>
<p>
   위 SRFI-39에서도 보이듯이, closure와 macro을 이용해서 스킴
   컴파일러/인터프리터를 확장하지 않고도 추가할 수 있다. (그리고
   어쩌면 이렇게 유사한 방법으로 JS에도 추가할 수 있겠지)</p>
<div class="src src-scheme">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scheme" data-lang="scheme"><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">use-modules</span> <span class="p">((</span><span class="nf">rnrs</span><span class="p">)</span> <span class="nv">:version</span> <span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">define </span><span class="nv">var-dynamic</span> <span class="p">(</span><span class="nf">make-parameter</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lexical-maker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var-lexical</span> <span class="ss">&#39;lexical-1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">var-lexical</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dynamic-maker</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nf">var-dynamic</span><span class="p">)))</span> <span class="c1">; `var-dynamic&#39; needs to be evaluated as</span>
</span></span><span class="line"><span class="cl">                               <span class="c1">; a function to get its&#39; value.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">var-lexical</span> <span class="ss">&#39;lexical-no!</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nf">assert</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">((</span><span class="nf">lexical-maker</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                   <span class="ss">&#39;lexical-1</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nf">parameterize</span> <span class="p">((</span><span class="nf">var-dynamic</span> <span class="ss">&#39;dynamic-yes</span><span class="p">))</span> <span class="c1">; not just `let&#39;, it&#39;s</span>
</span></span><span class="line"><span class="cl">                                               <span class="c1">; `parameterize&#39;.</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nf">assert</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">((</span><span class="nf">dynamic-maker</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                   <span class="ss">&#39;dynamic-yes</span><span class="p">))))</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   조금 괄호가 복잡해보인다. Scheme의 특성으로, lambda-function을
   값으로 되돌리고, 또 그걸 그대로 <code>(...)</code> 으로 감싸서 <code>funcall</code> 처럼
   바로 평가해 버리니까 2중 괄호로 감싼게 좀 보인다.</p>
<p>
   <code>make-parameter</code> 으로 만든 dynamic binding은 사실 언어 차원에서
   지원하는 바인딩이 아니고, 그냥 box-container의 일종일테고,
   <code>parameterize</code> 매크로를 사용해서 마치 커먼리습에서 <code>let</code> 을 이용해
   값을 binding한다. ..그리고 또 괄호로 parameter object을 감싸서
   함수로서 평가하여, bind된 값을 참조해낸다. (이렇게 괄호가 또
   생긴다.)</p>
<p>
   <a href="https://www.gnu.org/software/guile/">GNU Guile</a> 에서 테스트했다. Racket등에서는 <code>use-modules</code> 이 동일하게
   동작할지 모르겠다. 아마 이 라인 대신에 <code>#lang racket</code> 정도로
   대체하면 잘 동작할거 같다.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Emacs-Lisp
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>Emacs-Lisp은 원래는 dynamic binding만 지원했엇다.</p>
<p>
   그리고 지금은 lexical binding을 지원하기 위해서는 사용하려는
   소스코드의 <a href="https://www.emacswiki.org/emacs/FileLocalVariables">file local variable</a> 으로 지정해줘야 함.</p>
<div class="src src-emacs-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">assert</span> <span class="p">(</span><span class="nf">eq</span> <span class="ss">&#39;dynamic</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;lexical</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="nv">x</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="nf">funcall</span> <span class="nv">f</span><span class="p">))))))</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   위 코드는 dynamic binding으로 동작한다.</p>
<p>
   lexical binding을 쓰려면 다음과 같이 달라진다.</p>
<div class="src src-emacs-lisp">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl">  <span class="c1">;;; -*- lexical-binding: t; -*-</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">assert</span> <span class="p">(</span><span class="nf">eq</span> <span class="ss">&#39;lexical</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;lexical</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="nv">x</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;dynamic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="nf">funcall</span> <span class="nv">f</span><span class="p">))))))</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   맨 첫 번째 특별한 주석으로 표기한 부분을 눈여겨 보라.</p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Clojure
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>Clojure은 기본은 lexical binding을 지원한다. (<code>let</code> 을 통해서)</p>
<p>
   그렇지만, <code>^:dynamic</code> metadata와 <code>binding</code> 으로 dynamic binding을
   지정 가능하다:</p>
<p>
   <a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/binding">http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/binding</a></p>
<div class="src src-clojure">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="cl"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">x</span> <span class="mi">2</span> <span class="nv">y</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
결론
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>커먼리습하자.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
Footnotes
</h2>
</div>
<div class="footnotes">
<hr class="footnotes-separatator">
<div class="footnote-definitions">
<div class="footnote-definition">
<sup id="footnote-1"><a href="#footnote-reference-1">1</a></sup>
<div class="footnote-body">
<p>다른 Lisp이 아닌 언어로는 짜기가 어렵거나, 아예 가능하지도
않으니까. 그리고 커먼리습이 Lisp-dialects 중에서 이를 표현하기에
명확하다고 생각한다.</p>
</div>
</div>
<div class="footnote-definition">
<sup id="footnote-2"><a href="#footnote-reference-2">2</a></sup>
<div class="footnote-body">
<p>이렇게 dynamic binding인 변수는, 커먼리습의 관례는 <code>*...*</code> 와
같이 표기한다. 참고로 상수는 <code>+...+</code>. –&gt; <a href="https://google.github.io/styleguide/lispguide.xml#Global_variables_and_constants">Google Common Lisp Style
Guide</a></p>
</div>
</div>
<div class="footnote-definition">
<sup id="footnote-3"><a href="#footnote-reference-3">3</a></sup>
<div class="footnote-body">
<p>오히려 전역변수는 없는 쪽이 가깝다. 다른 변수로 상태를 표현하고
싶다면, <code>defstruct</code>, <code>defclass</code> 으로 객체를 만드록 정리하겠지.</p>
</div>
</div>
</div>
</div>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li style="display: inline">#<a href="/tags/lisp">lisp</a></li>
					
					<li style="display: inline">#<a href="/tags/scheme">scheme</a></li>
					
					<li style="display: inline">#<a href="/tags/common-lisp">common-lisp</a></li>
					
					<li style="display: inline">#<a href="/tags/emacs-lisp">emacs-lisp</a></li>
					
					<li style="display: inline">#<a href="/tags/guile">guile</a></li>
					
					<li style="display: inline">#<a href="/tags/clojure">clojure</a></li>
					
					<li style="display: inline">#<a href="/tags/javascript">javascript</a></li>
					
					<li style="display: inline">#<a href="/tags/dynamic-binding">dynamic-binding</a></li>
					
					<li style="display: inline">#<a href="/tags/lexical-binding">lexical-binding</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  
  <div class="footer-info">
    2025  © <a href='/myself'>ageldama</a> 👾  | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-YSB7MGHZ4V"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YSB7MGHZ4V');
</script>
<script>
  
</script></div>
    </body>
</html>
