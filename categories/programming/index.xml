<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on 아겔로그</title>
    <link>https://ageldama.github.io/categories/programming/</link>
    <description>Recent content in Programming on 아겔로그</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© &lt;a href=&#39;https://ageldama.github.io/myself&#39;&gt;ageldama&lt;/a&gt; 👾</copyright>
    <lastBuildDate>Wed, 12 Mar 2025 10:40:27 +0000</lastBuildDate>
    <atom:link href="https://ageldama.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>data-driven programming &amp; data-driven design &amp; data-oriented programming ???</title>
      <link>https://ageldama.github.io/posts/2025-03mar/2025-03mar12--01-data-prog/</link>
      <pubDate>Wed, 12 Mar 2025 10:40:27 +0000</pubDate>
      <guid>https://ageldama.github.io/posts/2025-03mar/2025-03mar12--01-data-prog/</guid>
      <description>비슷한 용어들. 내가 이해한 정리들은 1:&#xA;data-driven programming 데이터처리를 중심으로 하는 프로그래밍언어나 도구, 스타일.&#xA;예를 들어, awk, perl은 입력의 패턴에 따라 코드를 나누고 출력을 만들기 수월한 방식을 제공.&#xA;https://en.wikipedia.org/wiki/Data-driven_programming a &amp;#34;replacement&amp;#34; for awk and sed (by Larry Wall) data-oriented design 현대 cpu의 아키텍처에 적절하도록, cpu cache, simd등을 잘 적용될 수 있도록 애플리케이션 데이터구조를 설계하는 방식.2&#xA;그리고 단순히 게임개발에서 ecs만이 아니라 lmax disruptor등도 포함될 것 같다.&#xA;https://en.wikipedia.org/wiki/Data-oriented_design dod의 예시: Entity component system lmax disruptor (by Martin Fowler) data-oriented programming 그리고 또 갑자기 위 2개의 정의처럼 완전 갑자기, dop은 다음과 같은 원칙들을 이용한 애플리케이션 개발방식:</description>
    </item>
    <item>
      <title>xmake, compile_commands.json, flycheck</title>
      <link>https://ageldama.github.io/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</link>
      <pubDate>Mon, 06 May 2024 07:51:13 +0000</pubDate>
      <guid>https://ageldama.github.io/posts/2024-05may/2024-05may06--xmake-compile_commands_json-flycheck/</guid>
      <description>cmake/warp등을 써보면서 c/c++ 개발할 때에 빌드도구 갖고 놀다가, 이번에 마음을 열고 xmake을 익혀봄.&#xA;마음에 든다. 가볍고 빠르고 좋다.&#xA;ccache등도 바로 지원하고, lua으로 스크립팅도 그럭저럭 할만해 보이고, [build.zig](https://ziglang.org/learn/build-system/)스러워서 당연하게도 좋은거 같아.&#xA;계속 쓸거 같다.&#xA;emacs / flycheck + c/c++ 개발할 때에 단점이, 자동적으로 외부 3rd-party 라이브러리의 include-path을 설정해주지 않아서, [dirs-local](https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html) 같은걸 세팅해주길 기대한다는 점.&#xA;그래서 그냥 xmake project -vD -k compile_commands -m debug 같이 compile_commands.json 생성하고,&#xA;이걸 파싱해서 표준출력으로 include-paths https://github.</description>
    </item>
    <item>
      <title>Ping 04/02/2023 .01: 씨언어의 장자 zig, rust, golang, c&#43;&#43; ???</title>
      <link>https://ageldama.github.io/posts/2023-02feb/2023-02feb04--01-ping/</link>
      <pubDate>Sat, 04 Feb 2023 16:46:54 +0000</pubDate>
      <guid>https://ageldama.github.io/posts/2023-02feb/2023-02feb04--01-ping/</guid>
      <description>최근에 재미로 zig 을 정말 재밌게 &amp;#39;읽었다&amp;#39;. 공부해보고 실제로 뭔가 코딩을 많이 해보거나 한 것은 아니고, 대체 어떻게 동작하는 프로그램을 이걸로 만들라고 하는건지 이해하고 싶었기 때문에 해봤다.&#xA;zig으로 프로그램을 짜는게 궁금하던 부분은 haskell의 monad을 이용한 방식, 혹은 apl이나 prolog으로 실제프로그램을 어떻게 만들 수 있을지 패러다임부터 다른 언어를 공부하고 생각해보는 것과는 조금 다를수도 있겠다. 어쨌든 그냥 imperative언어이니까.&#xA;오히려, zig을 어떻게 써먹어야 할지 궁금하던 지점은, c++의 스마트포인터와 move semantics등을 이해하는 것이나, rust의 borrowing checker, rc/arc등을 이해하는 것과 마찬가지인 것 같다.</description>
    </item>
    <item>
      <title>Python &#43; Generator / LeetCode &#34;1614. max nesting depth of the parentheses&#34;</title>
      <link>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</link>
      <pubDate>Wed, 11 Nov 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-11nov/leet-code-1614-3rd/</guid>
      <description>지난 번 작성한 Common Lisp / LOOP매크로을 이용한 구현 을 다른 언어에서였다면, 비슷한 조건으로 메모리 복잡도 O(1)으로 풀어보고 싶었다.&#xA;1 2 3 4 5 6 7 8 from itertools import accumulate def find_paren_count(s): gen_only_parens = (ch == &amp;#39;(&amp;#39; and 1 or -1 for ch in s if ch in (&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;,)) return max(accumulate(gen_only_parens)) 다른 언어에서도 lazy stream을 지원한다면 비슷하게 풀 수 있을 것 같다.</description>
    </item>
    <item>
      <title>&#34;org-more.el&#34; released!</title>
      <link>https://ageldama.github.io/posts/2020-11nov/org-more-1st-rel/</link>
      <pubDate>Wed, 04 Nov 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-11nov/org-more-1st-rel/</guid>
      <description>org-more.el: search .org files have certain tags (#+tags[]: or #+tags[]:)&#xA;개인 위키, KB처럼 org 파일 모음을 사용하고 있는데, 디렉토리 계층과 직접 링크 관계만이 아니라 같은 태그들으로 묶어서 각 파일들을 검색하고 리스팅 할 수 있도록 만들었다.</description>
    </item>
    <item>
      <title>&#34;asdf-subdir-finder&#34; released!</title>
      <link>https://ageldama.github.io/posts/2020-10oct/asdf-subdir-finder-1st/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/asdf-subdir-finder-1st/</guid>
      <description>지난번 포스팅한 &amp;#34;asdf 정의를 내 코드베이스의 하위디렉토리에서 자동으로 로딩하기&amp;#34;를 프로젝트으로 만들었다.&#xA;https://github.com/ageldama/asdf-subdir-finder&#xA;사람마다 커먼리습으로 작업하는 스타일에 따라 많이 다를 수 있어서 안 써도 되기도 하지만, 그냥 정리해서 공개는 해봤다.</description>
    </item>
    <item>
      <title>&#34;커먼리습 ASDF 불러오기 편하게 하기&#34; 대모험</title>
      <link>https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/lisp-asdf-subdir-finder/</guid>
      <description>ASDF와 system definition file 검색의 정석 이전에 ASDF을 이용하여 커먼리습 프로젝트의 의존성, 시스템을 로딩하기 에 대해서 설명한 적이 있었다.&#xA;이전에 다룬 내용은 정석적으로 $HOME/common-lisp 디렉토리에 .asd 파일을 심볼릭링크를 걸고, (asdf:load-system ..) 을 시도하는 내용이었었다.&#xA;Prototyping등 더 편안하게 혼자 코딩을 할 때는… 혼자 커먼리습 코딩을 하면서, 나는 더 간단하게 프로젝트를 시작하는 방법을 선호한다.&#xA;커먼리습이 파일 이름이나 경로에 대해서 의존하는 것이 아니고, 컴파일시점, 로딩시점에 순서에 따라 로딩해서 최종적으로 컴파일하여 적재한 결과 이미지를 더 중요하게 여기기 때문에, 그리고 그런 컴파일, 빌드, 로딩과 같은 모든 단계들 자체도 커먼리습 표현식 그자체로 동작하기 때문에 그냥 하나의 소스파일을 섹션별로 나눠서 작업하면 편리하다.</description>
    </item>
    <item>
      <title>CommonLisp (w/o LOOP-macro) / LeetCode &#34;1614. max nesting depth of the parentheses&#34;</title>
      <link>https://ageldama.github.io/posts/2020-10oct/leet-code-1614-2nd/</link>
      <pubDate>Wed, 21 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/leet-code-1614-2nd/</guid>
      <description>어제 작성한 LOOP매크로을 이용한 구현 을 풀어서, 만약 LOOP매크로가 없었더라면 어떻게 짰을지 작성해봤다.&#xA;1 2 3 4 5 6 7 8 9 10 11 12 (defun max-nested-parentheses-raw (s) (declare (optimize (speed 3) (safety 0)) (type simple-string s)) (let ((n 0) (result 0)) (declare (type fixnum n result)) (dotimes (s--cur-idx (length s)) (let ((ch (elt s s--cur-idx))) (when (member ch &amp;#39;(#\( #\))) (incf n (if (eql #\( ch) 1 -1)) (setf result (max n result))))) result)) 여전히 타입을 지정해서 자동으로 타입추론, 최적화 하도록 했다.</description>
    </item>
    <item>
      <title>CommonLisp / LeetCode &#34;1614. max nesting depth of the parentheses&#34;</title>
      <link>https://ageldama.github.io/posts/2020-10oct/leet-code-1614/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-10oct/leet-code-1614/</guid>
      <description> 문제 https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/&#xA;작성한 코드 1 2 3 4 5 6 7 8 (defun max-nested-parentheses (s) (declare (optimize (speed 3) (safety 0)) (type simple-string s)) (loop with n fixnum = 0 for ch across s when (member ch &amp;#39;(#\( #\))) do (incf n (if (eql #\( ch) 1 -1)) maximizing n)) 코드 의도 우아한 코드보다는 공간복잡도가 O(1) 이고 싶었다. Edit SBCL에 맞춰 코드에 타입을 지정해줘봤다.&#xA;결과 어셈블리 코드가 조금 짧아졌다. </description>
    </item>
    <item>
      <title>Python에 대한 내 관점</title>
      <link>https://ageldama.github.io/posts/2020-09sep/perspective-on-python/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-09sep/perspective-on-python/</guid>
      <description>Python은 조금 지루한 문법의 언어다. 거기에 매크로 같은 기능도 없어서 항상 평이한 문장을 작성하게 되는 것 같다.&#xA;하지만 다른 비슷한 언어들과는 다르게, 파이썬 문장 자체는 깔끔하면서도 density가 높다. 리습, 하스켈 같은 언어들으로 작성한 것을 생각해봐도 밀도가 높아 표현력이 좋다.&#xA;Java와 같은 언어는 밀도도 낮고 표현력도 가끔은 너무 아쉽다.&#xA;파이썬이 이렇게 밀도가 높을 수 있는 이유는, 언어 자체적으로 매크로를 지원하거나 해서 문법을 확장하는 방법을 채택하는 것이 아니라 SymPy에서 그랬었던 것처럼 값을 계속 쌓아갈 수 있게 만들고 연산자를 재정의해서 문장이 다르게 해석되도록 만드는 방법이고, 이쪽이 더 Pythonic한 방법 같다.</description>
    </item>
    <item>
      <title>코드 편집기에 대한 생각</title>
      <link>https://ageldama.github.io/posts/2020-05may/editors/</link>
      <pubDate>Thu, 28 May 2020 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-05may/editors/</guid>
      <description>코드 편집기를 어떻게 써왔었는지 잠깐 생각해봤다:&#xA;DOS시절: MS-DOS Editor.&#xA;GW-BASIC 시절에는 정말 https://en.wikipedia.org/wiki/MS-DOS_Editor 을 열심히 썼었던 것 같다. 그리고 그 다음엔 PowerBASIC for DOS 열심히 썼었다. QuickBASIC 같은 바이트코드으로 컴파일해서 .exe 파일에 인터프리터와 바이트코드를 embedding 하는 VB의 P-code 같은 가짜 컴파일 방식1이 아니라 정말 네이티브 코드로 컴파일해주고, 인라인 어셈블리와 메모리 조작이 가능한 베이직 컴파일러, IDE여서 좋은 환경이었던 것 같다. 터보C 2.0 편집기. PowerBASIC이랑 유사해서 익숙하게 쓸 수 있었던 것 같다.</description>
    </item>
    <item>
      <title>Covariant, Contravariant, Invariant등 Type Variances 이해하기</title>
      <link>https://ageldama.github.io/posts/2020-01jan/type-variances/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:02 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2020-01jan/type-variances/</guid>
      <description>거의 그대로 베껴온 원본 글&#xA;계약서로서의 타입 타입을 생각할 때, &amp;lt;계약서&amp;gt;로 생각하는 것이 편하다.&#xA;왜냐하면, 전달한 값이 그 타입의 범위 안에서 전달 받은 쪽에서 취급이 제한된다는 보장이 있어야 안전한 코드를 컴파일러는 생성해줄 수 있다. (혹은 그렇게 안전한지 체크를 해준다.)&#xA;Subtype, 일반화(Generalization), 특화(Specialization) 타입을 말할 때, 나는 보통 객체지향언어에서의 클래스의 상속 관계를 떠올린다. 꼭 그렇지는 않겠지만, 이 글에서도 그렇게 설명을 해보겠다.&#xA;이 글에서는 계속 다음 3개의 타입이 있고, 다음과 같은 관계라고 가정하겠다.</description>
    </item>
    <item>
      <title>Lisp에서 Dynamic/Lexical Binding와 JavaScript의 var/let</title>
      <link>https://ageldama.github.io/posts/2019-12dec/lisp-dynamic-and-lexical-bindings-and-js/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/lisp-dynamic-and-lexical-bindings-and-js/</guid>
      <description>다음의 간단한 코드를 읽어보자.&#xA;1 2 3 4 5 6 7 8 9 10 11 12 var x = &amp;#34;lexical&amp;#34;; function maker() { return function() { return x; }; } { var x = &amp;#34;dynamic&amp;#34;; assert(maker()() == &amp;#34;???&amp;#34;); } maker()() 의 결과는 &amp;#39;dynamic&amp;#39; 이다.&#xA;심지어, 맨 마지막에 있는 {..} 블록을 넘어가서도 x 의 값은 여전이 &amp;#39;dynamic&amp;#39; 이다.&#xA;자바스크립트에서 binding은 어딘가 이도 저도 아니게 심각하게 고장난 느낌이다. 이 글에서 이야기할 lexical binding이나 dynamic binding에도 속하지 않는 느낌이고, 이번에 새로 추가된 let 도 이해하기가 어려운게 아니라 그냥 제대로 망가져 있는거 같다.</description>
    </item>
    <item>
      <title>direnv &#43; direnv-mode 이맥스 지원 &#43; C/C&#43;&#43;/Python등 프로젝트 설정 적용하기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/direnv/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/direnv/</guid>
      <description>프로젝트의 빌드 디렉토리, virtualenv와 같은 경로의 설정, 경로 설정에 따른 빌드/실행/테스팅/스크립트을 편하게 하려고 만든 moonshot.el 와 유사한걸 검색해봤다.&#xA;몇 가지 이런 비슷한게 몇 가지 있는데, 내 상황에 쓸만한 것은 direnv&#xA;NPM: dotenv https://www.npmjs.com/package/dotenv&#xA;Node.js에서 Unix environment variable으로 .env 파일을 로딩해주는 역할인 듯.&#xA;Shell에서 Hook 걸어서 사용하기엔 별로 인거 같았다.&#xA;그리고 Node.js 이외의 프로젝트에 적용하려면 매번 JS으로 wrapper을 짜주고 하기 싫었고,&#xA;.env 파일이 그냥 정적인 key-value 문자열의 나열이라, 파일시스템에서 경로를 조립하고 하는데 별로라는 생각이 들었다.</description>
    </item>
    <item>
      <title>moonshot.el 최초 릴리즈</title>
      <link>https://ageldama.github.io/posts/2019-12dec/moonshot-1st-rel/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/moonshot-1st-rel/</guid>
      <description>moonshot.el 을 만들어서 공개했다.&#xA;이맥스를 써오면서 불편하다고 생각한걸 간단히 하고 싶었었다:&#xA;불편함들 빌드 디렉토리 Projectile을 사용하니까 프로젝트 디렉토리는 관리가 쉬운데, 빌드 디렉토리는 관리가 어려웠다.&#xA;아예 Projectile이 추론하는 디렉토리 바깥에 빌드 디렉토리는 위치하는 경우도 있으니까.&#xA;예) GNU Autotools configure 이나 CMake으로 작업할 때, 소스트리 바깥에 빌드 디렉토리를 걸어놓아서 정리를 깔끔하게 할 수 있으니까. 그런데 이 &amp;#39;빌드 디렉토리&amp;#39;가 중요한게,&#xA;말그대로 컴파일한 .o 파일이나 최종 결과 실행파일 등이 여기에 쌓이니까 디버깅, 테스트를 위해서 실행파일을 실행하거나, 심지어 make 이나 ninja 같은 빌드 커맨드를 실행하기 위해서도 빌드 디렉토리를 지정하거나 이동해서 실행해야 하니까 귀찮다.</description>
    </item>
    <item>
      <title>Hololog Perl/CLI 버젼</title>
      <link>https://ageldama.github.io/posts/2019-12dec/hololog-perl-cli-1st-rel/</link>
      <pubDate>Tue, 17 Dec 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/hololog-perl-cli-1st-rel/</guid>
      <description>https://github.com/ageldama/hololog-perl-cli&#xA;한줄씩 메모를 하는걸 좋아하고, 그냥 데스크탑에서 PDF을 읽거나 웹페이지를 읽으면서 어딘가에 생각난거나 이해한걸 필기하면서 진행하고 싶어서 만들었다.&#xA;다음 트윗 타래에서 이야기한것처럼, 그냥 트위터 비밀계를 써도 괜찮지만, 그것도 너무 웹브라우져 열고 하다보면 산만해져서.&#xA;tweet 1206138361968070656 처음 시작은 Unix/GNU cat 을 간단하게 터미널에서 쓰면 된다는 생각이 들었다.&#xA;1 cat &amp;gt;&amp;gt; foo.txt ..그런데 유닉스가 아닌 사람들, 윈도를 쓰는 사람들은 어떻게 하지?&#xA;1 copy con foo.txt ..사실 위와 같이 cmd.exe 에서 실행해도 되겠지만, 뭔가 그래도 윈도 사용자들이나 터미널 화면을 무서워하는 사람들이 저런거 좋아할까.</description>
    </item>
    <item>
      <title>radio-recorder 프로젝트 설명</title>
      <link>https://ageldama.github.io/posts/2019-12dec/dissect-radio-gaga/</link>
      <pubDate>Wed, 11 Dec 2019 01:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/dissect-radio-gaga/</guid>
      <description>2년전쯤에 한국 라디오를 혼자 듣고 싶었었다. 하지만 시차가 많이 나는 지역에 살았었다. (8시간 정도 느림)&#xA;그래서 한국 인터넷 라디오를 녹음해서 개인적으로 들을 수 있다면 좋겠다는 아이디어로 작업했던 프로젝트 소스코드를 공개한다.&#xA;https://github.com/ageldama/radio-recorder&#xA;방송사의 인터넷 라디오를 녹음 하는 스크립트는 커밋에서 제외하고 공개한다. 이는 방송사에게 문제가 될 수 있으므로 개인적으로 알아내서 사용하고 타인과 공유하지 않기를 바란다.&#xA;프로그램 구성 cron 서버 지정된 시간에 녹음/인코딩 스크립트를 실행하는 스케쥴을 담당한다. 오래된 임시 파일 정리 등등도. 한국의 시간대와 내가 있는 시간대가 달라서 다른 cron scheduler을 쓰지 않고 그냥 짰었던거 같다.</description>
    </item>
    <item>
      <title>Org 파일으로 Hugo 포스팅 테스트</title>
      <link>https://ageldama.github.io/posts/2019-12dec/foo/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/foo/</guid>
      <description>적당히 잘 동작하는거 같으니 앞으로는 그냥 혼란스러운 Markdown 대신에 그냥 Org 파일으로 블로깅 하며 될거 같다. 행벜.&#xA;예전 버젼 Hugo에서는 지원을 제대로 못하던거 같은데, 어느샌가 업데이트 하니까 되는거 같아서 그냥 슬그머니 쓰기로. https://gohugo.io/content-management/formats/&#xA;기존 마크다운들도 인라인 이미지 문법을 바꾸고, ToC 표시 설정도 바뀌어서 조금 변경.&#xA;아쉬운건 여전히 Org 파일에서 ToC 지원은 빠져 있는거 같아서… https://github.com/snosov1/toc-org 설치해봤다. 그냥 고민할 필요가 없었구나. ㅋ&#xA;제일 좋은건 code syntax highlight이 예뻐졌다.&#xA;Table of Contents &amp;lt;– :TOC: –&amp;gt; foobar</description>
    </item>
    <item>
      <title>First release of cl-state-machine</title>
      <link>https://ageldama.github.io/posts/2019-12dec/cl-state-machine-1st-release/</link>
      <pubDate>Mon, 09 Dec 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/cl-state-machine-1st-release/</guid>
      <description>Made a small state machine library/DSL in/for CommonLisp.&#xA;https://github.com/ageldama/cl-state-machine</description>
    </item>
    <item>
      <title>커먼리습 설정하기, ASDF 시스템 코드를 받기</title>
      <link>https://ageldama.github.io/posts/2019-12dec/tips-ecl-clisp/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-12dec/tips-ecl-clisp/</guid>
      <description>1. ASDF을 최신 버젼으로 설정한다 (이부분에서 많이 고생했는데) SBCL와 다르게 CLISP, ECL 은 최신 버젼의 ASDF을 내장한걸 패키징해놓지 않았다.&#xA;대부분은 문제가 없이 동작하지만, 내가 작성한 커먼리습 시스템에서 실행파일을 빌드할 때 문제가 많았다.&#xA;ASDF 의 최신 버젼을 git clone 해서 적당한 디렉토리에 받는다. https://common-lisp.net/project/asdf/ make을 내려받은 ASDF 디렉토리에서 실행한다. 실행하면 build/asdf.lisp 파일으로 한 파일으로 뭉쳐서 로딩하게 편안한 파일을 생성해준다. 내 커먼리습 구현체의 시작설정파일 맨 앞에 다음처럼 추가한다. (load &amp;quot;~/local/asdf/build/asdf&amp;quot;) 여기서 나는 $HOME/local/asdf/ 에 ASDF을 받았다고 가정.</description>
    </item>
    <item>
      <title>(Common Lisp의 어두운 면) Equality</title>
      <link>https://ageldama.github.io/posts/2019-11nov/the-dark-side-of-cl-equality/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-11nov/the-dark-side-of-cl-equality/</guid>
      <description>오늘은 커먼리습의 어두운 면을 이야기 해볼까. 보통 나는 리습 팬보이니까 리습에 대해 불리한 이야기는 잘 쓰지 않는거 같아서 한번 써보기로 생각했다. 그리고 놀랍게도 이 글의 끝에 가서는 다시 이런 리습의 결점을 리습의 위대함으로 승화시키는 단계까지 끌어가 보도록 하려고함.&#xA;뭐 커먼리습의 CLHS - HyperSpec을 읽다보면 비슷한데 아주 약간씩 미묘하게 달라서 지원하는 것들이 있다:&#xA;let Special Operator LET, LET* Special Operator FLET, LABELS, MACROLET map Function MAP Function MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON Function MAP-INTO prog Macro PROG1, PROG2 Special Operator PROGN Macro PROG, PROG* Special Operator PROGV &amp;hellip;그밖에도 좀 더 있을듯?</description>
    </item>
    <item>
      <title>(소프트웨어 고고학) 어째서 `String#replaceAll`처럼 메서드 경로의 구분자로 `#`을 쓸까?</title>
      <link>https://ageldama.github.io/posts/2019-11nov/why-sharpsign-in-method-path/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-11nov/why-sharpsign-in-method-path/</guid>
      <description>오늘 아침 다음은 오늘 아침 트위터의 타임라인에서 내가 스쳐본 한 스크린샷의 일부이다:&#xA;1&#xA;&amp;hellip;뭐에 느낌을 받았냐하면, 바로 저 String#replace(..) 이라는 부분이다. (다른 부분에서는 String.prototype.replace(..) 와 같이 썼는데 굳이 저기서만 갑자기 튀어나온 표기법)&#xA;사실 나도 종종 내가 작업한 코드의 문서를 쓰거나2 아니면 다른 사람과 텍스트로 대화를 해야할 때 이렇게 표기를 해왔었다.3&#xA;각각의 언어들에서 (내가 생각하는) 저렇게 표기하는 근거들은 다음과 같다:&#xA;Java: https://www.oracle.com/technetwork/articles/java/index-137868.html @see Component#getGraphics() JavaDoc안에서 다른 메서드, 필드를 참고로 넣고 싶을 때 이게 표준표기법이고 javadoc도 요렇게 써줘야 링크처리를 해준다.</description>
    </item>
    <item>
      <title>cl-toy-stack-lang 첫번째 버젼과 작업하면서 깨달은것</title>
      <link>https://ageldama.github.io/posts/2019-10oct/cl-toy-stack-lang/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-10oct/cl-toy-stack-lang/</guid>
      <description>일단 첫번째 버젼 다 만들었다.&#xA;https://github.com/ageldama/cl-toy-stack-lang/releases/tag/v0.1.0&#xA;그냥 장난으로 인터프리터도 아니라 그냥 eval 이용한 간단한 파서도 필요없이 lexer만으로 만들만한 Forth 비슷한 언어를 만듬.&#xA;명령어도 실용적인 목적이 아닌만큼 그냥 문자열 장난 밖엔 없다.&#xA;느낀점 라이브러리 좋은거 갖다 잘쓰자 uiop 같은거, feature-expression 삽질을 적게하거나 안해도됨. 더 portable하고 잘 굴러가는. Test! 3. 짜고 하나씩 진화시켜가면서 다시 돌리는 재미. Idiomatic하게 그리고 역시 Test! ..처음엔 그냥 전역변수에 상태를 갖도록 만들고, 그걸 dynamic binding으로 바꿔서 파라미터화하고, 또 그걸 다시 상태를 캡슐화하는 클래스로 감싸고, 처음엔 단순하게 리습스럽게 짜고 그걸 진화시키고, 그리고 역시 다시 테스트.</description>
    </item>
    <item>
      <title>rutils으로 커먼리습 확장해서 clojure 비슷하게, 더 편하게</title>
      <link>https://ageldama.github.io/posts/2019-10oct/cl-rutils/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:01 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-10oct/cl-rutils/</guid>
      <description>커먼리습은 CLHS 이후로 언어 자체 정의는 변하지 않았다.&#xA;구현체마다 조금씩 확장이 있을수도 있지만 딱히 그렇게 하지도 않는거 같다. 그럴만도 하다고 생각하는게 어차피 커먼리습에서 lisp reader을 확장하는게 CLHS에서 정의해놓은 기능 중 하나이고, 구현체들도 스펙을 잘 구현해놓았으니까.&#xA;결국 커먼리습에서 문법이나 그런게 조금 마음에 안들거나 확장하고 싶으면 언제든지 매크로를 만들듯이 확장하면 되니까.&#xA;&amp;lsquo;커먼리습 언어 자체를 커먼리습으로 프로그램 할 수 있다&amp;rsquo;&#xA;이런 커먼리습 확장 &amp;lsquo;라이브러리&amp;rsquo; 들이 여러가지 있는데, 가장 요즘에 쓸만할거 같다고 생각하는건 rutils이다. https://github.</description>
    </item>
    <item>
      <title>CFFI으로 CommonLisp 2d array을 Foreign function으로 전달하기</title>
      <link>https://ageldama.github.io/posts/2019-03mar/cffi-2d-array/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-03mar/cffi-2d-array/</guid>
      <description>https://github.com/ageldama/cffi-2d-array-hello&#xA;cffi:with-foreign-array이 CFFI manual에 없어서 처음에 좀 골치아팠음.&#xA;리습 어레이를 복사해서 매핑해줌.</description>
    </item>
    <item>
      <title>Ivy/Counsel으로 바꾸기, 기능들 만들기 (w/ C&#43;&#43;지원, &#43;&#43;rmsbolt)</title>
      <link>https://ageldama.github.io/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</link>
      <pubDate>Tue, 26 Feb 2019 01:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-02feb/counsel-ivy&#43;cpp-ide/</guid>
      <description>최근에 이맥스 설정을 Helm기반에서 Ivy/Counsel으로 전부 바꿨다.&#xA;더 가볍고, 적당히 잘 동작하고, Ripgrep이랑 기본적으로 설정이 가능해서 편함.&#xA;거기에 C-c C-o (ivy-occur) + wgrep이 Helm에선 동작할때가 그때그때 기능에 따라 달라서 짜증나고, 심지어 플러그인을 설정해서 써야하거나 해서 정말 좋아하는 기능인데 우울하게 만들었는데, Ivy이 훨씬 깔끔하게 동작하고 일관성있게 잘 동작함.&#xA;처음에는 Helm에서 하는 기능들을 그대로 옮기려고만 생각하다가, 오히려 Ivy에 맞춰서 내가 익숙해지고, 더 낫게 할 방법들이 있어서 그냥 내가 adopt해서 편안해졌다.&#xA;CMake + compile_commands.</description>
    </item>
    <item>
      <title>Golang Goroutine, Channel, I/O 그리고 Scheduler 이해해보기</title>
      <link>https://ageldama.github.io/posts/2019-02feb/2019-02feb07thu-gosched-fun/</link>
      <pubDate>Thu, 07 Feb 2019 15:30:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2019-02feb/2019-02feb07thu-gosched-fun/</guid>
      <description>Go언어를 요즘에 진지하게 생각하고 계속해서 자료를 찾아보며 익히고 있다.&#xA;가장 흥미있는 부분은 Goroutine scheduler 구현과 I/O시스템을 어떻게 만들었을까인데, 아직은 소스코드를 뜯어 읽고 하지는 못하지만, 그냥 내가 만들었다면 아마 이렇지 않을까 하는 정도의 추측을 갖고 반대로 예제들을 만들어보며 확인해보고 있다.1&#xA;우선 현재의 추측은 다음과 같다.&#xA;GOMAXPROCS 같은걸 이용해서 실행시간에는 필요한만큼만 최소한으로만 OS Thread을 시작하는듯. 2 너무 많은 스레드가 있어도 어차피 Context switching 비용만 늘어나고 별 의미는 커녕 더 나쁠 수 있으니까. Goroutine들은 Go runtime의 Scheduler이 서로 실행기회를 나눠준다.</description>
    </item>
    <item>
      <title>ASDF으로 간단한 의존성 연결과 로딩하기</title>
      <link>https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/</link>
      <pubDate>Sat, 03 Nov 2018 19:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2018-11nov/cl-asdf-custom-load-script/</guid>
      <description>System? 이런게 왜 필요하지? require있잖아 대부분의 유명한 프로그래밍언어들이 커먼리습의 System 에 대응하는 기능이 명확하게 없으니까, 다른 프로그래밍 하거나 하는 방법으로 이야기를 하지는 않아야겠다.1&#xA;https://lispcookbook.github.io/cl-cookbook/systems.html 에서 마음에 드는 설명을 찾을수 있다.&#xA;A system is a collection of Lisp files that together constitute an application or a library, and that should therefore be managed as a whole. A system definition describes which source files make up the system, what the dependencies among them are, and the order they should be compiled and loaded in.</description>
    </item>
    <item>
      <title>CQuery &#43; LSP vs CMake-IDE &#43; RTags</title>
      <link>https://ageldama.github.io/posts/2018-09sep/cquery-vs-cmake-ide/</link>
      <pubDate>Sun, 23 Sep 2018 12:00:00 +0900</pubDate>
      <guid>https://ageldama.github.io/posts/2018-09sep/cquery-vs-cmake-ide/</guid>
      <description>LSP + CQuery을 써보려고 했는데, 결국 CMake-IDE + RTags 조합으로 원래대로 쓰게될거 같아. :&#xA;_build/ 와 같이 CMake, Ninja, Makefile등의 파일들을 별도의 디렉토리로 만들어서 필드하고 싶은데, 제대로 지원을 못한다. 1. 그냥 프로젝트 소스코드랑 같이 generate하고 gcc등의 중간 파일이 모두 같이 남아서 지저분해져서 싫어함. 아직은 별로 내 마음에 꼭 들게 만들기는 어려울거 같아서. 그래도 인상적이었던 부분들:&#xA;flycheck에 전용으로 연동되어 있는 점. company-lsp이 생각보다 훨씬 부드럽고 자동완성 잘되는거. 미래에는 그냥 LSP기반만 남을거 같아서, 이것도 &amp;ldquo;helm-rg의 모험&amp;quot;처럼 아직은 완전히 전환은 못할거 같긴하다.</description>
    </item>
    <item>
      <title>예전 모나드를 이용한 비동기코드의 정리에 대한 아이디어를 다시 생각해보기</title>
      <link>https://ageldama.github.io/posts/2017/2017-02-26-aync-rxjava-and-monad/</link>
      <pubDate>Sun, 26 Feb 2017 13:50:00 +0100</pubDate>
      <guid>https://ageldama.github.io/posts/2017/2017-02-26-aync-rxjava-and-monad/</guid>
      <description>예전 내가 썼던 블로그가 갑자기 떠올랐다. http://ageldama.blogspot.de/2012/03/nodejs-haskell-io-monad.html&#xA;내용은,&#xA;콜백헬 싫다. 그런데, 하스켈의 IO Monad처럼 imperative code을 작성할 수 있으면, 3. 이것들끼리의 제어권을 주고 받는걸 event loop측에서 제어하면서도, 4. 각각의 statements끼리 그냥 주욱 흐름대로 작성한것과 다르지 않게 짜기 쉽다. 굳이 이 얘기 왜 하냐하면, 사실 요즘에 RxJava2 보고, Python3에서 asyncio 같은거 보면서 이런거, 그러니까 결국엔 모나드스러운 체이닝을 구현하고, 그걸로 콜백들을 풀어서 잘 해결하고 있는거 같은 인상이 들어서.&#xA;결론? 내 아이디어 부심. 그리고 조금 더 잘 생각하고 실제로 어떻게 구현할지 고민해봤다면 좋았을거라는, 나 자신의 능력 한탄하기.</description>
    </item>
  </channel>
</rss>
